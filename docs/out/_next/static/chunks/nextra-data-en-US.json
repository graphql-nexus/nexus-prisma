{"/":{"title":"Home","data":{"":""}},"/roadmap":{"title":"Roadmap","data":{"":"","done#Done":"(#4) Support for Prisma Model field types that map to standard GraphQL scalars\n(#8) Support for Prisma Model field types of DateTime & Json\n(#16) Support for Prisma enums\n(#25, #36) Basic support for Prisma Model field types relating to other Models 1:1\n(#38) Basic support for Prisma Model field types relating to other Models 1:n\n(#43) Support for runtime and gentime settings\n(#61) JSDoc for settings/$settings\n(#68) Support for Prisma Model field type Bytes","shortterm#Shortterm":"(#59) Support for Prisma Model field type BigInt\n(#94) Support for Prisma Model field type Decimal\nImproved JSDoc for relation 1:1 & 1:n fields","midterm#Midterm":"Support for Prisma Model field types relating to other Models n:n\nSupport for relation field ordering parameters\n(#83) Support for relation field filtering parameters\nSupport for relation field pagination parameters","longterm#Longterm":"Nexus Plugin? t.model? t.crud?\n..."}},"/docs/recipes":{"title":"Recipes","data":{"":"","project-relation-with-custom-resolver-logic#Project relation with custom resolver logic":"Nexus Prisma generates default GraphQL resolvers for your model relation fields. However you may want to run custom logic in the resolver. This is easy to do. The following show a few ways.\nWrap Style You can access the default resolver within your own custom resolver.\nobjectType({\nname: User.$name,\ndefinition(t) {\nt.field(User.id)\nt.field({\n...User.posts,\nasync resolve(...args) {\n// Your custom before-logic here\nconst result = await User.posts.resolve(...args)\n// Your custom after-logic here\nreturn result\n},\n})\n},\n})\n\nReplace Style You can simply opt out of using the default resolver completely:\nobjectType({\nname: User.$name,\ndefinition(t) {\nt.field(User.id)\nt.field({\n...User.posts,\nasync resolve(...args) {\n// Your custom logic here\n},\n})\n},\n})","supply-custom-scalars-to-your-graphql-schema#Supply custom scalars to your GraphQL schema":"The following is a brief example how you could add your own custom GraphQL custom scalars to satisfy Nexus Prisma. Note that most of the time using the defaults exported by nexus-prisma/scalars will probably be good enough for you.\nimport { GraphQLScalarType } from 'graphql'\nimport { JSONObjectResolver, DateTimeResolver } from 'graphql-scalars'\nimport { asNexusMethod, makeSchema } from 'nexus'\n\nconst jsonScalar = new GraphQLScalarType({\n...JSONObjectResolver,\n// Override the default 'JsonObject' name with one that matches what Nexus Prisma expects.\nname: 'Json',\n})\n\nconst dateTimeScalar = new GraphQLScalarType(DateTimeResolver)\n\nmakeSchema({\ntypes: [asNexusMethod(jsonScalar, 'json'), asNexusMethod(dateTimeScalar, 'dateTime')],\n})"}},"/docs/usage":{"title":"Usage","data":{"":"Install dependencies\nnpm add nexus-prisma nexus graphql @prisma/client\nnpm add --dev prisma\n\nnexus graphql and @prisma/client are peer dependencies. prisma is for the Prisma CLI which\nyou'll probably want during development.\n\nIf you use nexus@=<1.0 then you must use t.field(<NAME>, <CONFIG>) instead of t.field(<CONFIG>). The Nexus Prisma docs assume the latter form.\n\nAdd a nexus-prisma generator block to your Prisma Schema.\nRun prisma generate in your terminal.\nImport models from nexus-prisma and then pass them to your Nexus type definition and field definition configurations. In this way you will be effectively projecting models from your data layer into GraphQL types in your API layer.","example#Example":"generator client {\nprovider = \"prisma-client-js\"\n}\n\ngenerator nexusPrisma {\nprovider = \"nexus-prisma\"\n}\n\n/// This is a user!\nmodel User {\n/// This is an id!\nid  String  @id\n}\n\nprisma generate\n\nimport { User } from 'nexus-prisma'\nimport { makeSchema, objectType } from 'nexus'\n\nexport const schema = makeSchema({\ntypes: [\nobjectType({\nname: User.$name\ndescription: User.$description\ndefinition(t) {\nt.field(User.id)\n// t.field(User.id.name, User.id)    <-- For nexus@=<1.0 users\n}\n})\n]\n})"}},"/docs/architecture":{"title":"Architecture","data":{"":"Understanding the following information should not be required knowledge for using Nexus Prisma. It is primarily here for internal maintenance and collaboration. But we're happy for whatever benefit you get out of it too.","system#System":"You or a script (CI, programmatic, etc.) run $ prisma generate.\nPrisma generator system reads your Prisma schema file\nPrisma generator system runs the Nexus Prisma generator passing it the \"DMMF\", a structured representation of your Prisma schema.\nNexus Prisma generator reads your Nexus Prisma generator configuration if present.\nNexus Prisma generator writes generated source code. By default into a special place within the nexus-prisma package in your node_modules. However, you can configure this location.\nLater when you run your code it imports nexus-prisma which hits the generated entrypoint.\nThe generated runtime is actually thin, making use of a larger static runtime.","package-exports#Package Exports":"When users choose a custom Nexus Prisma output directory the generated runtime needs to import the static runtime. There are a few things that need to happen in order for this to work:\nThe output's imports needs to specify the package to import from\nThe output's imports needs to specify the subpath to import from\n\nFor (1) we import from 'nexus-prisma'. We just rely on the assumption that the user is outputting into a directory where eventually node_modules/nexus-prisma will should up in the CWD path as Node module resolution algorithm executes.For (2) we look if user is outputting ESM or CJS (gentime config) and based on that access either /dist-cjs or /dist-esm. In order to support this we need to break the encapsulation provided by package.json exports field. We need to configure in it:\n\"./*\": {\n\"default\": \"./*.js\"\n}\nWe cannot do something slightly cleaner either like this:\n\"./_/*\": {\n\"require\": \"./dist-cjs/*.js\",\n\"import\": \"./dist-esm/*.js\"\n}\nBecause ncc, at least, does not support resolving .../_/... imports to what is specified in the package exports."}},"/docs/features":{"title":"Features","data":{"":"The following use abbreviated examples that skip a complete setup of passing Nexus type definition to Nexus'\nmakeSchema. If you are new to Nexus, consider reading the official Nexus\ntutorial before jumping into Nexus Prisma.","type-safe-generated-library-code#Type-safe Generated Library Code":"Following the same philosophy as Prisma Client, Nexus Prisma uses generation to create an API that feels tailor made for your project.\nmodel User {\nid  String  @id\n}\n\nimport { User } from 'nexus-prisma'\nimport { objectType } from 'nexus'\n\nobjectType({\nname: User.$name\ndescription: User.$description\ndefinition(t) {\nt.field({\ntype: User.id.type,\ndescription: User.id.description\n})\n}\n})","project-enums#Project Enums":"Every enum defined in your Prisma schema becomes importable as a Nexus enum type definition configuration. This makes it trivial to project enums from your database layer into your API layer.\nenum SomeEnum {\nfoo\nbar\n}\n\nimport { SomeEnum } from 'nexus-prisma'\nimport { enumType } from 'nexus'\n\nSomeEnum.name //    'SomeEnum'\nSomeEnum.members // ['foo', 'bar']\n\nenumType(SomeEnum)","project-scalars#Project Scalars":"Like GraphQL, Prisma has the concept of scalar types. Some of the Prisma scalars can be naturally mapped to standard GraphQL scalars. The mapping is as follows:Prisma Standard Scalar to GraphQL Standard Scalar Mapping\nPrisma\tGraphQL\tBoolean\tBoolean\tString\tString\tInt\tInt\tFloat\tFloat\tString with @id\tID\tInt with @id\tID | Int (configurable)\nHowever some of the Prisma scalars do not have a natural standard representation in GraphQL. For these cases Nexus Prisma generates code that references type names matching those scalar names in Prisma. Then, you are expected to define those custom scalar types in your GraphQL API. Nexus Prisma ships with pre-defined mappings in nexus-prisma/scalars you can use for convenience. The mapping is as follows:Prisma Standard-Scalar to GraphQL Custom-Scalar Mapping\nPrisma\tGraphQL\tNexus t Helper\tGraphQL Scalar Implementation\tAdditional Info\tJson\tJson\tjson\tJsonObject\t\tDateTime\tDateTime\tdateTime\tDateTime\t\tBigInt\tBigInt\tbigInt\tBigInt\tJavaScript BigInt\tBytes\tBytes\tbytes\tByte\tNode.js Buffer\tDecimal\tDecimal\tdecimal\t(internal)\tUses Decimal.js\n\nNot all Prisma scalar mappings are implemented yet: Unsupported\n\nBigInt is supported in Node.js since version\n10.4.0\nhowever to support BigInt in JSON.parse/JSON.stringify you must use\njson-bigint-patch otherwise BigInt values will be\nserialized as strings.\nYou can use your own GraphQL Scalar Implementation, however, you must adhere to the above Prisma/GraphQL name mapping defined above.Here is an example using Nexus Prisma's pre-defined GraphQL custom scalars:\nimport NexusPrismaScalars from 'nexus-prisma/scalars'\nimport { makeSchema } from 'nexus'\n\nmakeSchema({\ntypes: [NexusPrismaScalars],\n})\nThere is a recipe below showing how to add your own custom scalars if you want.","project-relations#Project Relations":"You can project relations into your API with Nexus Prisma. Nexus Prisma even includes the resolver you'll need at runtime to fulfill the projection by automating use of your Prisma Client instance.Please note that not all kinds of relationships are supported yet. Details about projecting each kind of relation are documented in their respective sections. This section only contains general documentation common to all.To project relations you must by default expose an instance of Prisma Client on the GraphQL context under the key name prisma. You can customize which context property Nexus Prisma should look for your Prisma Client.","example-exposing-prisma-client-on-graphql-context-with-apollo-server#Example: Exposing Prisma Client on GraphQL Context with Apollo Server":"import { ApolloServer } from 'apollo-server'\nimport { PrismaClient } from '@prisma/client'\nimport schema from './your/schema/somewhere'\n\nconst prisma = new PrismaClient()\n\nnew ApolloServer({\nschema,\ncontext() {\nreturn {\nprisma,\n}\n},\n})","project-11-relation#Project 1:1 Relation":"You can project 1:1 relationships into your API.","example-tests#Example: Tests":"The integration test suite is a useful reference as it is declarative (easy to read) and gives a known-working example spanning from database all the way to executed GraphQL document.\nTests\nSnapshots","example-full-11#Example: Full 1:1":"// Database Schema\n\nmodel User {\nid         String  @id\nprofile    Profile @relation(fields: [profileId], references: [id])\nprofileId  String\n}\n\nmodel Profile {\nid      String  @id\nuser    User?\n}\n\n// API Schema\n\nimport { User, Profile } from 'nexus-prisma'\n\nqueryType({\ndefinition(t) {\nt.nonNull.list.nonNull.field('users', {\ntype: 'User',\nresolve(_, __, ctx) {\nreturn ctx.prisma.user.findMany()\n},\n})\n},\n})\n\nobjectType({\nname: User.$name,\ndefinition(t) {\nt.field(User.id)\nt.field(User.profile)\n},\n})\n\nobjectType({\nname: Profile.$name,\ndefinition(t) {\nt.field(Profile.id)\n},\n})\n\n# API Schema Represented in GraphQL SDL (this is generated by Nexus)\n\ntype Query {\nusers: [User!]!\n}\n\ntype User {\nid: ID\nprofile: Profile\n}\n\ntype Profile {\nid: ID\n}\n\n// Example Database Data (for following example)\n\nawait prisma.user.create({\ndata: {\nid: 'user1',\nprofile: {\ncreate: {\nid: 'profile1',\n},\n},\n},\n})\n\n# Example API Client Query\n\nquery {\nusers {\nid\nprofile {\nid\n}\n}\n}\n\n{\n\"data\": {\n\"users\": [\n{\n\"id\": \"user1\",\n\"profile\": {\n\"id\": \"profile1\"\n}\n}\n]\n}\n}","limitation-nullable-on-without-relation-scalar-side#Limitation: Nullable on Without-Relation-Scalar Side":"Prisma requires that a 1:1 relationship has one side that is optional. For example in the following it is not possible for Profile to have a required relationship to User. For more detail you can read the Prisma docs about this here.\nmodel User {\nid         String  @id\nprofile    Profile @relation(fields: [profileId], references: [id])\nprofileId  String\n}\n\nmodel Profile {\nid      String  @id\nuser    User?  // <--  \"?\" required\n}\nPrisma inherits this limitation from databases. In turn Nexus Prisma inherits this limitation from Prisma. For example consider this projection and then look at the resulting GraphQL SDL representation.\nimport { User, Profile } from 'nexus-prisma'\n\nobjectType({\nname: User.$name,\ndefinition(t) {\nt.field(User.id)\nt.field(User.profile)\n},\n})\n\nobjectType({\nname: Profile.$name,\ndefinition(t) {\nt.field(Profile.id)\nt.field(User.profile)\n},\n})\n\ntype User {\nid: ID\nprofile: Profile!\n}\n\ntype Profile {\nid: ID\nuser: User # <-- Nullable!\n}\nThis limitation may be a problem for your API. There is an issue track this that you can subscribe to if interested. As a workaround for now you can do this:\nobjectType({\nname: Profile.$name,\ndefinition(t) {\nt.field(Profile.id)\nt.field({\n...User.profile,\ntype: nonNull(User.profile.type),\n})\n},\n})","project-1n-relation#Project 1:n Relation":"You can project 1:n relationships into your API.","example-tests-1#Example: Tests":"The integration test suite is a useful reference as it is declarative (easy to read) and gives a known-working example spanning from database all the way to executed GraphQL document.\nTests\nSnapshots","example-full-1n#Example: Full 1:n":"// Database Schema\n\nmodel User {\nid         String    @id\nposts      Post[]\n}\n\nmodel Post {\nid        String  @id\nauthor    User?   @relation(fields: [authorId], references: [id])\nauthorId  String\n}\n\n// API Schema\n\nimport { User, Post } from 'nexus-prisma'\n\nqueryType({\ndefinition(t) {\nt.nonNull.list.nonNull.field('users', {\ntype: 'User',\nresolve(_, __, ctx) {\nreturn ctx.prisma.user.findMany()\n},\n})\n},\n})\n\nobjectType({\nname: User.$name,\ndefinition(t) {\nt.field(User.id)\nt.field(User.posts)\n},\n})\n\nobjectType({\nname: Post.$name,\ndefinition(t) {\nt.field(Post.id)\n},\n})\n\n# API Schema Represented in GraphQL SDL (this is generated by Nexus)\n\ntype Query {\nusers: [User]\n}\n\ntype User {\nid: ID!\nposts: [Post!]!\n}\n\ntype Post {\nid: ID!\n}\n\n// Example Database Data (for following example)\n\nawait prisma.user.create({\ndata: {\nid: 'user1',\nposts: {\ncreate: [{ id: 'post1' }, { id: 'post2' }],\n},\n},\n})\n\n# Example API Client Query\n\nquery {\nusers {\nid\nposts {\nid\n}\n}\n}\n\n{\n\"data\": {\n\"users\": [\n{\n\"id\": \"user1\",\n\"posts\": [\n{\n\"id\": \"post1\"\n},\n{\n\"id\": \"post2\"\n}\n]\n}\n]\n}\n}","projecting-nullability#Projecting Nullability":"Currently nullability projection is not configurable. This section describes how Nexus Prisma handles it.\nNexus Prisma Projects\n│\n│\nDB Layer (Prisma)           → → ┴ → →           API Layer (GraphQL)\n–––––––––––––––––                               –––––––––––––––––––\n\nNullable Field Relation                         Nullable Field Relation\n\nmodel A {                                       type A {\nfoo Foo?                                        foo: Foo\n}                                               }\n\n\n\nNon-Nullable Field Relation                     Non-Nullable Field Relation\n\nmodel A {                                       type A {\nfoo Foo                                         foo: Foo!\n}                                               }\n\n\n\nList Field Relation                             Non-Nullable Field Relation Within Non-Nullable List\n\nmodel A {                                       type A {\nfoos Foo[]                                      foo: [Foo!]!\n}                                               }\nIf a findOne or findUnique for a non-nullable Prisma field return null for some reason (e.g. data corruption in the database) then the standard GraphQL null propagation will kick in.","prisma-client-rejectonnotfound-handling#Prisma Client rejectOnNotFound Handling":"Prisma Client's rejectOnNotFound feature is effectively ignored by Nexus Prisma. For example if you set rejectOnNotFound globally on your Prisma Client it will not effect Nexus Prisma when it uses Prisma Client. This is because Nexus Prisma sets rejectOnNotFound: false for every findUnique/findFirst request it sends.The reason for this design choice is that when Nexus Prisma's logic is handling a GraphQL resolver that includes how to handle nullability issues which it has full knowledge about.If you have a use-case for different behaviour please open a feature request. Also, remember, you can always override the Nexus Prisma resolvers with your own logic (recipe).","related-issues#Related Issues":"#98 Always set rejectOnNotFound to false","prisma-schema-docs-propagation#Prisma Schema Docs Propagation":"","as-graphql-schema-doc#As GraphQL schema doc":"/// A user.\nmodel User {\n/// A stable identifier to find users by.\nid  String  @id\n}\n\nimport { User } from 'nexus-prisma'\nimport { objectType } from 'nexus'\n\nUser.$description // JSDoc: A user.\nUser.id.description // JSDoc: A stable identifier to find users by.\n\nobjectType({\nname: User.$name\ndescription: User.$description\ndefinition(t) {\nt.field(User.id)\n}\n})\n\n\"\"\"\nA user.\n\"\"\"\ntype User {\n\"\"\"\nA stable identifier to find users by.\n\"\"\"\nid: ID\n}","as-jsdoc#As JSDoc":"Can be disabled in gentime settings.\n/// A user.\nmodel User {\n/// A stable identifier to find users by.\nid  String  @id\n}\n\nimport { User } from 'nexus-prisma'\n\nUser // JSDoc: A user.\nUser.id // JSDoc: A stable identifier to find users by.","rich-formatting#Rich Formatting":"It is possible to write multiline documentation in your Prisma Schema file. It is also possible to write markdown or whatever else you want.\n/// # Foo   _bar_\n/// qux\n///\n/// tot\nmodel Foo {\n/// Foo   bar\n/// qux\n///\n/// tot\nfoo  String\n}\nHowever, you should understand the formatting logic Nexus Prisma uses as it may limit what you want to achieve. The current logic is:\nStrip newlines\nCollapse multi-spaces spaces into single-space\n\nSo the above would get extracted by Nexus Prisma as if it was written like this:\n/// # Foo _bar_ qux tot\nmodel Foo {\n/// Foo bar qux tot\nfoo  String\n}\nThis formatting logic is conservative. We are open to making it less so, in order to support more expressivity. Please open an issue if you have an idea.","esm-support#ESM Support":"Nexus Prisma supports both ESM and CJS. There shouldn't be anything you need to \"do\", things should \"just work\". Here's the highlights of how it works though:\nWe publish both a CJS and ESM build to npm.\nWhen the generator runs, it emits CJS code to the CJS build and ESM code to the ESM build.\nNexus Prisma CLI exists both in the ESM and CJS builds but its built to not matter which is used. That said, the package manifest is setup to run the CJS of the CLI and so that is what ends up being used in practice.","refined-dx#Refined DX":"These are finer points that aren't perhaps worth a top-level point but none the less add up toward a thoughtful developer experience.","jsdoc#JSDoc":"Generated Nexus configuration for fields and models that you have not documented in your PSL get default JSDoc that teaches you how to do so.\nJSDoc for Enums have their members embedded","default-runtime#Default Runtime":"When your project is in a state where the generated Nexus Prisma part is missing (new repo clone, reinstalled deps, etc.) Nexus Prisma gives you a default runtime export named PleaseRunPrismaGenerate and will error with a clear message.","peer-dependency-validation#Peer-Dependency Validation":"When nexus-prisma is imported it will validate that your project has peer dependencies setup correctly.If a peer dependency is not installed it nexus-prisma will log an error and then exit 1. If its version does not satify the range supported by the current version of nexus-prisma that you have installed, then a warning will be logged. If you want to opt-out of this validation (e.g. you're using a bundler) then set an envar as follows:\nNO_PEER_DEPENDENCY_CHECK=true|1\nPEER_DEPENDENCY_CHECK=false|0","auto-import-optimized#Auto-Import Optimized":"nexus-prisma/scalars offers a default export you can easily auto-import by name: NexusPrismaScalars."}},"/docs/notes":{"title":"Notes","data":{"":"","which-should-i-use-nexus-plugin-prisma-vs-nexus-prisma-vs-vanilla-nexus#Which should I use? nexus-plugin-prisma vs nexus-prisma vs Vanilla Nexus":"","vanilla-nexus#Vanilla Nexus":"npm | githubIf stability is the most important thing for you then Prisma+Nexus vanilla is probably good for you.\npro: flexible\npro: stable\ncon: If you have a lot of boilerplate CRUD then might feel painful","nexus-plugin-prisma#nexus-plugin-prisma":"npm | githubIf automatic CRUD is the most important thing for you then maybe stick with the old nexus-prisma.\npro: rich automated CRUD featureset\ncon: not flexible\ncon: not being actively maintained\ncon: not kept up to date with Prisma\ncon: buggy","nexus-prisma#nexus-prisma":"npm | githubIf you would benefit from model projection features and are ok with using early access software then consider nexus-prisma.\npro: flexible\npro: maintained\ncon: early access, things may change, bugs may be present, features may be incomplete.","working-with-bundlers#Working with Bundlers":"","disable-peer-dependency-check#Disable Peer Dependency Check":"When working with bundlers, it probably makes sense to disable the runtime peer dependency check system since the bundle step is merging the dependency tree into a single file and may be moved to run standalone away from the original project manifest (e.g. in a docker container).Instructions to do this can be found here.","general-support#General Support":"nexus-prisma has tests showing that it supports ncc. Other bundlers are not tested and may or may not work. It is our goal however that nexus-prisma not be the reason for any popular bundler to not work on your project. So if you encounter a problem with one (e.g. parcel), open an issue here and we'll fix the issue including an addition to our test suite.","for-users-of-nexus-prisma020#For users of nexus-prisma@=<0.20":"Versions of nexus-prisma package prior to 0.20 were a completely different version of the API, and had also become deprecated at one point to migrate to nexus-plugin-prisma when Nexus Framework was being worked on. All of that is history.","for-users-of-nexus10#For users of nexus@=<1.0":"The release of Nexus 1.1 introduced an overload to t.field allowing improved usage of Nexus Prisma. The difference is as follows. Note if you prefer the older way that is and always will be supported too.\nimport { User } from 'nexus-prisma'\nimport { makeSchema, objectType } from 'nexus'\n\nexport const schema = makeSchema({\ntypes: [\nobjectType({\nname: User.$name\ndescription: User.$description\ndefinition(t) {\n+        t.field(User.id) //                 <-- for nexus@>=1.1 users\n-        t.field(User.id.name, User.id) //   <-- For nexus@=<1.0 users\n}\n})\n]\n})","supported-versions-of-node#Supported Versions Of Node":"We only officially support what we test.We test Node versions that are Active LTS and Current. For which versions of Node that equals you can refer to our tests or look here: https://nodejs.org/en/about/releases.","supported-versions-of-prismaclient#Supported Versions Of @prisma/client":"We only officially support what we test.We test Prisma Client versions 2.30.x, 2.29.x.","supported-versions-of-ts-node#Supported Versions Of ts-node":"We only officially support what we test.We test ts-node versions 10.x.Reminder: ts-node is an optional peer dep required when you are working with the gentime settings.","matrix-testing-policy#Matrix Testing Policy":"We test the latest versions of @prisma/client against Node 16 and 14 on Ubuntu, macOS, and Windows while past versions of @prisma/client are tested only against Node 16 on Ubuntu. We do this to keep the CI test matris reasonable as the number of past @prisma/client versions supported could grow long.","patch-version-support-policy#Patch Version Support Policy":"We only support the latest patch version of a minor series. For example imagine that there was a bug when nexus-prisma was integrated with @prisma/client@2.30.1 but not when integrated with @prisma/client@2.30.2. Our policy would be that users should upgrade to the latest 2.30.x version, and that we would not release any no code changes of nexus-prisma."}},"/docs/settings/runtime":{"title":"Runtime","data":{"":"","reference#Reference":"Please refer to the thorough JSDoc for reference documentation. Typically consumed in your IDE or Paka."}},"/docs/settings/gentime":{"title":"Gentime","data":{"":"You are able to control certain aspects of the Nexus Prisma code generation.","usage#Usage":"Create a configuration file named any of:\nnexusPrisma.ts  /  nexus-prisma.ts  /  nexus_prisma.ts\nIn one of the following directories:\nProject Root – The directory containing your project's package.json. Example:\n├── nexus-prisma.ts\n└── package.json\n\nPrisma Directory – The directory containing your Prisma schema. Example:\n├── prisma/nexus-prisma.ts\n└── package.json\n\n\n\nIf you have not already, install ts-node which nexus-prisma will use to read your configuration module.\nImport the settings singleton and make your desired changes. Example:\nimport { settings } from 'nexus-prisma/generator'\n\nsettings({\nprojectIdIntToGraphQL: 'ID',\n})","reference#Reference":"Please refer to the thorough JSDoc for reference documentation. Typically consumed in your IDE or Paka.","notes#Notes":"","prisma-schema-file-generator-config#Prisma Schema File Generator Config":"Nexus Prisma supports custom configuration of the output directory within the generator block within your Prisma Schema file like so:\n// prisma/schema.prisma\n\ngenerator nexusPrisma {\nprovider = \"nexus-prisma\"\noutput   = \"../generated/nexus-prisma\"\n}\nThe above is equivalent to the following:\n// prisma/nexus-prisma.ts\n\nimport { settings } from 'nexus-prisma/generator'\n\nsettings({\noutput: '../generated/nexus-prisma',\n})\nIt is considered idiomatic to use the Nexus Prisma configuration file instead of inline generator block configuration. Inline generator block configuration lacks autocomplete and inline JSDoc. The only reason output is supported is to be symmetrical with Prisma Client and thus ease onboarding."}}}