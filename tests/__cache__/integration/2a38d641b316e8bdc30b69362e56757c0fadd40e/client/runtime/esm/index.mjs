var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __markAsModule2 = (target) => __defProp2(target, "__esModule", { value: true });
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS2 = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[Object.keys(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export2 = (target, all) => {
  __markAsModule2(target);
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && key !== "default")
        __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule2 = (module2) => {
  return __reExport(__markAsModule2(__defProp2(module2 != null ? __create2(__getProtoOf2(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows2 = __commonJS2({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs7 = __require("fs");
    function checkPathExt(path6, options2) {
      var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path6.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    __name(checkPathExt, "checkPathExt");
    function checkStat(stat, path6, options2) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path6, options2);
    }
    __name(checkStat, "checkStat");
    function isexe(path6, options2, cb) {
      fs7.stat(path6, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path6, options2));
      });
    }
    __name(isexe, "isexe");
    function sync(path6, options2) {
      return checkStat(fs7.statSync(path6), path6, options2);
    }
    __name(sync, "sync");
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode2 = __commonJS2({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs7 = __require("fs");
    function isexe(path6, options2, cb) {
      fs7.stat(path6, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options2));
      });
    }
    __name(isexe, "isexe");
    function sync(path6, options2) {
      return checkStat(fs7.statSync(path6), options2);
    }
    __name(sync, "sync");
    function checkStat(stat, options2) {
      return stat.isFile() && checkMode(stat, options2);
    }
    __name(checkStat, "checkStat");
    function checkMode(stat, options2) {
      var mod2 = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
      var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
      return ret;
    }
    __name(checkMode, "checkMode");
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe2 = __commonJS2({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports2, module2) {
    var fs7 = __require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows2();
    } else {
      core = require_mode2();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path6, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject2) {
          isexe(path6, options2 || {}, function(er, is) {
            if (er) {
              reject2(er);
            } else {
              resolve2(is);
            }
          });
        });
      }
      core(path6, options2 || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    __name(isexe, "isexe");
    function sync(path6, options2) {
      try {
        return core.sync(path6, options2 || {});
      } catch (er) {
        if (options2 && options2.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
    __name(sync, "sync");
  }
});

// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which2 = __commonJS2({
  "../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports2, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path6 = __require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe2();
    var getNotFoundError = /* @__PURE__ */ __name((cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), "getNotFoundError");
    var getPathInfo = /* @__PURE__ */ __name((cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    }, "getPathInfo");
    var which = /* @__PURE__ */ __name((cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = /* @__PURE__ */ __name((i) => new Promise((resolve2, reject2) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve2(found) : reject2(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path6.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve2(subStep(p, i, 0));
      }), "step");
      const subStep = /* @__PURE__ */ __name((p, i, ii) => new Promise((resolve2, reject2) => {
        if (ii === pathExt.length)
          return resolve2(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve2(p + ext);
          }
          return resolve2(subStep(p, i, ii + 1));
        });
      }), "subStep");
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    }, "which");
    var whichSync = /* @__PURE__ */ __name((cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path6.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }, "whichSync");
    module2.exports = which;
    which.sync = whichSync;
  }
});

// ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key2 = __commonJS2({
  "../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey = /* @__PURE__ */ __name((options2 = {}) => {
      const environment = options2.env || process.env;
      const platform2 = options2.platform || process.platform;
      if (platform2 !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    }, "pathKey");
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand2 = __commonJS2({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path6 = __require("path");
    var which = require_which2();
    var getPathKey = require_path_key2();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env[getPathKey({ env })],
          pathExt: withoutPathExt ? path6.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path6.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    __name(resolveCommandAttempt, "resolveCommandAttempt");
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    __name(resolveCommand, "resolveCommand");
    module2.exports = resolveCommand;
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js
var require_escape2 = __commonJS2({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg2) {
      arg2 = arg2.replace(metaCharsRegExp, "^$1");
      return arg2;
    }
    __name(escapeCommand, "escapeCommand");
    function escapeArgument(arg2, doubleEscapeMetaChars) {
      arg2 = `${arg2}`;
      arg2 = arg2.replace(/(\\*)"/g, '$1$1\\"');
      arg2 = arg2.replace(/(\\*)$/, "$1$1");
      arg2 = `"${arg2}"`;
      arg2 = arg2.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg2 = arg2.replace(metaCharsRegExp, "^$1");
      }
      return arg2;
    }
    __name(escapeArgument, "escapeArgument");
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex2 = __commonJS2({
  "../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command2 = __commonJS2({
  "../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex2();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path6, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path6.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang2 = __commonJS2({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs7 = __require("fs");
    var shebangCommand = require_shebang_command2();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs7.openSync(command, "r");
        fs7.readSync(fd, buffer, 0, size, 0);
        fs7.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    __name(readShebang, "readShebang");
    module2.exports = readShebang;
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js
var require_parse5 = __commonJS2({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path6 = __require("path");
    var resolveCommand = require_resolveCommand2();
    var escape = require_escape2();
    var readShebang = require_readShebang2();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    __name(detectShebang, "detectShebang");
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path6.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg2) => escape.argument(arg2, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    __name(parseNonShell, "parseNonShell");
    function parse2(command, args, options2) {
      if (args && !Array.isArray(args)) {
        options2 = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options2 = Object.assign({}, options2);
      const parsed = {
        command,
        args,
        options: options2,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options2.shell ? parsed : parseNonShell(parsed);
    }
    __name(parse2, "parse");
    module2.exports = parse2;
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js
var require_enoent2 = __commonJS2({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    __name(notFoundError, "notFoundError");
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    __name(hookChildProcess, "hookChildProcess");
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    __name(verifyENOENT, "verifyENOENT");
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    __name(verifyENOENTSync, "verifyENOENTSync");
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js
var require_cross_spawn2 = __commonJS2({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = __require("child_process");
    var parse2 = require_parse5();
    var enoent = require_enoent2();
    function spawn2(command, args, options2) {
      const parsed = parse2(command, args, options2);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    __name(spawn2, "spawn");
    function spawnSync(command, args, options2) {
      const parsed = parse2(command, args, options2);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    __name(spawnSync, "spawnSync");
    module2.exports = spawn2;
    module2.exports.spawn = spawn2;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse2;
    module2.exports._enoent = enoent;
  }
});

// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name2 = __commonJS2({
  "../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS2({
  "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min2 = Math.min(r, g, b);
      const max2 = Math.max(r, g, b);
      const delta = max2 - min2;
      let h;
      let s;
      if (max2 === min2) {
        h = 0;
      } else if (r === max2) {
        h = (g - b) / delta;
      } else if (g === max2) {
        h = 2 + (b - r) / delta;
      } else if (b === max2) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min2 + max2) / 2;
      if (max2 === min2) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max2 + min2);
      } else {
        s = delta / (2 - max2 - min2);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = /* @__PURE__ */ __name(function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      }, "diffc");
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    __name(comparativeDistance, "comparativeDistance");
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max2 = Math.max(Math.max(r, g), b);
      const min2 = Math.min(Math.min(r, g), b);
      const chroma = max2 - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r) {
        hue = (g - b) / chroma % 6;
      } else if (max2 === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route2 = __commonJS2({
  "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    __name(buildGraph, "buildGraph");
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    __name(deriveBFS, "deriveBFS");
    function link2(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    __name(link2, "link");
    function wrapConversion(toModel, graph) {
      const path6 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path6.unshift(graph[cur].parent);
        fn = link2(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path6;
      return fn;
    }
    __name(wrapConversion, "wrapConversion");
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS2({
  "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = /* @__PURE__ */ __name(function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      }, "wrappedFn");
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    __name(wrapRaw, "wrapRaw");
    function wrapRounded(fn) {
      const wrappedFn = /* @__PURE__ */ __name(function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      }, "wrappedFn");
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    __name(wrapRounded, "wrapRounded");
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS2({
  "../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    }, "wrapAnsi16");
    var wrapAnsi256 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    }, "wrapAnsi256");
    var wrapAnsi16m = /* @__PURE__ */ __name((fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    }, "wrapAnsi16m");
    var ansi2ansi = /* @__PURE__ */ __name((n) => n, "ansi2ansi");
    var rgb2rgb = /* @__PURE__ */ __name((r, g, b) => [r, g, b], "rgb2rgb");
    var setLazyProperty = /* @__PURE__ */ __name((object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    }, "setLazyProperty");
    var colorConvert;
    var makeDynamicStyles = /* @__PURE__ */ __name((wrap, targetSpace, identity2, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert2();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity2, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    }, "makeDynamicStyles");
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    __name(assembleStyles, "assembleStyles");
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS2({
  "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS2({
  "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag2();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    __name(translateLevel, "translateLevel");
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min2 = forceColor || 0;
      if (env.TERM === "dumb") {
        return min2;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min2;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min2;
    }
    __name(supportsColor, "supportsColor");
    function getSupportLevel(stream3) {
      const level = supportsColor(stream3, stream3 && stream3.isTTY);
      return translateLevel(level);
    }
    __name(getSupportLevel, "getSupportLevel");
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js
var require_util3 = __commonJS2({
  "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = /* @__PURE__ */ __name((string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    }, "stringReplaceAll");
    var stringEncaseCRLFWithFirstIndex = /* @__PURE__ */ __name((string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    }, "stringEncaseCRLFWithFirstIndex");
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js
var require_templates2 = __commonJS2({
  "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    __name(unescape, "unescape");
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    __name(parseArguments, "parseArguments");
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    __name(parseStyle, "parseStyle");
    function buildStyle(chalk11, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk11;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    __name(buildStyle, "buildStyle");
    module2.exports = (chalk11, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk11, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk11, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js
var require_source2 = __commonJS2({
  "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles2();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color2();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util3();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = /* @__PURE__ */ __name((object, options2 = {}) => {
      if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options2.level === void 0 ? colorLevel : options2.level;
    }, "applyOptions");
    var ChalkClass = class {
      constructor(options2) {
        return chalkFactory(options2);
      }
    };
    __name(ChalkClass, "ChalkClass");
    var chalkFactory = /* @__PURE__ */ __name((options2) => {
      const chalk12 = {};
      applyOptions(chalk12, options2);
      chalk12.template = (...arguments_) => chalkTag(chalk12.template, ...arguments_);
      Object.setPrototypeOf(chalk12, Chalk.prototype);
      Object.setPrototypeOf(chalk12.template, chalk12);
      chalk12.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk12.template.Instance = ChalkClass;
      return chalk12.template;
    }, "chalkFactory");
    function Chalk(options2) {
      return chalkFactory(options2);
    }
    __name(Chalk, "Chalk");
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = /* @__PURE__ */ __name((open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    }, "createStyler");
    var createBuilder = /* @__PURE__ */ __name((self2, _styler, _isEmpty) => {
      const builder = /* @__PURE__ */ __name((...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      }, "builder");
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    }, "createBuilder");
    var applyStyle = /* @__PURE__ */ __name((self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    }, "applyStyle");
    var template;
    var chalkTag = /* @__PURE__ */ __name((chalk12, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates2();
      }
      return template(chalk12, parts.join(""));
    }, "chalkTag");
    Object.defineProperties(Chalk.prototype, styles);
    var chalk11 = Chalk();
    chalk11.supportsColor = stdoutColor;
    chalk11.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk11.stderr.supportsColor = stderrColor;
    module2.exports = chalk11;
  }
});

// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms2 = __commonJS2({
  "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse2, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// ../debug/dist/common.js
var require_common6 = __commonJS2({
  "../debug/dist/common.js"(exports2) {
    var __defProp46 = Object.defineProperty;
    var __markAsModule3 = /* @__PURE__ */ __name((target) => __defProp46(target, "__esModule", { value: true }), "__markAsModule");
    var __name45 = /* @__PURE__ */ __name((target, value) => __defProp46(target, "name", { value, configurable: true }), "__name");
    var __export3 = /* @__PURE__ */ __name((target, all) => {
      __markAsModule3(target);
      for (var name in all)
        __defProp46(target, name, { get: all[name], enumerable: true });
    }, "__export");
    __export3(exports2, {
      setup: () => setup
    });
    var __defProp210 = Object.defineProperty;
    var __name210 = /* @__PURE__ */ __name45((target, value) => __defProp210(target, "name", { value, configurable: true }), "__name");
    function setup(env) {
      const createDebug = /* @__PURE__ */ __name210((namespace, logger2) => {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        const debug10 = /* @__PURE__ */ __name210((...args) => {
          const self2 = debug10;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          if (logger2 && typeof logger2 === "function") {
            logger2.apply(self2, args);
          }
          if (debug10.enabled) {
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
        }, "debug");
        debug10.namespace = namespace;
        debug10.useColors = createDebug.useColors();
        debug10.color = createDebug.selectColor(namespace);
        debug10.extend = extend;
        debug10.destroy = createDebug.destroy;
        Object.defineProperty(debug10, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug10);
        }
        return debug10;
      }, "createDebug");
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms2();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      __name45(selectColor, "selectColor");
      __name210(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      __name45(extend, "extend");
      __name210(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      __name(enable, "enable");
      __name45(enable, "enable");
      __name210(enable, "enable");
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      __name45(disable, "disable");
      __name210(disable, "disable");
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      __name45(enabled, "enabled");
      __name210(enabled, "enabled");
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      __name(toNamespace, "toNamespace");
      __name45(toNamespace, "toNamespace");
      __name210(toNamespace, "toNamespace");
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce, "coerce");
      __name45(coerce, "coerce");
      __name210(coerce, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      __name45(destroy, "destroy");
      __name210(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    __name45(setup, "setup");
    __name210(setup, "setup");
  }
});

// ../debug/dist/node.js
var require_node3 = __commonJS2({
  "../debug/dist/node.js"(exports2, module2) {
    var __create3 = Object.create;
    var __defProp46 = Object.defineProperty;
    var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames3 = Object.getOwnPropertyNames;
    var __getProtoOf3 = Object.getPrototypeOf;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __markAsModule3 = /* @__PURE__ */ __name((target) => __defProp46(target, "__esModule", { value: true }), "__markAsModule");
    var __name45 = /* @__PURE__ */ __name((target, value) => __defProp46(target, "name", { value, configurable: true }), "__name");
    var __export3 = /* @__PURE__ */ __name((target, all) => {
      __markAsModule3(target);
      for (var name in all)
        __defProp46(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __reExport2 = /* @__PURE__ */ __name((target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames3(module22))
          if (!__hasOwnProp3.call(target, key) && key !== "default")
            __defProp46(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable });
      }
      return target;
    }, "__reExport");
    var __toModule3 = /* @__PURE__ */ __name((module22) => {
      return __reExport2(__markAsModule3(__defProp46(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    }, "__toModule");
    __export3(exports2, {
      default: () => node_default
    });
    var import_tty = __toModule3(__require("tty"));
    var import_util7 = __toModule3(__require("util"));
    var import_common4 = __toModule3(require_common6());
    var __defProp210 = Object.defineProperty;
    var __name210 = /* @__PURE__ */ __name45((target, value) => __defProp210(target, "name", { value, configurable: true }), "__name");
    exports2.init = init;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = import_util7.default.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      var _a2;
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : import_tty.default.isatty((_a2 = process.stderr) == null ? void 0 : _a2.fd);
    }
    __name(useColors, "useColors");
    __name45(useColors, "useColors");
    __name210(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    __name45(formatArgs, "formatArgs");
    __name210(formatArgs, "formatArgs");
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    __name(getDate, "getDate");
    __name45(getDate, "getDate");
    __name210(getDate, "getDate");
    function log4(...args) {
      return process.stderr.write(import_util7.default.format(...args) + "\n");
    }
    __name(log4, "log");
    __name45(log4, "log");
    __name210(log4, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    __name45(save, "save");
    __name210(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    __name45(load, "load");
    __name210(load, "load");
    function init(debug10) {
      debug10.inspectOpts = {};
      const keys2 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug10.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    __name(init, "init");
    __name45(init, "init");
    __name210(init, "init");
    var mod2 = (0, import_common4.setup)(exports2);
    module2.exports = mod2;
    var node_default = mod2;
    var { formatters } = mod2;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return import_util7.default.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return import_util7.default.inspect(v, this.inspectOpts);
    };
  }
});

// ../debug/dist/index.js
var require_dist7 = __commonJS2({
  "../debug/dist/index.js"(exports2) {
    var __create3 = Object.create;
    var __defProp46 = Object.defineProperty;
    var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames3 = Object.getOwnPropertyNames;
    var __getProtoOf3 = Object.getPrototypeOf;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __markAsModule3 = /* @__PURE__ */ __name((target) => __defProp46(target, "__esModule", { value: true }), "__markAsModule");
    var __name45 = /* @__PURE__ */ __name((target, value) => __defProp46(target, "name", { value, configurable: true }), "__name");
    var __export3 = /* @__PURE__ */ __name((target, all) => {
      __markAsModule3(target);
      for (var name in all)
        __defProp46(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __reExport2 = /* @__PURE__ */ __name((target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames3(module22))
          if (!__hasOwnProp3.call(target, key) && key !== "default")
            __defProp46(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable });
      }
      return target;
    }, "__reExport");
    var __toModule3 = /* @__PURE__ */ __name((module22) => {
      return __reExport2(__markAsModule3(__defProp46(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    }, "__toModule");
    __export3(exports2, {
      Debug: () => Debug8,
      default: () => Debug8,
      getLogs: () => getLogs2
    });
    var import_node = __toModule3(require_node3());
    var __defProp210 = Object.defineProperty;
    var __name210 = /* @__PURE__ */ __name45((target, value) => __defProp210(target, "name", { value, configurable: true }), "__name");
    var cache = [];
    var MAX_LOGS = 100;
    function Debug8(namespace) {
      const debug10 = (0, import_node.default)(namespace, (...args) => {
        cache.push(args);
        if (cache.length > MAX_LOGS) {
          cache.shift();
        }
      });
      return debug10;
    }
    __name(Debug8, "Debug");
    __name45(Debug8, "Debug");
    __name210(Debug8, "Debug");
    Debug8.enable = (namespace) => {
      import_node.default.enable(namespace);
    };
    Debug8.enabled = (namespace) => import_node.default.enabled(namespace);
    function getLogs2(numChars = 7500) {
      const output = cache.map((c) => c.map((item) => {
        if (typeof item === "string") {
          return item;
        }
        return JSON.stringify(item);
      }).join("  ")).join("\n");
      if (output.length < numChars) {
        return output;
      }
      return output.slice(-numChars);
    }
    __name(getLogs2, "getLogs");
    __name45(getLogs2, "getLogs");
    __name210(getLogs2, "getLogs");
  }
});

// ../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js
var require_indent_string2 = __commonJS2({
  "../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string, count = 1, options2) => {
      options2 = {
        indent: " ",
        includeEmptyLines: false,
        ...options2
      };
      if (typeof string !== "string") {
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
      }
      if (typeof count !== "number") {
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
      }
      if (typeof options2.indent !== "string") {
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options2.indent}\``);
      }
      if (count === 0) {
        return string;
      }
      const regex = options2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options2.indent.repeat(count));
    };
  }
});

// ../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js
var require_js_levenshtein = __commonJS2({
  "../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      function _min(d0, d1, d2, bx, ay) {
        return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
      }
      __name(_min, "_min");
      return function(a, b) {
        if (a === b) {
          return 0;
        }
        if (a.length > b.length) {
          var tmp = a;
          a = b;
          b = tmp;
        }
        var la = a.length;
        var lb = b.length;
        while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
          la--;
          lb--;
        }
        var offset = 0;
        while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
          offset++;
        }
        la -= offset;
        lb -= offset;
        if (la === 0 || lb < 3) {
          return lb;
        }
        var x = 0;
        var y;
        var d0;
        var d1;
        var d2;
        var d3;
        var dd;
        var dy;
        var ay;
        var bx0;
        var bx1;
        var bx2;
        var bx3;
        var vector = [];
        for (y = 0; y < la; y++) {
          vector.push(y + 1);
          vector.push(a.charCodeAt(offset + y));
        }
        var len = vector.length - 1;
        for (; x < lb - 3; ) {
          bx0 = b.charCodeAt(offset + (d0 = x));
          bx1 = b.charCodeAt(offset + (d1 = x + 1));
          bx2 = b.charCodeAt(offset + (d2 = x + 2));
          bx3 = b.charCodeAt(offset + (d3 = x + 3));
          dd = x += 4;
          for (y = 0; y < len; y += 2) {
            dy = vector[y];
            ay = vector[y + 1];
            d0 = _min(dy, d0, d1, bx0, ay);
            d1 = _min(d0, d1, d2, bx1, ay);
            d2 = _min(d1, d2, d3, bx2, ay);
            dd = _min(d2, d3, dd, bx3, ay);
            vector[y] = dd;
            d3 = d2;
            d2 = d1;
            d1 = d0;
            d0 = dy;
          }
        }
        for (; x < lb; ) {
          bx0 = b.charCodeAt(offset + (d0 = x));
          dd = ++x;
          for (y = 0; y < len; y += 2) {
            dy = vector[y];
            vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
            d0 = dy;
          }
        }
        return dd;
      };
    }();
  }
});

// ../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS2({
  "../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS2({
  "../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// ../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js
var require_is_regexp = __commonJS2({
  "../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => Object.prototype.toString.call(input) === "[object RegExp]";
  }
});

// ../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js
var require_is_obj = __commonJS2({
  "../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      const type = typeof value;
      return value !== null && (type === "object" || type === "function");
    };
  }
});

// ../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js
var require_lib3 = __commonJS2({
  "../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = (object) => Object.getOwnPropertySymbols(object).filter((keySymbol) => Object.prototype.propertyIsEnumerable.call(object, keySymbol));
  }
});

// ../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js
var require_min_indent = __commonJS2({
  "../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string) => {
      const match = string.match(/^[ \t]*(?=\S)/gm);
      if (!match) {
        return 0;
      }
      return match.reduce((r, a) => Math.min(r, a.length), Infinity);
    };
  }
});

// ../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js
var require_strip_indent = __commonJS2({
  "../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js"(exports2, module2) {
    "use strict";
    var minIndent = require_min_indent();
    module2.exports = (string) => {
      const indent4 = minIndent(string);
      if (indent4 === 0) {
        return string;
      }
      const regex = new RegExp(`^[ \\t]{${indent4}}`, "gm");
      return string.replace(regex, "");
    };
  }
});

// ../../node_modules/.pnpm/@prisma+engines@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/engines/dist/index.js
var require_dist8 = __commonJS2({
  "../../node_modules/.pnpm/@prisma+engines@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/engines/dist/index.js"(exports, module) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __markAsModule = /* @__PURE__ */ __name((target) => __defProp(target, "__esModule", { value: true }), "__markAsModule");
    var __commonJS = /* @__PURE__ */ __name((callback, module2) => () => {
      if (!module2) {
        module2 = { exports: {} };
        callback(module2.exports, module2);
      }
      return module2.exports;
    }, "__commonJS");
    var __export = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __exportStar = /* @__PURE__ */ __name((target, module2, desc) => {
      if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))
          if (!__hasOwnProp.call(target, key) && key !== "default")
            __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
      }
      return target;
    }, "__exportStar");
    var __toModule = /* @__PURE__ */ __name((module2) => {
      if (module2 && module2.__esModule)
        return module2;
      return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", { value: module2, enumerable: true })), module2);
    }, "__toModule");
    var require_ms = __commonJS((exports2, module2) => {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module2.exports = function(val, options2) {
        options2 = options2 || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse2(val);
        } else if (type === "number" && isFinite(val)) {
          return options2.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      __name(parse2, "parse");
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      __name(fmtShort, "fmtShort");
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      __name(fmtLong, "fmtLong");
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
      __name(plural, "plural");
    });
    var require_common = __commonJS((exports2) => {
      var __defProp210 = Object.defineProperty;
      var __markAsModule22 = /* @__PURE__ */ __name((target) => __defProp210(target, "__esModule", { value: true }), "__markAsModule2");
      var __name45 = /* @__PURE__ */ __name((target, value) => __defProp210(target, "name", { value, configurable: true }), "__name");
      var __export22 = /* @__PURE__ */ __name((target, all) => {
        __markAsModule22(target);
        for (var name in all)
          __defProp210(target, name, { get: all[name], enumerable: true });
      }, "__export2");
      __export22(exports2, {
        setup: () => setup
      });
      var __defProp222 = Object.defineProperty;
      var __name210 = /* @__PURE__ */ __name45((target, value) => __defProp222(target, "name", { value, configurable: true }), "__name");
      function setup(env) {
        const createDebug = /* @__PURE__ */ __name210((namespace, logger2) => {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          const debug32 = /* @__PURE__ */ __name210((...args) => {
            const self2 = debug32;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format2];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            if (logger2 && typeof logger2 === "function") {
              logger2.apply(self2, args);
            }
            if (debug32.enabled) {
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
          }, "debug");
          debug32.namespace = namespace;
          debug32.useColors = createDebug.useColors();
          debug32.color = createDebug.selectColor(namespace);
          debug32.extend = extend;
          debug32.destroy = createDebug.destroy;
          Object.defineProperty(debug32, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug32);
          }
          return debug32;
        }, "createDebug");
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        __name(selectColor, "selectColor");
        __name45(selectColor, "selectColor");
        __name210(selectColor, "selectColor");
        createDebug.selectColor = selectColor;
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        __name(extend, "extend");
        __name45(extend, "extend");
        __name210(extend, "extend");
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        __name(enable, "enable");
        __name45(enable, "enable");
        __name210(enable, "enable");
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        __name(disable, "disable");
        __name45(disable, "disable");
        __name210(disable, "disable");
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        __name(enabled, "enabled");
        __name45(enabled, "enabled");
        __name210(enabled, "enabled");
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        __name(toNamespace, "toNamespace");
        __name45(toNamespace, "toNamespace");
        __name210(toNamespace, "toNamespace");
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        __name(coerce, "coerce");
        __name45(coerce, "coerce");
        __name210(coerce, "coerce");
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        __name(destroy, "destroy");
        __name45(destroy, "destroy");
        __name210(destroy, "destroy");
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      __name(setup, "setup");
      __name45(setup, "setup");
      __name210(setup, "setup");
    });
    var require_node = __commonJS((exports2, module2) => {
      var __create22 = Object.create;
      var __defProp210 = Object.defineProperty;
      var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames22 = Object.getOwnPropertyNames;
      var __getProtoOf22 = Object.getPrototypeOf;
      var __hasOwnProp22 = Object.prototype.hasOwnProperty;
      var __markAsModule22 = /* @__PURE__ */ __name((target) => __defProp210(target, "__esModule", { value: true }), "__markAsModule2");
      var __name45 = /* @__PURE__ */ __name((target, value) => __defProp210(target, "name", { value, configurable: true }), "__name");
      var __export22 = /* @__PURE__ */ __name((target, all) => {
        __markAsModule22(target);
        for (var name in all)
          __defProp210(target, name, { get: all[name], enumerable: true });
      }, "__export2");
      var __reExport2 = /* @__PURE__ */ __name((target, module22, desc) => {
        if (module22 && typeof module22 === "object" || typeof module22 === "function") {
          for (let key of __getOwnPropNames22(module22))
            if (!__hasOwnProp22.call(target, key) && key !== "default")
              __defProp210(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc22(module22, key)) || desc.enumerable });
        }
        return target;
      }, "__reExport");
      var __toModule22 = /* @__PURE__ */ __name((module22) => {
        return __reExport2(__markAsModule22(__defProp210(module22 != null ? __create22(__getProtoOf22(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
      }, "__toModule2");
      __export22(exports2, {
        default: () => node_default
      });
      var import_tty = __toModule22(__require("tty"));
      var import_util7 = __toModule22(__require("util"));
      var import_common4 = __toModule22(require_common());
      var __defProp222 = Object.defineProperty;
      var __name210 = /* @__PURE__ */ __name45((target, value) => __defProp222(target, "name", { value, configurable: true }), "__name");
      exports2.init = init;
      exports2.log = log4;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.destroy = import_util7.default.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      exports2.colors = [6, 2, 3, 4, 5, 1];
      exports2.inspectOpts = Object.keys(process.env).filter((key) => {
        return /^debug_/i.test(key);
      }).reduce((obj, key) => {
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
          return k.toUpperCase();
        });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        var _a2;
        return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : import_tty.default.isatty((_a2 = process.stderr) == null ? void 0 : _a2.fd);
      }
      __name(useColors, "useColors");
      __name45(useColors, "useColors");
      __name210(useColors, "useColors");
      function formatArgs(args) {
        const { namespace: name, useColors: useColors2 } = this;
        if (useColors2) {
          const c = this.color;
          const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
          const prefix = `  ${colorCode};1m${name} [0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      __name(formatArgs, "formatArgs");
      __name45(formatArgs, "formatArgs");
      __name210(formatArgs, "formatArgs");
      function getDate() {
        if (exports2.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }
      __name(getDate, "getDate");
      __name45(getDate, "getDate");
      __name210(getDate, "getDate");
      function log4(...args) {
        return process.stderr.write(import_util7.default.format(...args) + "\n");
      }
      __name(log4, "log");
      __name45(log4, "log");
      __name210(log4, "log");
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      __name(save, "save");
      __name45(save, "save");
      __name210(save, "save");
      function load() {
        return process.env.DEBUG;
      }
      __name(load, "load");
      __name45(load, "load");
      __name210(load, "load");
      function init(debug32) {
        debug32.inspectOpts = {};
        const keys2 = Object.keys(exports2.inspectOpts);
        for (let i = 0; i < keys2.length; i++) {
          debug32.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
        }
      }
      __name(init, "init");
      __name45(init, "init");
      __name210(init, "init");
      var mod2 = (0, import_common4.setup)(exports2);
      module2.exports = mod2;
      var node_default = mod2;
      var { formatters } = mod2;
      formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return import_util7.default.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
      };
      formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return import_util7.default.inspect(v, this.inspectOpts);
      };
    });
    var require_dist = __commonJS((exports2) => {
      var __create22 = Object.create;
      var __defProp210 = Object.defineProperty;
      var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames22 = Object.getOwnPropertyNames;
      var __getProtoOf22 = Object.getPrototypeOf;
      var __hasOwnProp22 = Object.prototype.hasOwnProperty;
      var __markAsModule22 = /* @__PURE__ */ __name((target) => __defProp210(target, "__esModule", { value: true }), "__markAsModule2");
      var __name45 = /* @__PURE__ */ __name((target, value) => __defProp210(target, "name", { value, configurable: true }), "__name");
      var __export22 = /* @__PURE__ */ __name((target, all) => {
        __markAsModule22(target);
        for (var name in all)
          __defProp210(target, name, { get: all[name], enumerable: true });
      }, "__export2");
      var __reExport2 = /* @__PURE__ */ __name((target, module22, desc) => {
        if (module22 && typeof module22 === "object" || typeof module22 === "function") {
          for (let key of __getOwnPropNames22(module22))
            if (!__hasOwnProp22.call(target, key) && key !== "default")
              __defProp210(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc22(module22, key)) || desc.enumerable });
        }
        return target;
      }, "__reExport");
      var __toModule22 = /* @__PURE__ */ __name((module22) => {
        return __reExport2(__markAsModule22(__defProp210(module22 != null ? __create22(__getProtoOf22(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
      }, "__toModule2");
      __export22(exports2, {
        Debug: () => Debug22,
        default: () => Debug22,
        getLogs: () => getLogs2
      });
      var import_node = __toModule22(require_node());
      var __defProp222 = Object.defineProperty;
      var __name210 = /* @__PURE__ */ __name45((target, value) => __defProp222(target, "name", { value, configurable: true }), "__name");
      var cache = [];
      var MAX_LOGS = 100;
      function Debug22(namespace) {
        const debug32 = (0, import_node.default)(namespace, (...args) => {
          cache.push(args);
          if (cache.length > MAX_LOGS) {
            cache.shift();
          }
        });
        return debug32;
      }
      __name(Debug22, "Debug2");
      __name45(Debug22, "Debug");
      __name210(Debug22, "Debug");
      Debug22.enable = (namespace) => {
        import_node.default.enable(namespace);
      };
      Debug22.enabled = (namespace) => import_node.default.enabled(namespace);
      function getLogs2(numChars = 7500) {
        const output = cache.map((c) => c.map((item) => {
          if (typeof item === "string") {
            return item;
          }
          return JSON.stringify(item);
        }).join("  ")).join("\n");
        if (output.length < numChars) {
          return output;
        }
        return output.slice(-numChars);
      }
      __name(getLogs2, "getLogs");
      __name45(getLogs2, "getLogs");
      __name210(getLogs2, "getLogs");
    });
    var require_package = __commonJS((exports2, module2) => {
      module2.exports = {
        name: "@prisma/engines-version",
        version: "3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727",
        main: "index.js",
        types: "index.d.ts",
        license: "Apache-2.0",
        author: "Tim Suchanek <suchanek@prisma.io>",
        prisma: {
          enginesVersion: "dc520b92b1ebb2d28dc3161f9f82e875bd35d727"
        },
        repository: {
          type: "git",
          url: "https://github.com/prisma/engines-wrapper.git",
          directory: "packages/engines-version"
        },
        devDependencies: {
          "@types/node": "16.11.10",
          typescript: "4.5.2"
        },
        scripts: {
          build: "tsc -d",
          prepublishOnly: "tsc -d",
          publish: "echo $GITHUB_CONTEXT"
        },
        files: [
          "index.js",
          "index.d.ts"
        ]
      };
    });
    var require_engines_version = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.enginesVersion = void 0;
      exports2.enginesVersion = require_package().prisma.enginesVersion;
    });
    var require_getNodeAPIName = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getNodeAPIName = void 0;
      var NODE_API_QUERY_ENGINE_URL_BASE = "libquery_engine";
      function getNodeAPIName3(platform2, type) {
        const isUrl = type === "url";
        if (platform2.includes("windows")) {
          return isUrl ? `query_engine.dll.node` : `query_engine-${platform2}.dll.node`;
        } else if (platform2.includes("linux") || platform2.includes("debian") || platform2.includes("rhel")) {
          return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform2}.so.node`;
        } else if (platform2.includes("darwin")) {
          return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform2}.dylib.node`;
        } else {
          throw new Error(`Node API is currently not supported on your platform: ${platform2}`);
        }
      }
      __name(getNodeAPIName3, "getNodeAPIName");
      exports2.getNodeAPIName = getNodeAPIName3;
    });
    var require_getPlatform = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getPlatform = exports2.getOpenSSLVersion = exports2.parseOpenSSLVersion = exports2.resolveDistro = exports2.parseDistro = exports2.getos = void 0;
      var child_process_1 = __require("child_process");
      var fs_12 = __importDefault2(__require("fs"));
      var os_1 = __importDefault2(__require("os"));
      var util_12 = __require("util");
      var readFile2 = (0, util_12.promisify)(fs_12.default.readFile);
      var exists22 = (0, util_12.promisify)(fs_12.default.exists);
      async function getos() {
        const platform2 = os_1.default.platform();
        const arch = process.arch;
        if (platform2 === "freebsd") {
          const version = await gracefulExec(`freebsd-version`);
          if (version && version.trim().length > 0) {
            const regex = /^(\d+)\.?/;
            const match = regex.exec(version);
            if (match) {
              return {
                platform: "freebsd",
                distro: `freebsd${match[1]}`,
                arch
              };
            }
          }
        }
        if (platform2 !== "linux") {
          return {
            platform: platform2,
            arch
          };
        }
        return {
          platform: "linux",
          libssl: await getOpenSSLVersion(),
          distro: await resolveDistro(),
          arch
        };
      }
      __name(getos, "getos");
      exports2.getos = getos;
      function parseDistro(input) {
        const idRegex = /^ID="?([^"\n]*)"?$/im;
        const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
        const idMatch = idRegex.exec(input);
        const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
        const idLikeMatch = idLikeRegex.exec(input);
        const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
        if (id === "raspbian") {
          return "arm";
        }
        if (id === "nixos") {
          return "nixos";
        }
        if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
          return "rhel";
        }
        if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
          return "debian";
        }
        return;
      }
      __name(parseDistro, "parseDistro");
      exports2.parseDistro = parseDistro;
      async function resolveDistro() {
        const osReleaseFile = "/etc/os-release";
        const alpineReleaseFile = "/etc/alpine-release";
        if (await exists22(alpineReleaseFile)) {
          return "musl";
        } else if (await exists22(osReleaseFile)) {
          return parseDistro(await readFile2(osReleaseFile, "utf-8"));
        } else {
          return;
        }
      }
      __name(resolveDistro, "resolveDistro");
      exports2.resolveDistro = resolveDistro;
      function parseOpenSSLVersion(input) {
        const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
        if (match) {
          return match[1] + ".x";
        }
        return;
      }
      __name(parseOpenSSLVersion, "parseOpenSSLVersion");
      exports2.parseOpenSSLVersion = parseOpenSSLVersion;
      async function getOpenSSLVersion() {
        const [version, ls] = await Promise.all([
          gracefulExec(`openssl version -v`),
          gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
        ]);
        if (version) {
          const v = parseOpenSSLVersion(version);
          if (v) {
            return v;
          }
        }
        if (ls) {
          const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
          if (match) {
            return match[1] + ".x";
          }
        }
        return void 0;
      }
      __name(getOpenSSLVersion, "getOpenSSLVersion");
      exports2.getOpenSSLVersion = getOpenSSLVersion;
      async function gracefulExec(cmd) {
        return new Promise((resolve2) => {
          try {
            (0, child_process_1.exec)(cmd, (err, stdout) => {
              resolve2(String(stdout));
            });
          } catch (e) {
            resolve2(void 0);
            return void 0;
          }
        });
      }
      __name(gracefulExec, "gracefulExec");
      async function getPlatform4() {
        const { platform: platform2, libssl, distro, arch } = await getos();
        if (platform2 === "darwin" && arch === "arm64") {
          return "darwin-arm64";
        }
        if (platform2 === "darwin") {
          return "darwin";
        }
        if (platform2 === "win32") {
          return "windows";
        }
        if (platform2 === "freebsd") {
          return distro;
        }
        if (platform2 === "openbsd") {
          return "openbsd";
        }
        if (platform2 === "netbsd") {
          return "netbsd";
        }
        if (platform2 === "linux" && arch === "arm64") {
          return `linux-arm64-openssl-${libssl}`;
        }
        if (platform2 === "linux" && arch === "arm") {
          return `linux-arm-openssl-${libssl}`;
        }
        if (platform2 === "linux" && distro === "nixos") {
          return "linux-nixos";
        }
        if (platform2 === "linux" && distro === "musl") {
          return "linux-musl";
        }
        if (platform2 === "linux" && distro && libssl) {
          return distro + "-openssl-" + libssl;
        }
        if (libssl) {
          return "debian-openssl-" + libssl;
        }
        if (distro) {
          return distro + "-openssl-1.1.x";
        }
        return "debian-openssl-1.1.x";
      }
      __name(getPlatform4, "getPlatform");
      exports2.getPlatform = getPlatform4;
    });
    var require_isNodeAPISupported = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isNodeAPISupported = void 0;
      var fs_12 = __importDefault2(__require("fs"));
      var _1 = require_dist2();
      async function isNodeAPISupported2() {
        const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
        const customLibraryExists = customLibraryPath && fs_12.default.existsSync(customLibraryPath);
        const os2 = await (0, _1.getos)();
        if (!customLibraryExists && (os2.arch === "x32" || os2.arch === "ia32")) {
          throw new Error(`The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set \`engineType = "binary"\` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)`);
        }
      }
      __name(isNodeAPISupported2, "isNodeAPISupported");
      exports2.isNodeAPISupported = isNodeAPISupported2;
    });
    var require_platforms = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.platforms = void 0;
      exports2.platforms = [
        "darwin",
        "darwin-arm64",
        "debian-openssl-1.0.x",
        "debian-openssl-1.1.x",
        "rhel-openssl-1.0.x",
        "rhel-openssl-1.1.x",
        "linux-arm64-openssl-1.1.x",
        "linux-arm64-openssl-1.0.x",
        "linux-arm-openssl-1.1.x",
        "linux-arm-openssl-1.0.x",
        "linux-musl",
        "linux-nixos",
        "windows",
        "freebsd11",
        "freebsd12",
        "openbsd",
        "netbsd",
        "arm"
      ];
    });
    var require_dist2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.platforms = exports2.isNodeAPISupported = exports2.getPlatform = exports2.getos = exports2.getNodeAPIName = void 0;
      var getNodeAPIName_1 = require_getNodeAPIName();
      Object.defineProperty(exports2, "getNodeAPIName", { enumerable: true, get: function() {
        return getNodeAPIName_1.getNodeAPIName;
      } });
      var getPlatform_1 = require_getPlatform();
      Object.defineProperty(exports2, "getos", { enumerable: true, get: function() {
        return getPlatform_1.getos;
      } });
      Object.defineProperty(exports2, "getPlatform", { enumerable: true, get: function() {
        return getPlatform_1.getPlatform;
      } });
      var isNodeAPISupported_1 = require_isNodeAPISupported();
      Object.defineProperty(exports2, "isNodeAPISupported", { enumerable: true, get: function() {
        return isNodeAPISupported_1.isNodeAPISupported;
      } });
      var platforms_1 = require_platforms();
      Object.defineProperty(exports2, "platforms", { enumerable: true, get: function() {
        return platforms_1.platforms;
      } });
    });
    var require_color_name = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    });
    var require_conversions = __commonJS((exports2, module2) => {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      module2.exports = convert;
      for (const model of Object.keys(convert)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const { channels, labels } = convert[model];
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
      convert.rgb.hsl = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const min2 = Math.min(r, g, b);
        const max2 = Math.max(r, g, b);
        const delta = max2 - min2;
        let h;
        let s;
        if (max2 === min2) {
          h = 0;
        } else if (r === max2) {
          h = (g - b) / delta;
        } else if (g === max2) {
          h = 2 + (b - r) / delta;
        } else if (b === max2) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        const l = (min2 + max2) / 2;
        if (max2 === min2) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max2 + min2);
        } else {
          s = delta / (2 - max2 - min2);
        }
        return [h, s * 100, l * 100];
      };
      convert.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h;
        let s;
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const v = Math.max(r, g, b);
        const diff = v - Math.min(r, g, b);
        const diffc = /* @__PURE__ */ __name(function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        }, "diffc");
        if (diff === 0) {
          h = 0;
          s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert.rgb.hwb = function(rgb) {
        const r = rgb[0];
        const g = rgb[1];
        let b = rgb[2];
        const h = convert.rgb.hsl(rgb)[0];
        const w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert.rgb.cmyk = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const k = Math.min(1 - r, 1 - g, 1 - b);
        const c = (1 - r - k) / (1 - k) || 0;
        const m = (1 - g - k) / (1 - k) || 0;
        const y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
      }
      __name(comparativeDistance, "comparativeDistance");
      convert.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert.rgb.xyz = function(rgb) {
        let r = rgb[0] / 255;
        let g = rgb[1] / 255;
        let b = rgb[2] / 255;
        r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
        g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
        b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert.rgb.lab = function(rgb) {
        const xyz = convert.rgb.xyz(rgb);
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert.hsl.rgb = function(hsl) {
        const h = hsl[0] / 360;
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        const t1 = 2 * l - t2;
        const rgb = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert.hsl.hsv = function(hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100;
        let l = hsl[2] / 100;
        let smin = s;
        const lmin = Math.max(l, 0.01);
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v = (l + s) / 2;
        const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert.hsv.rgb = function(hsv) {
        const h = hsv[0] / 60;
        const s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6;
        const f = h - Math.floor(h);
        const p = 255 * v * (1 - s);
        const q = 255 * v * (1 - s * f);
        const t = 255 * v * (1 - s * (1 - f));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t];
          case 3:
            return [p, q, v];
          case 4:
            return [t, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert.hsv.hsl = function(hsv) {
        const h = hsv[0];
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const vmin = Math.max(v, 0.01);
        let sl;
        let l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert.hwb.rgb = function(hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i = Math.floor(6 * h);
        const v = 1 - bl;
        f = 6 * h - i;
        if ((i & 1) !== 0) {
          f = 1 - f;
        }
        const n = wh + f * (v - wh);
        let r;
        let g;
        let b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert.cmyk.rgb = function(cmyk) {
        const c = cmyk[0] / 100;
        const m = cmyk[1] / 100;
        const y = cmyk[2] / 100;
        const k = cmyk[3] / 100;
        const r = 1 - Math.min(1, c * (1 - k) + k);
        const g = 1 - Math.min(1, m * (1 - k) + k);
        const b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert.xyz.rgb = function(xyz) {
        const x = xyz[0] / 100;
        const y = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r;
        let g;
        let b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert.xyz.lab = function(xyz) {
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert.lab.xyz = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let x;
        let y;
        let z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        const y2 = y ** 3;
        const x2 = x ** 3;
        const z2 = z ** 3;
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert.lab.lch = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let h;
        const hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        const c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert.lch.lab = function(lch) {
        const l = lch[0];
        const c = lch[1];
        const h = lch[2];
        const hr = h / 360 * 2 * Math.PI;
        const a = c * Math.cos(hr);
        const b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert.rgb.ansi16 = function(args, saturation = null) {
        const [r, g, b] = args;
        let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      };
      convert.rgb.ansi256 = function(args) {
        const r = args[0];
        const g = args[1];
        const b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert.ansi16.rgb = function(args) {
        let color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r = (color & 1) * mult * 255;
        const g = (color >> 1 & 1) * mult * 255;
        const b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        let rem;
        const r = Math.floor(args / 36) / 5 * 255;
        const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        const b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert.rgb.hex = function(args) {
        const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.hex.rgb = function(args) {
        const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        let colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r = integer >> 16 & 255;
        const g = integer >> 8 & 255;
        const b = integer & 255;
        return [r, g, b];
      };
      convert.rgb.hcg = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const max2 = Math.max(Math.max(r, g), b);
        const min2 = Math.min(Math.min(r, g), b);
        const chroma = max2 - min2;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min2 / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max2 === r) {
          hue = (g - b) / chroma % 6;
        } else if (max2 === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert.hsl.hcg = function(hsl) {
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
        let f = 0;
        if (c < 1) {
          f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
      };
      convert.hsv.hcg = function(hsv) {
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const c = s * v;
        let f = 0;
        if (c < 1) {
          f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
      };
      convert.hcg.rgb = function(hcg) {
        const h = hcg[0] / 360;
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        const pure = [0, 0, 0];
        const hi = h % 1 * 6;
        const v = hi % 1;
        const w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert.hcg.hsv = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        let f = 0;
        if (v > 0) {
          f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
      };
      convert.hcg.hsl = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const l = g * (1 - c) + 0.5 * c;
        let s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert.hcg.hwb = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert.hwb.hcg = function(hwb) {
        const w = hwb[1] / 100;
        const b = hwb[2] / 100;
        const v = 1 - b;
        const c = v - w;
        let g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert.gray.hsl = function(args) {
        return [0, 0, args[0]];
      };
      convert.gray.hsv = convert.gray.hsl;
      convert.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    });
    var require_route = __commonJS((exports2, module2) => {
      var conversions = require_conversions();
      function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      __name(buildGraph, "buildGraph");
      function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i = 0; i < len; i++) {
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      __name(deriveBFS, "deriveBFS");
      function link2(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      __name(link2, "link");
      function wrapConversion(toModel, graph) {
        const path22 = [graph[toModel].parent, toModel];
        let fn = conversions[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path22.unshift(graph[cur].parent);
          fn = link2(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path22;
        return fn;
      }
      __name(wrapConversion, "wrapConversion");
      module2.exports = function(fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i = 0; i < len; i++) {
          const toModel = models[i];
          const node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    });
    var require_color_convert = __commonJS((exports2, module2) => {
      var conversions = require_conversions();
      var route = require_route();
      var convert = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = /* @__PURE__ */ __name(function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          return fn(args);
        }, "wrappedFn");
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      __name(wrapRaw, "wrapRaw");
      function wrapRounded(fn) {
        const wrappedFn = /* @__PURE__ */ __name(function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          const result = fn(args);
          if (typeof result === "object") {
            for (let len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        }, "wrappedFn");
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      __name(wrapRounded, "wrapRounded");
      models.forEach((fromModel) => {
        convert[fromModel] = {};
        Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert[fromModel][toModel] = wrapRounded(fn);
          convert[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module2.exports = convert;
    });
    var require_ansi_styles = __commonJS((exports2, module2) => {
      "use strict";
      var wrapAnsi16 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
        const code = fn(...args);
        return `[${code + offset}m`;
      }, "wrapAnsi16");
      var wrapAnsi256 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
        const code = fn(...args);
        return `[${38 + offset};5;${code}m`;
      }, "wrapAnsi256");
      var wrapAnsi16m = /* @__PURE__ */ __name((fn, offset) => (...args) => {
        const rgb = fn(...args);
        return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      }, "wrapAnsi16m");
      var ansi2ansi = /* @__PURE__ */ __name((n) => n, "ansi2ansi");
      var rgb2rgb = /* @__PURE__ */ __name((r, g, b) => [r, g, b], "rgb2rgb");
      var setLazyProperty = /* @__PURE__ */ __name((object, property, get) => {
        Object.defineProperty(object, property, {
          get: () => {
            const value = get();
            Object.defineProperty(object, property, {
              value,
              enumerable: true,
              configurable: true
            });
            return value;
          },
          enumerable: true,
          configurable: true
        });
      }, "setLazyProperty");
      var colorConvert;
      var makeDynamicStyles = /* @__PURE__ */ __name((wrap, targetSpace, identity2, isBackground) => {
        if (colorConvert === void 0) {
          colorConvert = require_color_convert();
        }
        const offset = isBackground ? 10 : 0;
        const styles = {};
        for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
          const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
          if (sourceSpace === targetSpace) {
            styles[name] = wrap(identity2, offset);
          } else if (typeof suite === "object") {
            styles[name] = wrap(suite[targetSpace], offset);
          }
        }
        return styles;
      }, "makeDynamicStyles");
      function assembleStyles() {
        const codes = new Map();
        const styles = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.gray = styles.color.blackBright;
        styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
        styles.color.grey = styles.color.blackBright;
        styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles)) {
          for (const [styleName, style] of Object.entries(group)) {
            styles[styleName] = {
              open: `[${style[0]}m`,
              close: `[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
          });
        }
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
        styles.color.close = "[39m";
        styles.bgColor.close = "[49m";
        setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
        setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
        return styles;
      }
      __name(assembleStyles, "assembleStyles");
      Object.defineProperty(module2, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    });
    var require_has_flag = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    });
    var require_supports_color = __commonJS((exports2, module2) => {
      "use strict";
      var os2 = __require("os");
      var tty = __require("tty");
      var hasFlag = require_has_flag();
      var { env } = process;
      var forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        forceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = 1;
      }
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      __name(translateLevel, "translateLevel");
      function supportsColor(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min2 = forceColor || 0;
        if (env.TERM === "dumb") {
          return min2;
        }
        if (process.platform === "win32") {
          const osRelease = os2.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min2;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        return min2;
      }
      __name(supportsColor, "supportsColor");
      function getSupportLevel(stream3) {
        const level = supportsColor(stream3, stream3 && stream3.isTTY);
        return translateLevel(level);
      }
      __name(getSupportLevel, "getSupportLevel");
      module2.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel(supportsColor(true, tty.isatty(1))),
        stderr: translateLevel(supportsColor(true, tty.isatty(2)))
      };
    });
    var require_util = __commonJS((exports2, module2) => {
      "use strict";
      var stringReplaceAll = /* @__PURE__ */ __name((string, substring, replacer) => {
        let index = string.indexOf(substring);
        if (index === -1) {
          return string;
        }
        const substringLength = substring.length;
        let endIndex = 0;
        let returnValue = "";
        do {
          returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
          endIndex = index + substringLength;
          index = string.indexOf(substring, endIndex);
        } while (index !== -1);
        returnValue += string.substr(endIndex);
        return returnValue;
      }, "stringReplaceAll");
      var stringEncaseCRLFWithFirstIndex = /* @__PURE__ */ __name((string, prefix, postfix, index) => {
        let endIndex = 0;
        let returnValue = "";
        do {
          const gotCR = string[index - 1] === "\r";
          returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
          endIndex = index + 1;
          index = string.indexOf("\n", endIndex);
        } while (index !== -1);
        returnValue += string.substr(endIndex);
        return returnValue;
      }, "stringEncaseCRLFWithFirstIndex");
      module2.exports = {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      };
    });
    var require_templates = __commonJS((exports2, module2) => {
      "use strict";
      var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", ""],
        ["a", "\x07"]
      ]);
      function unescape(c) {
        const u = c[0] === "u";
        const bracket = c[1] === "{";
        if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        if (u && bracket) {
          return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      __name(unescape, "unescape");
      function parseArguments(name, arguments_) {
        const results = [];
        const chunks = arguments_.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          const number = Number(chunk);
          if (!Number.isNaN(number)) {
            results.push(number);
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
          }
        }
        return results;
      }
      __name(parseArguments, "parseArguments");
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1];
          if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([name].concat(args));
          } else {
            results.push([name]);
          }
        }
        return results;
      }
      __name(parseStyle, "parseStyle");
      function buildStyle(chalk11, styles) {
        const enabled = {};
        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk11;
        for (const [styleName, styles2] of Object.entries(enabled)) {
          if (!Array.isArray(styles2)) {
            continue;
          }
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
        }
        return current;
      }
      __name(buildStyle, "buildStyle");
      module2.exports = (chalk11, temporary) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
          if (escapeCharacter) {
            chunk.push(unescape(escapeCharacter));
          } else if (style) {
            const string = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? string : buildStyle(chalk11, styles)(string));
            styles.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk11, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
          } else {
            chunk.push(character);
          }
        });
        chunks.push(chunk.join(""));
        if (styles.length > 0) {
          const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMessage);
        }
        return chunks.join("");
      };
    });
    var require_source = __commonJS((exports2, module2) => {
      "use strict";
      var ansiStyles = require_ansi_styles();
      var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
      var {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      } = require_util();
      var { isArray } = Array;
      var levelMapping = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
      ];
      var styles = Object.create(null);
      var applyOptions = /* @__PURE__ */ __name((object, options2 = {}) => {
        if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
          throw new Error("The `level` option should be an integer from 0 to 3");
        }
        const colorLevel = stdoutColor ? stdoutColor.level : 0;
        object.level = options2.level === void 0 ? colorLevel : options2.level;
      }, "applyOptions");
      var ChalkClass = /* @__PURE__ */ __name(class {
        constructor(options2) {
          return chalkFactory(options2);
        }
      }, "ChalkClass");
      var chalkFactory = /* @__PURE__ */ __name((options2) => {
        const chalk22 = {};
        applyOptions(chalk22, options2);
        chalk22.template = (...arguments_) => chalkTag(chalk22.template, ...arguments_);
        Object.setPrototypeOf(chalk22, Chalk.prototype);
        Object.setPrototypeOf(chalk22.template, chalk22);
        chalk22.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        };
        chalk22.template.Instance = ChalkClass;
        return chalk22.template;
      }, "chalkFactory");
      function Chalk(options2) {
        return chalkFactory(options2);
      }
      __name(Chalk, "Chalk");
      for (const [styleName, style] of Object.entries(ansiStyles)) {
        styles[styleName] = {
          get() {
            const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
            Object.defineProperty(this, styleName, { value: builder });
            return builder;
          }
        };
      }
      styles.visible = {
        get() {
          const builder = createBuilder(this, this._styler, true);
          Object.defineProperty(this, "visible", { value: builder });
          return builder;
        }
      };
      var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const model of usedModels) {
        styles[model] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      for (const model of usedModels) {
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      var proto = Object.defineProperties(() => {
      }, {
        ...styles,
        level: {
          enumerable: true,
          get() {
            return this._generator.level;
          },
          set(level) {
            this._generator.level = level;
          }
        }
      });
      var createStyler = /* @__PURE__ */ __name((open, close, parent) => {
        let openAll;
        let closeAll;
        if (parent === void 0) {
          openAll = open;
          closeAll = close;
        } else {
          openAll = parent.openAll + open;
          closeAll = close + parent.closeAll;
        }
        return {
          open,
          close,
          openAll,
          closeAll,
          parent
        };
      }, "createStyler");
      var createBuilder = /* @__PURE__ */ __name((self2, _styler, _isEmpty) => {
        const builder = /* @__PURE__ */ __name((...arguments_) => {
          if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
            return applyStyle(builder, chalkTag(builder, ...arguments_));
          }
          return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
        }, "builder");
        Object.setPrototypeOf(builder, proto);
        builder._generator = self2;
        builder._styler = _styler;
        builder._isEmpty = _isEmpty;
        return builder;
      }, "createBuilder");
      var applyStyle = /* @__PURE__ */ __name((self2, string) => {
        if (self2.level <= 0 || !string) {
          return self2._isEmpty ? "" : string;
        }
        let styler = self2._styler;
        if (styler === void 0) {
          return string;
        }
        const { openAll, closeAll } = styler;
        if (string.indexOf("") !== -1) {
          while (styler !== void 0) {
            string = stringReplaceAll(string, styler.close, styler.open);
            styler = styler.parent;
          }
        }
        const lfIndex = string.indexOf("\n");
        if (lfIndex !== -1) {
          string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
        }
        return openAll + string + closeAll;
      }, "applyStyle");
      var template;
      var chalkTag = /* @__PURE__ */ __name((chalk22, ...strings) => {
        const [firstString] = strings;
        if (!isArray(firstString) || !isArray(firstString.raw)) {
          return strings.join(" ");
        }
        const arguments_ = strings.slice(1);
        const parts = [firstString.raw[0]];
        for (let i = 1; i < firstString.length; i++) {
          parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
        }
        if (template === void 0) {
          template = require_templates();
        }
        return template(chalk22, parts.join(""));
      }, "chalkTag");
      Object.defineProperties(Chalk.prototype, styles);
      var chalk11 = Chalk();
      chalk11.supportsColor = stdoutColor;
      chalk11.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
      chalk11.stderr.supportsColor = stderrColor;
      module2.exports = chalk11;
    });
    var require_windows = __commonJS((exports2, module2) => {
      module2.exports = isexe;
      isexe.sync = sync;
      var fs7 = __require("fs");
      function checkPathExt(path22, options2) {
        var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
        if (!pathext) {
          return true;
        }
        pathext = pathext.split(";");
        if (pathext.indexOf("") !== -1) {
          return true;
        }
        for (var i = 0; i < pathext.length; i++) {
          var p = pathext[i].toLowerCase();
          if (p && path22.substr(-p.length).toLowerCase() === p) {
            return true;
          }
        }
        return false;
      }
      __name(checkPathExt, "checkPathExt");
      function checkStat(stat, path22, options2) {
        if (!stat.isSymbolicLink() && !stat.isFile()) {
          return false;
        }
        return checkPathExt(path22, options2);
      }
      __name(checkStat, "checkStat");
      function isexe(path22, options2, cb) {
        fs7.stat(path22, function(er, stat) {
          cb(er, er ? false : checkStat(stat, path22, options2));
        });
      }
      __name(isexe, "isexe");
      function sync(path22, options2) {
        return checkStat(fs7.statSync(path22), path22, options2);
      }
      __name(sync, "sync");
    });
    var require_mode = __commonJS((exports2, module2) => {
      module2.exports = isexe;
      isexe.sync = sync;
      var fs7 = __require("fs");
      function isexe(path22, options2, cb) {
        fs7.stat(path22, function(er, stat) {
          cb(er, er ? false : checkStat(stat, options2));
        });
      }
      __name(isexe, "isexe");
      function sync(path22, options2) {
        return checkStat(fs7.statSync(path22), options2);
      }
      __name(sync, "sync");
      function checkStat(stat, options2) {
        return stat.isFile() && checkMode(stat, options2);
      }
      __name(checkStat, "checkStat");
      function checkMode(stat, options2) {
        var mod2 = stat.mode;
        var uid = stat.uid;
        var gid = stat.gid;
        var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
        var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
        var u = parseInt("100", 8);
        var g = parseInt("010", 8);
        var o = parseInt("001", 8);
        var ug = u | g;
        var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
        return ret;
      }
      __name(checkMode, "checkMode");
    });
    var require_isexe = __commonJS((exports2, module2) => {
      var fs7 = __require("fs");
      var core;
      if (process.platform === "win32" || global.TESTING_WINDOWS) {
        core = require_windows();
      } else {
        core = require_mode();
      }
      module2.exports = isexe;
      isexe.sync = sync;
      function isexe(path22, options2, cb) {
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (!cb) {
          if (typeof Promise !== "function") {
            throw new TypeError("callback not provided");
          }
          return new Promise(function(resolve2, reject2) {
            isexe(path22, options2 || {}, function(er, is) {
              if (er) {
                reject2(er);
              } else {
                resolve2(is);
              }
            });
          });
        }
        core(path22, options2 || {}, function(er, is) {
          if (er) {
            if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
              er = null;
              is = false;
            }
          }
          cb(er, is);
        });
      }
      __name(isexe, "isexe");
      function sync(path22, options2) {
        try {
          return core.sync(path22, options2 || {});
        } catch (er) {
          if (options2 && options2.ignoreErrors || er.code === "EACCES") {
            return false;
          } else {
            throw er;
          }
        }
      }
      __name(sync, "sync");
    });
    var require_which = __commonJS((exports2, module2) => {
      var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
      var path22 = __require("path");
      var COLON = isWindows ? ";" : ":";
      var isexe = require_isexe();
      var getNotFoundError = /* @__PURE__ */ __name((cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), "getNotFoundError");
      var getPathInfo = /* @__PURE__ */ __name((cmd, opt) => {
        const colon = opt.colon || COLON;
        const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
          ...isWindows ? [process.cwd()] : [],
          ...(opt.path || process.env.PATH || "").split(colon)
        ];
        const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
        const pathExt = isWindows ? pathExtExe.split(colon) : [""];
        if (isWindows) {
          if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
            pathExt.unshift("");
        }
        return {
          pathEnv,
          pathExt,
          pathExtExe
        };
      }, "getPathInfo");
      var which = /* @__PURE__ */ __name((cmd, opt, cb) => {
        if (typeof opt === "function") {
          cb = opt;
          opt = {};
        }
        if (!opt)
          opt = {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        const step = /* @__PURE__ */ __name((i) => new Promise((resolve2, reject2) => {
          if (i === pathEnv.length)
            return opt.all && found.length ? resolve2(found) : reject2(getNotFoundError(cmd));
          const ppRaw = pathEnv[i];
          const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
          const pCmd = path22.join(pathPart, cmd);
          const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          resolve2(subStep(p, i, 0));
        }), "step");
        const subStep = /* @__PURE__ */ __name((p, i, ii) => new Promise((resolve2, reject2) => {
          if (ii === pathExt.length)
            return resolve2(step(i + 1));
          const ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return resolve2(p + ext);
            }
            return resolve2(subStep(p, i, ii + 1));
          });
        }), "subStep");
        return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
      }, "which");
      var whichSync = /* @__PURE__ */ __name((cmd, opt) => {
        opt = opt || {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        for (let i = 0; i < pathEnv.length; i++) {
          const ppRaw = pathEnv[i];
          const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
          const pCmd = path22.join(pathPart, cmd);
          const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          for (let j = 0; j < pathExt.length; j++) {
            const cur = p + pathExt[j];
            try {
              const is = isexe.sync(cur, { pathExt: pathExtExe });
              if (is) {
                if (opt.all)
                  found.push(cur);
                else
                  return cur;
              }
            } catch (ex) {
            }
          }
        }
        if (opt.all && found.length)
          return found;
        if (opt.nothrow)
          return null;
        throw getNotFoundError(cmd);
      }, "whichSync");
      module2.exports = which;
      which.sync = whichSync;
    });
    var require_path_key = __commonJS((exports2, module2) => {
      "use strict";
      var pathKey = /* @__PURE__ */ __name((options2 = {}) => {
        const environment = options2.env || process.env;
        const platform2 = options2.platform || process.platform;
        if (platform2 !== "win32") {
          return "PATH";
        }
        return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
      }, "pathKey");
      module2.exports = pathKey;
      module2.exports.default = pathKey;
    });
    var require_resolveCommand = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var which = require_which();
      var getPathKey = require_path_key();
      function resolveCommandAttempt(parsed, withoutPathExt) {
        const env = parsed.options.env || process.env;
        const cwd = process.cwd();
        const hasCustomCwd = parsed.options.cwd != null;
        const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
        if (shouldSwitchCwd) {
          try {
            process.chdir(parsed.options.cwd);
          } catch (err) {
          }
        }
        let resolved;
        try {
          resolved = which.sync(parsed.command, {
            path: env[getPathKey({ env })],
            pathExt: withoutPathExt ? path22.delimiter : void 0
          });
        } catch (e) {
        } finally {
          if (shouldSwitchCwd) {
            process.chdir(cwd);
          }
        }
        if (resolved) {
          resolved = path22.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
        }
        return resolved;
      }
      __name(resolveCommandAttempt, "resolveCommandAttempt");
      function resolveCommand(parsed) {
        return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
      }
      __name(resolveCommand, "resolveCommand");
      module2.exports = resolveCommand;
    });
    var require_escape = __commonJS((exports2, module2) => {
      "use strict";
      var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
      function escapeCommand(arg2) {
        arg2 = arg2.replace(metaCharsRegExp, "^$1");
        return arg2;
      }
      __name(escapeCommand, "escapeCommand");
      function escapeArgument(arg2, doubleEscapeMetaChars) {
        arg2 = `${arg2}`;
        arg2 = arg2.replace(/(\\*)"/g, '$1$1\\"');
        arg2 = arg2.replace(/(\\*)$/, "$1$1");
        arg2 = `"${arg2}"`;
        arg2 = arg2.replace(metaCharsRegExp, "^$1");
        if (doubleEscapeMetaChars) {
          arg2 = arg2.replace(metaCharsRegExp, "^$1");
        }
        return arg2;
      }
      __name(escapeArgument, "escapeArgument");
      module2.exports.command = escapeCommand;
      module2.exports.argument = escapeArgument;
    });
    var require_shebang_regex = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = /^#!(.*)/;
    });
    var require_shebang_command = __commonJS((exports2, module2) => {
      "use strict";
      var shebangRegex = require_shebang_regex();
      module2.exports = (string = "") => {
        const match = string.match(shebangRegex);
        if (!match) {
          return null;
        }
        const [path22, argument] = match[0].replace(/#! ?/, "").split(" ");
        const binary = path22.split("/").pop();
        if (binary === "env") {
          return argument;
        }
        return argument ? `${binary} ${argument}` : binary;
      };
    });
    var require_readShebang = __commonJS((exports2, module2) => {
      "use strict";
      var fs7 = __require("fs");
      var shebangCommand = require_shebang_command();
      function readShebang(command) {
        const size = 150;
        const buffer = Buffer.alloc(size);
        let fd;
        try {
          fd = fs7.openSync(command, "r");
          fs7.readSync(fd, buffer, 0, size, 0);
          fs7.closeSync(fd);
        } catch (e) {
        }
        return shebangCommand(buffer.toString());
      }
      __name(readShebang, "readShebang");
      module2.exports = readShebang;
    });
    var require_parse = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var resolveCommand = require_resolveCommand();
      var escape = require_escape();
      var readShebang = require_readShebang();
      var isWin = process.platform === "win32";
      var isExecutableRegExp = /\.(?:com|exe)$/i;
      var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
      function detectShebang(parsed) {
        parsed.file = resolveCommand(parsed);
        const shebang = parsed.file && readShebang(parsed.file);
        if (shebang) {
          parsed.args.unshift(parsed.file);
          parsed.command = shebang;
          return resolveCommand(parsed);
        }
        return parsed.file;
      }
      __name(detectShebang, "detectShebang");
      function parseNonShell(parsed) {
        if (!isWin) {
          return parsed;
        }
        const commandFile = detectShebang(parsed);
        const needsShell = !isExecutableRegExp.test(commandFile);
        if (parsed.options.forceShell || needsShell) {
          const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
          parsed.command = path22.normalize(parsed.command);
          parsed.command = escape.command(parsed.command);
          parsed.args = parsed.args.map((arg2) => escape.argument(arg2, needsDoubleEscapeMetaChars));
          const shellCommand = [parsed.command].concat(parsed.args).join(" ");
          parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
          parsed.command = process.env.comspec || "cmd.exe";
          parsed.options.windowsVerbatimArguments = true;
        }
        return parsed;
      }
      __name(parseNonShell, "parseNonShell");
      function parse2(command, args, options2) {
        if (args && !Array.isArray(args)) {
          options2 = args;
          args = null;
        }
        args = args ? args.slice(0) : [];
        options2 = Object.assign({}, options2);
        const parsed = {
          command,
          args,
          options: options2,
          file: void 0,
          original: {
            command,
            args
          }
        };
        return options2.shell ? parsed : parseNonShell(parsed);
      }
      __name(parse2, "parse");
      module2.exports = parse2;
    });
    var require_enoent = __commonJS((exports2, module2) => {
      "use strict";
      var isWin = process.platform === "win32";
      function notFoundError(original, syscall) {
        return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
          code: "ENOENT",
          errno: "ENOENT",
          syscall: `${syscall} ${original.command}`,
          path: original.command,
          spawnargs: original.args
        });
      }
      __name(notFoundError, "notFoundError");
      function hookChildProcess(cp, parsed) {
        if (!isWin) {
          return;
        }
        const originalEmit = cp.emit;
        cp.emit = function(name, arg1) {
          if (name === "exit") {
            const err = verifyENOENT(arg1, parsed, "spawn");
            if (err) {
              return originalEmit.call(cp, "error", err);
            }
          }
          return originalEmit.apply(cp, arguments);
        };
      }
      __name(hookChildProcess, "hookChildProcess");
      function verifyENOENT(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, "spawn");
        }
        return null;
      }
      __name(verifyENOENT, "verifyENOENT");
      function verifyENOENTSync(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, "spawnSync");
        }
        return null;
      }
      __name(verifyENOENTSync, "verifyENOENTSync");
      module2.exports = {
        hookChildProcess,
        verifyENOENT,
        verifyENOENTSync,
        notFoundError
      };
    });
    var require_cross_spawn = __commonJS((exports2, module2) => {
      "use strict";
      var cp = __require("child_process");
      var parse2 = require_parse();
      var enoent = require_enoent();
      function spawn2(command, args, options2) {
        const parsed = parse2(command, args, options2);
        const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
        enoent.hookChildProcess(spawned, parsed);
        return spawned;
      }
      __name(spawn2, "spawn");
      function spawnSync(command, args, options2) {
        const parsed = parse2(command, args, options2);
        const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
        result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
        return result;
      }
      __name(spawnSync, "spawnSync");
      module2.exports = spawn2;
      module2.exports.spawn = spawn2;
      module2.exports.sync = spawnSync;
      module2.exports._parse = parse2;
      module2.exports._enoent = enoent;
    });
    var require_strip_final_newline = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = (input) => {
        const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
        const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
        if (input[input.length - 1] === LF) {
          input = input.slice(0, input.length - 1);
        }
        if (input[input.length - 1] === CR) {
          input = input.slice(0, input.length - 1);
        }
        return input;
      };
    });
    var require_npm_run_path = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var pathKey = require_path_key();
      var npmRunPath = /* @__PURE__ */ __name((options2) => {
        options2 = {
          cwd: process.cwd(),
          path: process.env[pathKey()],
          execPath: process.execPath,
          ...options2
        };
        let previous;
        let cwdPath = path22.resolve(options2.cwd);
        const result = [];
        while (previous !== cwdPath) {
          result.push(path22.join(cwdPath, "node_modules/.bin"));
          previous = cwdPath;
          cwdPath = path22.resolve(cwdPath, "..");
        }
        const execPathDir = path22.resolve(options2.cwd, options2.execPath, "..");
        result.push(execPathDir);
        return result.concat(options2.path).join(path22.delimiter);
      }, "npmRunPath");
      module2.exports = npmRunPath;
      module2.exports.default = npmRunPath;
      module2.exports.env = (options2) => {
        options2 = {
          env: process.env,
          ...options2
        };
        const env = { ...options2.env };
        const path32 = pathKey({ env });
        options2.path = env[path32];
        env[path32] = module2.exports(options2);
        return env;
      };
    });
    var require_mimic_fn = __commonJS((exports2, module2) => {
      "use strict";
      var mimicFn = /* @__PURE__ */ __name((to, from) => {
        for (const prop of Reflect.ownKeys(from)) {
          Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
        }
        return to;
      }, "mimicFn");
      module2.exports = mimicFn;
      module2.exports.default = mimicFn;
    });
    var require_onetime = __commonJS((exports2, module2) => {
      "use strict";
      var mimicFn = require_mimic_fn();
      var calledFunctions = new WeakMap();
      var onetime = /* @__PURE__ */ __name((function_, options2 = {}) => {
        if (typeof function_ !== "function") {
          throw new TypeError("Expected a function");
        }
        let returnValue;
        let callCount = 0;
        const functionName = function_.displayName || function_.name || "<anonymous>";
        const onetime2 = /* @__PURE__ */ __name(function(...arguments_) {
          calledFunctions.set(onetime2, ++callCount);
          if (callCount === 1) {
            returnValue = function_.apply(this, arguments_);
            function_ = null;
          } else if (options2.throw === true) {
            throw new Error(`Function \`${functionName}\` can only be called once`);
          }
          return returnValue;
        }, "onetime2");
        mimicFn(onetime2, function_);
        calledFunctions.set(onetime2, callCount);
        return onetime2;
      }, "onetime");
      module2.exports = onetime;
      module2.exports.default = onetime;
      module2.exports.callCount = (function_) => {
        if (!calledFunctions.has(function_)) {
          throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
        }
        return calledFunctions.get(function_);
      };
    });
    var require_core = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SIGNALS = void 0;
      var SIGNALS = [
        {
          name: "SIGHUP",
          number: 1,
          action: "terminate",
          description: "Terminal closed",
          standard: "posix"
        },
        {
          name: "SIGINT",
          number: 2,
          action: "terminate",
          description: "User interruption with CTRL-C",
          standard: "ansi"
        },
        {
          name: "SIGQUIT",
          number: 3,
          action: "core",
          description: "User interruption with CTRL-\\",
          standard: "posix"
        },
        {
          name: "SIGILL",
          number: 4,
          action: "core",
          description: "Invalid machine instruction",
          standard: "ansi"
        },
        {
          name: "SIGTRAP",
          number: 5,
          action: "core",
          description: "Debugger breakpoint",
          standard: "posix"
        },
        {
          name: "SIGABRT",
          number: 6,
          action: "core",
          description: "Aborted",
          standard: "ansi"
        },
        {
          name: "SIGIOT",
          number: 6,
          action: "core",
          description: "Aborted",
          standard: "bsd"
        },
        {
          name: "SIGBUS",
          number: 7,
          action: "core",
          description: "Bus error due to misaligned, non-existing address or paging error",
          standard: "bsd"
        },
        {
          name: "SIGEMT",
          number: 7,
          action: "terminate",
          description: "Command should be emulated but is not implemented",
          standard: "other"
        },
        {
          name: "SIGFPE",
          number: 8,
          action: "core",
          description: "Floating point arithmetic error",
          standard: "ansi"
        },
        {
          name: "SIGKILL",
          number: 9,
          action: "terminate",
          description: "Forced termination",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGUSR1",
          number: 10,
          action: "terminate",
          description: "Application-specific signal",
          standard: "posix"
        },
        {
          name: "SIGSEGV",
          number: 11,
          action: "core",
          description: "Segmentation fault",
          standard: "ansi"
        },
        {
          name: "SIGUSR2",
          number: 12,
          action: "terminate",
          description: "Application-specific signal",
          standard: "posix"
        },
        {
          name: "SIGPIPE",
          number: 13,
          action: "terminate",
          description: "Broken pipe or socket",
          standard: "posix"
        },
        {
          name: "SIGALRM",
          number: 14,
          action: "terminate",
          description: "Timeout or timer",
          standard: "posix"
        },
        {
          name: "SIGTERM",
          number: 15,
          action: "terminate",
          description: "Termination",
          standard: "ansi"
        },
        {
          name: "SIGSTKFLT",
          number: 16,
          action: "terminate",
          description: "Stack is empty or overflowed",
          standard: "other"
        },
        {
          name: "SIGCHLD",
          number: 17,
          action: "ignore",
          description: "Child process terminated, paused or unpaused",
          standard: "posix"
        },
        {
          name: "SIGCLD",
          number: 17,
          action: "ignore",
          description: "Child process terminated, paused or unpaused",
          standard: "other"
        },
        {
          name: "SIGCONT",
          number: 18,
          action: "unpause",
          description: "Unpaused",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGSTOP",
          number: 19,
          action: "pause",
          description: "Paused",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGTSTP",
          number: 20,
          action: "pause",
          description: 'Paused using CTRL-Z or "suspend"',
          standard: "posix"
        },
        {
          name: "SIGTTIN",
          number: 21,
          action: "pause",
          description: "Background process cannot read terminal input",
          standard: "posix"
        },
        {
          name: "SIGBREAK",
          number: 21,
          action: "terminate",
          description: "User interruption with CTRL-BREAK",
          standard: "other"
        },
        {
          name: "SIGTTOU",
          number: 22,
          action: "pause",
          description: "Background process cannot write to terminal output",
          standard: "posix"
        },
        {
          name: "SIGURG",
          number: 23,
          action: "ignore",
          description: "Socket received out-of-band data",
          standard: "bsd"
        },
        {
          name: "SIGXCPU",
          number: 24,
          action: "core",
          description: "Process timed out",
          standard: "bsd"
        },
        {
          name: "SIGXFSZ",
          number: 25,
          action: "core",
          description: "File too big",
          standard: "bsd"
        },
        {
          name: "SIGVTALRM",
          number: 26,
          action: "terminate",
          description: "Timeout or timer",
          standard: "bsd"
        },
        {
          name: "SIGPROF",
          number: 27,
          action: "terminate",
          description: "Timeout or timer",
          standard: "bsd"
        },
        {
          name: "SIGWINCH",
          number: 28,
          action: "ignore",
          description: "Terminal window size changed",
          standard: "bsd"
        },
        {
          name: "SIGIO",
          number: 29,
          action: "terminate",
          description: "I/O is available",
          standard: "other"
        },
        {
          name: "SIGPOLL",
          number: 29,
          action: "terminate",
          description: "Watched event",
          standard: "other"
        },
        {
          name: "SIGINFO",
          number: 29,
          action: "ignore",
          description: "Request for process information",
          standard: "other"
        },
        {
          name: "SIGPWR",
          number: 30,
          action: "terminate",
          description: "Device running out of power",
          standard: "systemv"
        },
        {
          name: "SIGSYS",
          number: 31,
          action: "core",
          description: "Invalid system call",
          standard: "other"
        },
        {
          name: "SIGUNUSED",
          number: 31,
          action: "terminate",
          description: "Invalid system call",
          standard: "other"
        }
      ];
      exports2.SIGNALS = SIGNALS;
    });
    var require_realtime = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
      var getRealtimeSignals = /* @__PURE__ */ __name(function() {
        const length = SIGRTMAX - SIGRTMIN + 1;
        return Array.from({ length }, getRealtimeSignal);
      }, "getRealtimeSignals");
      exports2.getRealtimeSignals = getRealtimeSignals;
      var getRealtimeSignal = /* @__PURE__ */ __name(function(value, index) {
        return {
          name: `SIGRT${index + 1}`,
          number: SIGRTMIN + index,
          action: "terminate",
          description: "Application-specific signal (realtime)",
          standard: "posix"
        };
      }, "getRealtimeSignal");
      var SIGRTMIN = 34;
      var SIGRTMAX = 64;
      exports2.SIGRTMAX = SIGRTMAX;
    });
    var require_signals = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getSignals = void 0;
      var _os = __require("os");
      var _core = require_core();
      var _realtime = require_realtime();
      var getSignals = /* @__PURE__ */ __name(function() {
        const realtimeSignals = (0, _realtime.getRealtimeSignals)();
        const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
        return signals;
      }, "getSignals");
      exports2.getSignals = getSignals;
      var normalizeSignal = /* @__PURE__ */ __name(function({
        name,
        number: defaultNumber,
        description,
        action,
        forced = false,
        standard
      }) {
        const {
          signals: { [name]: constantSignal }
        } = _os.constants;
        const supported = constantSignal !== void 0;
        const number = supported ? constantSignal : defaultNumber;
        return { name, number, description, supported, action, forced, standard };
      }, "normalizeSignal");
    });
    var require_main = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.signalsByNumber = exports2.signalsByName = void 0;
      var _os = __require("os");
      var _signals = require_signals();
      var _realtime = require_realtime();
      var getSignalsByName = /* @__PURE__ */ __name(function() {
        const signals = (0, _signals.getSignals)();
        return signals.reduce(getSignalByName, {});
      }, "getSignalsByName");
      var getSignalByName = /* @__PURE__ */ __name(function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
        return {
          ...signalByNameMemo,
          [name]: { name, number, description, supported, action, forced, standard }
        };
      }, "getSignalByName");
      var signalsByName = getSignalsByName();
      exports2.signalsByName = signalsByName;
      var getSignalsByNumber = /* @__PURE__ */ __name(function() {
        const signals = (0, _signals.getSignals)();
        const length = _realtime.SIGRTMAX + 1;
        const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
        return Object.assign({}, ...signalsA);
      }, "getSignalsByNumber");
      var getSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {
        const signal = findSignalByNumber(number, signals);
        if (signal === void 0) {
          return {};
        }
        const { name, description, supported, action, forced, standard } = signal;
        return {
          [number]: {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
          }
        };
      }, "getSignalByNumber");
      var findSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {
        const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
        if (signal !== void 0) {
          return signal;
        }
        return signals.find((signalA) => signalA.number === number);
      }, "findSignalByNumber");
      var signalsByNumber = getSignalsByNumber();
      exports2.signalsByNumber = signalsByNumber;
    });
    var require_error = __commonJS((exports2, module2) => {
      "use strict";
      var { signalsByName } = require_main();
      var getErrorPrefix = /* @__PURE__ */ __name(({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
        if (timedOut) {
          return `timed out after ${timeout} milliseconds`;
        }
        if (isCanceled) {
          return "was canceled";
        }
        if (errorCode !== void 0) {
          return `failed with ${errorCode}`;
        }
        if (signal !== void 0) {
          return `was killed with ${signal} (${signalDescription})`;
        }
        if (exitCode !== void 0) {
          return `failed with exit code ${exitCode}`;
        }
        return "failed";
      }, "getErrorPrefix");
      var makeError = /* @__PURE__ */ __name(({
        stdout,
        stderr,
        all,
        error: error2,
        signal,
        exitCode,
        command,
        escapedCommand,
        timedOut,
        isCanceled,
        killed,
        parsed: { options: { timeout } }
      }) => {
        exitCode = exitCode === null ? void 0 : exitCode;
        signal = signal === null ? void 0 : signal;
        const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
        const errorCode = error2 && error2.code;
        const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
        const execaMessage = `Command ${prefix}: ${command}`;
        const isError2 = Object.prototype.toString.call(error2) === "[object Error]";
        const shortMessage = isError2 ? `${execaMessage}
${error2.message}` : execaMessage;
        const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
        if (isError2) {
          error2.originalMessage = error2.message;
          error2.message = message;
        } else {
          error2 = new Error(message);
        }
        error2.shortMessage = shortMessage;
        error2.command = command;
        error2.escapedCommand = escapedCommand;
        error2.exitCode = exitCode;
        error2.signal = signal;
        error2.signalDescription = signalDescription;
        error2.stdout = stdout;
        error2.stderr = stderr;
        if (all !== void 0) {
          error2.all = all;
        }
        if ("bufferedData" in error2) {
          delete error2.bufferedData;
        }
        error2.failed = true;
        error2.timedOut = Boolean(timedOut);
        error2.isCanceled = isCanceled;
        error2.killed = killed && !timedOut;
        return error2;
      }, "makeError");
      module2.exports = makeError;
    });
    var require_stdio = __commonJS((exports2, module2) => {
      "use strict";
      var aliases = ["stdin", "stdout", "stderr"];
      var hasAlias = /* @__PURE__ */ __name((options2) => aliases.some((alias) => options2[alias] !== void 0), "hasAlias");
      var normalizeStdio = /* @__PURE__ */ __name((options2) => {
        if (!options2) {
          return;
        }
        const { stdio } = options2;
        if (stdio === void 0) {
          return aliases.map((alias) => options2[alias]);
        }
        if (hasAlias(options2)) {
          throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
        }
        if (typeof stdio === "string") {
          return stdio;
        }
        if (!Array.isArray(stdio)) {
          throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
        }
        const length = Math.max(stdio.length, aliases.length);
        return Array.from({ length }, (value, index) => stdio[index]);
      }, "normalizeStdio");
      module2.exports = normalizeStdio;
      module2.exports.node = (options2) => {
        const stdio = normalizeStdio(options2);
        if (stdio === "ipc") {
          return "ipc";
        }
        if (stdio === void 0 || typeof stdio === "string") {
          return [stdio, stdio, stdio, "ipc"];
        }
        if (stdio.includes("ipc")) {
          return stdio;
        }
        return [...stdio, "ipc"];
      };
    });
    var require_signals2 = __commonJS((exports2, module2) => {
      module2.exports = [
        "SIGABRT",
        "SIGALRM",
        "SIGHUP",
        "SIGINT",
        "SIGTERM"
      ];
      if (process.platform !== "win32") {
        module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
      }
      if (process.platform === "linux") {
        module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
      }
    });
    var require_signal_exit = __commonJS((exports2, module2) => {
      var assert = __require("assert");
      var signals = require_signals2();
      var isWin = /^win/i.test(process.platform);
      var EE = __require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      var emitter;
      if (process.__signal_exit_emitter__) {
        emitter = process.__signal_exit_emitter__;
      } else {
        emitter = process.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts2) {
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts2 && opts2.alwaysLast) {
          ev = "afterexit";
        }
        var remove = /* @__PURE__ */ __name(function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        }, "remove");
        emitter.on(ev, cb);
        return remove;
      };
      module2.exports.unload = unload;
      function unload() {
        if (!loaded) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process.emit = originalProcessEmit;
        process.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      }
      __name(unload, "unload");
      function emit(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      }
      __name(emit, "emit");
      var sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = /* @__PURE__ */ __name(function listener() {
          var listeners = process.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process.kill(process.pid, sig);
          }
        }, "listener");
      });
      module2.exports.signals = function() {
        return signals;
      };
      module2.exports.load = load;
      var loaded = false;
      function load() {
        if (loaded) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process.emit = processEmit;
        process.reallyExit = processReallyExit;
      }
      __name(load, "load");
      var originalProcessReallyExit = process.reallyExit;
      function processReallyExit(code) {
        process.exitCode = code || 0;
        emit("exit", process.exitCode, null);
        emit("afterexit", process.exitCode, null);
        originalProcessReallyExit.call(process, process.exitCode);
      }
      __name(processReallyExit, "processReallyExit");
      var originalProcessEmit = process.emit;
      function processEmit(ev, arg2) {
        if (ev === "exit") {
          if (arg2 !== void 0) {
            process.exitCode = arg2;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process.exitCode, null);
          emit("afterexit", process.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      }
      __name(processEmit, "processEmit");
    });
    var require_kill = __commonJS((exports2, module2) => {
      "use strict";
      var os2 = __require("os");
      var onExit = require_signal_exit();
      var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
      var spawnedKill = /* @__PURE__ */ __name((kill, signal = "SIGTERM", options2 = {}) => {
        const killResult = kill(signal);
        setKillTimeout(kill, signal, options2, killResult);
        return killResult;
      }, "spawnedKill");
      var setKillTimeout = /* @__PURE__ */ __name((kill, signal, options2, killResult) => {
        if (!shouldForceKill(signal, options2, killResult)) {
          return;
        }
        const timeout = getForceKillAfterTimeout(options2);
        const t = setTimeout(() => {
          kill("SIGKILL");
        }, timeout);
        if (t.unref) {
          t.unref();
        }
      }, "setKillTimeout");
      var shouldForceKill = /* @__PURE__ */ __name((signal, { forceKillAfterTimeout }, killResult) => {
        return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
      }, "shouldForceKill");
      var isSigterm = /* @__PURE__ */ __name((signal) => {
        return signal === os2.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
      }, "isSigterm");
      var getForceKillAfterTimeout = /* @__PURE__ */ __name(({ forceKillAfterTimeout = true }) => {
        if (forceKillAfterTimeout === true) {
          return DEFAULT_FORCE_KILL_TIMEOUT;
        }
        if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
          throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
        }
        return forceKillAfterTimeout;
      }, "getForceKillAfterTimeout");
      var spawnedCancel = /* @__PURE__ */ __name((spawned, context) => {
        const killResult = spawned.kill();
        if (killResult) {
          context.isCanceled = true;
        }
      }, "spawnedCancel");
      var timeoutKill = /* @__PURE__ */ __name((spawned, signal, reject2) => {
        spawned.kill(signal);
        reject2(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
      }, "timeoutKill");
      var setupTimeout = /* @__PURE__ */ __name((spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
        if (timeout === 0 || timeout === void 0) {
          return spawnedPromise;
        }
        let timeoutId;
        const timeoutPromise = new Promise((resolve2, reject2) => {
          timeoutId = setTimeout(() => {
            timeoutKill(spawned, killSignal, reject2);
          }, timeout);
        });
        const safeSpawnedPromise = spawnedPromise.finally(() => {
          clearTimeout(timeoutId);
        });
        return Promise.race([timeoutPromise, safeSpawnedPromise]);
      }, "setupTimeout");
      var validateTimeout = /* @__PURE__ */ __name(({ timeout }) => {
        if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
          throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
        }
      }, "validateTimeout");
      var setExitHandler = /* @__PURE__ */ __name(async (spawned, { cleanup, detached }, timedPromise) => {
        if (!cleanup || detached) {
          return timedPromise;
        }
        const removeExitHandler = onExit(() => {
          spawned.kill();
        });
        return timedPromise.finally(() => {
          removeExitHandler();
        });
      }, "setExitHandler");
      module2.exports = {
        spawnedKill,
        spawnedCancel,
        setupTimeout,
        validateTimeout,
        setExitHandler
      };
    });
    var require_is_stream = __commonJS((exports2, module2) => {
      "use strict";
      var isStream = /* @__PURE__ */ __name((stream3) => stream3 !== null && typeof stream3 === "object" && typeof stream3.pipe === "function", "isStream");
      isStream.writable = (stream3) => isStream(stream3) && stream3.writable !== false && typeof stream3._write === "function" && typeof stream3._writableState === "object";
      isStream.readable = (stream3) => isStream(stream3) && stream3.readable !== false && typeof stream3._read === "function" && typeof stream3._readableState === "object";
      isStream.duplex = (stream3) => isStream.writable(stream3) && isStream.readable(stream3);
      isStream.transform = (stream3) => isStream.duplex(stream3) && typeof stream3._transform === "function" && typeof stream3._transformState === "object";
      module2.exports = isStream;
    });
    var require_buffer_stream = __commonJS((exports2, module2) => {
      "use strict";
      var { PassThrough: PassThroughStream } = __require("stream");
      module2.exports = (options2) => {
        options2 = { ...options2 };
        const { array } = options2;
        let { encoding } = options2;
        const isBuffer = encoding === "buffer";
        let objectMode = false;
        if (array) {
          objectMode = !(encoding || isBuffer);
        } else {
          encoding = encoding || "utf8";
        }
        if (isBuffer) {
          encoding = null;
        }
        const stream3 = new PassThroughStream({ objectMode });
        if (encoding) {
          stream3.setEncoding(encoding);
        }
        let length = 0;
        const chunks = [];
        stream3.on("data", (chunk) => {
          chunks.push(chunk);
          if (objectMode) {
            length = chunks.length;
          } else {
            length += chunk.length;
          }
        });
        stream3.getBufferedValue = () => {
          if (array) {
            return chunks;
          }
          return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
        };
        stream3.getBufferedLength = () => length;
        return stream3;
      };
    });
    var require_get_stream = __commonJS((exports2, module2) => {
      "use strict";
      var { constants: BufferConstants } = __require("buffer");
      var stream3 = __require("stream");
      var { promisify: promisify3 } = __require("util");
      var bufferStream = require_buffer_stream();
      var streamPipelinePromisified = promisify3(stream3.pipeline);
      var MaxBufferError = /* @__PURE__ */ __name(class extends Error {
        constructor() {
          super("maxBuffer exceeded");
          this.name = "MaxBufferError";
        }
      }, "MaxBufferError");
      async function getStream2(inputStream, options2) {
        if (!inputStream) {
          throw new Error("Expected a stream");
        }
        options2 = {
          maxBuffer: Infinity,
          ...options2
        };
        const { maxBuffer } = options2;
        const stream22 = bufferStream(options2);
        await new Promise((resolve2, reject2) => {
          const rejectPromise = /* @__PURE__ */ __name((error2) => {
            if (error2 && stream22.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
              error2.bufferedData = stream22.getBufferedValue();
            }
            reject2(error2);
          }, "rejectPromise");
          (async () => {
            try {
              await streamPipelinePromisified(inputStream, stream22);
              resolve2();
            } catch (error2) {
              rejectPromise(error2);
            }
          })();
          stream22.on("data", () => {
            if (stream22.getBufferedLength() > maxBuffer) {
              rejectPromise(new MaxBufferError());
            }
          });
        });
        return stream22.getBufferedValue();
      }
      __name(getStream2, "getStream");
      module2.exports = getStream2;
      module2.exports.buffer = (stream22, options2) => getStream2(stream22, { ...options2, encoding: "buffer" });
      module2.exports.array = (stream22, options2) => getStream2(stream22, { ...options2, array: true });
      module2.exports.MaxBufferError = MaxBufferError;
    });
    var require_merge_stream = __commonJS((exports2, module2) => {
      "use strict";
      var { PassThrough } = __require("stream");
      module2.exports = function() {
        var sources = [];
        var output = new PassThrough({ objectMode: true });
        output.setMaxListeners(0);
        output.add = add2;
        output.isEmpty = isEmpty;
        output.on("unpipe", remove);
        Array.prototype.slice.call(arguments).forEach(add2);
        return output;
        function add2(source) {
          if (Array.isArray(source)) {
            source.forEach(add2);
            return this;
          }
          sources.push(source);
          source.once("end", remove.bind(null, source));
          source.once("error", output.emit.bind(output, "error"));
          source.pipe(output, { end: false });
          return this;
        }
        __name(add2, "add");
        function isEmpty() {
          return sources.length == 0;
        }
        __name(isEmpty, "isEmpty");
        function remove(source) {
          sources = sources.filter(function(it) {
            return it !== source;
          });
          if (!sources.length && output.readable) {
            output.end();
          }
        }
        __name(remove, "remove");
      };
    });
    var require_stream = __commonJS((exports2, module2) => {
      "use strict";
      var isStream = require_is_stream();
      var getStream2 = require_get_stream();
      var mergeStream = require_merge_stream();
      var handleInput = /* @__PURE__ */ __name((spawned, input) => {
        if (input === void 0 || spawned.stdin === void 0) {
          return;
        }
        if (isStream(input)) {
          input.pipe(spawned.stdin);
        } else {
          spawned.stdin.end(input);
        }
      }, "handleInput");
      var makeAllStream = /* @__PURE__ */ __name((spawned, { all }) => {
        if (!all || !spawned.stdout && !spawned.stderr) {
          return;
        }
        const mixed = mergeStream();
        if (spawned.stdout) {
          mixed.add(spawned.stdout);
        }
        if (spawned.stderr) {
          mixed.add(spawned.stderr);
        }
        return mixed;
      }, "makeAllStream");
      var getBufferedData = /* @__PURE__ */ __name(async (stream3, streamPromise) => {
        if (!stream3) {
          return;
        }
        stream3.destroy();
        try {
          return await streamPromise;
        } catch (error2) {
          return error2.bufferedData;
        }
      }, "getBufferedData");
      var getStreamPromise = /* @__PURE__ */ __name((stream3, { encoding, buffer, maxBuffer }) => {
        if (!stream3 || !buffer) {
          return;
        }
        if (encoding) {
          return getStream2(stream3, { encoding, maxBuffer });
        }
        return getStream2.buffer(stream3, { maxBuffer });
      }, "getStreamPromise");
      var getSpawnedResult = /* @__PURE__ */ __name(async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
        const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
        const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
        const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
        try {
          return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
        } catch (error2) {
          return Promise.all([
            { error: error2, signal: error2.signal, timedOut: error2.timedOut },
            getBufferedData(stdout, stdoutPromise),
            getBufferedData(stderr, stderrPromise),
            getBufferedData(all, allPromise)
          ]);
        }
      }, "getSpawnedResult");
      var validateInputSync = /* @__PURE__ */ __name(({ input }) => {
        if (isStream(input)) {
          throw new TypeError("The `input` option cannot be a stream in sync mode");
        }
      }, "validateInputSync");
      module2.exports = {
        handleInput,
        makeAllStream,
        getSpawnedResult,
        validateInputSync
      };
    });
    var require_promise = __commonJS((exports2, module2) => {
      "use strict";
      var nativePromisePrototype = (async () => {
      })().constructor.prototype;
      var descriptors = ["then", "catch", "finally"].map((property) => [
        property,
        Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
      ]);
      var mergePromise = /* @__PURE__ */ __name((spawned, promise) => {
        for (const [property, descriptor] of descriptors) {
          const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
          Reflect.defineProperty(spawned, property, { ...descriptor, value });
        }
        return spawned;
      }, "mergePromise");
      var getSpawnedPromise = /* @__PURE__ */ __name((spawned) => {
        return new Promise((resolve2, reject2) => {
          spawned.on("exit", (exitCode, signal) => {
            resolve2({ exitCode, signal });
          });
          spawned.on("error", (error2) => {
            reject2(error2);
          });
          if (spawned.stdin) {
            spawned.stdin.on("error", (error2) => {
              reject2(error2);
            });
          }
        });
      }, "getSpawnedPromise");
      module2.exports = {
        mergePromise,
        getSpawnedPromise
      };
    });
    var require_command = __commonJS((exports2, module2) => {
      "use strict";
      var normalizeArgs = /* @__PURE__ */ __name((file2, args = []) => {
        if (!Array.isArray(args)) {
          return [file2];
        }
        return [file2, ...args];
      }, "normalizeArgs");
      var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
      var DOUBLE_QUOTES_REGEXP = /"/g;
      var escapeArg = /* @__PURE__ */ __name((arg2) => {
        if (typeof arg2 !== "string" || NO_ESCAPE_REGEXP.test(arg2)) {
          return arg2;
        }
        return `"${arg2.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
      }, "escapeArg");
      var joinCommand = /* @__PURE__ */ __name((file2, args) => {
        return normalizeArgs(file2, args).join(" ");
      }, "joinCommand");
      var getEscapedCommand = /* @__PURE__ */ __name((file2, args) => {
        return normalizeArgs(file2, args).map((arg2) => escapeArg(arg2)).join(" ");
      }, "getEscapedCommand");
      var SPACES_REGEXP = / +/g;
      var parseCommand = /* @__PURE__ */ __name((command) => {
        const tokens = [];
        for (const token of command.trim().split(SPACES_REGEXP)) {
          const previousToken = tokens[tokens.length - 1];
          if (previousToken && previousToken.endsWith("\\")) {
            tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
          } else {
            tokens.push(token);
          }
        }
        return tokens;
      }, "parseCommand");
      module2.exports = {
        joinCommand,
        getEscapedCommand,
        parseCommand
      };
    });
    var require_execa = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var childProcess = __require("child_process");
      var crossSpawn = require_cross_spawn();
      var stripFinalNewline = require_strip_final_newline();
      var npmRunPath = require_npm_run_path();
      var onetime = require_onetime();
      var makeError = require_error();
      var normalizeStdio = require_stdio();
      var { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = require_kill();
      var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream();
      var { mergePromise, getSpawnedPromise } = require_promise();
      var { joinCommand, parseCommand, getEscapedCommand } = require_command();
      var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
      var getEnv = /* @__PURE__ */ __name(({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
        const env = extendEnv ? { ...process.env, ...envOption } : envOption;
        if (preferLocal) {
          return npmRunPath.env({ env, cwd: localDir, execPath });
        }
        return env;
      }, "getEnv");
      var handleArguments = /* @__PURE__ */ __name((file2, args, options2 = {}) => {
        const parsed = crossSpawn._parse(file2, args, options2);
        file2 = parsed.command;
        args = parsed.args;
        options2 = parsed.options;
        options2 = {
          maxBuffer: DEFAULT_MAX_BUFFER,
          buffer: true,
          stripFinalNewline: true,
          extendEnv: true,
          preferLocal: false,
          localDir: options2.cwd || process.cwd(),
          execPath: process.execPath,
          encoding: "utf8",
          reject: true,
          cleanup: true,
          all: false,
          windowsHide: true,
          ...options2
        };
        options2.env = getEnv(options2);
        options2.stdio = normalizeStdio(options2);
        if (process.platform === "win32" && path22.basename(file2, ".exe") === "cmd") {
          args.unshift("/q");
        }
        return { file: file2, args, options: options2, parsed };
      }, "handleArguments");
      var handleOutput = /* @__PURE__ */ __name((options2, value, error2) => {
        if (typeof value !== "string" && !Buffer.isBuffer(value)) {
          return error2 === void 0 ? void 0 : "";
        }
        if (options2.stripFinalNewline) {
          return stripFinalNewline(value);
        }
        return value;
      }, "handleOutput");
      var execa2 = /* @__PURE__ */ __name((file2, args, options2) => {
        const parsed = handleArguments(file2, args, options2);
        const command = joinCommand(file2, args);
        const escapedCommand = getEscapedCommand(file2, args);
        validateTimeout(parsed.options);
        let spawned;
        try {
          spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
        } catch (error2) {
          const dummySpawned = new childProcess.ChildProcess();
          const errorPromise = Promise.reject(makeError({
            error: error2,
            stdout: "",
            stderr: "",
            all: "",
            command,
            escapedCommand,
            parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
          }));
          return mergePromise(dummySpawned, errorPromise);
        }
        const spawnedPromise = getSpawnedPromise(spawned);
        const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
        const processDone = setExitHandler(spawned, parsed.options, timedPromise);
        const context = { isCanceled: false };
        spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
        spawned.cancel = spawnedCancel.bind(null, spawned, context);
        const handlePromise = /* @__PURE__ */ __name(async () => {
          const [{ error: error2, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
          const stdout = handleOutput(parsed.options, stdoutResult);
          const stderr = handleOutput(parsed.options, stderrResult);
          const all = handleOutput(parsed.options, allResult);
          if (error2 || exitCode !== 0 || signal !== null) {
            const returnedError = makeError({
              error: error2,
              exitCode,
              signal,
              stdout,
              stderr,
              all,
              command,
              escapedCommand,
              parsed,
              timedOut,
              isCanceled: context.isCanceled,
              killed: spawned.killed
            });
            if (!parsed.options.reject) {
              return returnedError;
            }
            throw returnedError;
          }
          return {
            command,
            escapedCommand,
            exitCode: 0,
            stdout,
            stderr,
            all,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
          };
        }, "handlePromise");
        const handlePromiseOnce = onetime(handlePromise);
        handleInput(spawned, parsed.options.input);
        spawned.all = makeAllStream(spawned, parsed.options);
        return mergePromise(spawned, handlePromiseOnce);
      }, "execa");
      module2.exports = execa2;
      module2.exports.sync = (file2, args, options2) => {
        const parsed = handleArguments(file2, args, options2);
        const command = joinCommand(file2, args);
        const escapedCommand = getEscapedCommand(file2, args);
        validateInputSync(parsed.options);
        let result;
        try {
          result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
        } catch (error2) {
          throw makeError({
            error: error2,
            stdout: "",
            stderr: "",
            all: "",
            command,
            escapedCommand,
            parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
          });
        }
        const stdout = handleOutput(parsed.options, result.stdout, result.error);
        const stderr = handleOutput(parsed.options, result.stderr, result.error);
        if (result.error || result.status !== 0 || result.signal !== null) {
          const error2 = makeError({
            stdout,
            stderr,
            error: result.error,
            signal: result.signal,
            exitCode: result.status,
            command,
            escapedCommand,
            parsed,
            timedOut: result.error && result.error.code === "ETIMEDOUT",
            isCanceled: false,
            killed: result.signal !== null
          });
          if (!parsed.options.reject) {
            return error2;
          }
          throw error2;
        }
        return {
          command,
          escapedCommand,
          exitCode: 0,
          stdout,
          stderr,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      };
      module2.exports.command = (command, options2) => {
        const [file2, ...args] = parseCommand(command);
        return execa2(file2, args, options2);
      };
      module2.exports.commandSync = (command, options2) => {
        const [file2, ...args] = parseCommand(command);
        return execa2.sync(file2, args, options2);
      };
      module2.exports.node = (scriptPath, args, options2 = {}) => {
        if (args && !Array.isArray(args) && typeof args === "object") {
          options2 = args;
          args = [];
        }
        const stdio = normalizeStdio.node(options2);
        const defaultExecArgv = process.execArgv.filter((arg2) => !arg2.startsWith("--inspect"));
        const {
          nodePath = process.execPath,
          nodeOptions = defaultExecArgv
        } = options2;
        return execa2(nodePath, [
          ...nodeOptions,
          scriptPath,
          ...Array.isArray(args) ? args : []
        ], {
          ...options2,
          stdin: void 0,
          stdout: void 0,
          stderr: void 0,
          stdio,
          shell: false
        });
      };
    });
    var require_constants = __commonJS((exports2, module2) => {
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      module2.exports = {
        SEMVER_SPEC_VERSION,
        MAX_LENGTH,
        MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
        MAX_SAFE_COMPONENT_LENGTH
      };
    });
    var require_debug = __commonJS((exports2, module2) => {
      var debug32 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module2.exports = debug32;
    });
    var require_re = __commonJS((exports2, module2) => {
      var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
      var debug32 = require_debug();
      exports2 = module2.exports = {};
      var re = exports2.re = [];
      var src = exports2.src = [];
      var t = exports2.t = {};
      var R = 0;
      var createToken = /* @__PURE__ */ __name((name, value, isGlobal) => {
        const index = R++;
        debug32(index, value);
        t[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      }, "createToken");
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
      createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
      createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
      createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
      createToken("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
      createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t.COERCE], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports2.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports2.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
      exports2.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    });
    var require_parse_options = __commonJS((exports2, module2) => {
      var opts2 = ["includePrerelease", "loose", "rtl"];
      var parseOptions = /* @__PURE__ */ __name((options2) => !options2 ? {} : typeof options2 !== "object" ? { loose: true } : opts2.filter((k) => options2[k]).reduce((options22, k) => {
        options22[k] = true;
        return options22;
      }, {}), "parseOptions");
      module2.exports = parseOptions;
    });
    var require_identifiers = __commonJS((exports2, module2) => {
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = /* @__PURE__ */ __name((a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      }, "compareIdentifiers");
      var rcompareIdentifiers = /* @__PURE__ */ __name((a, b) => compareIdentifiers(b, a), "rcompareIdentifiers");
      module2.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    });
    var require_semver = __commonJS((exports2, module2) => {
      var debug32 = require_debug();
      var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants();
      var { re, t } = require_re();
      var parseOptions = require_parse_options();
      var { compareIdentifiers } = require_identifiers();
      var SemVer = /* @__PURE__ */ __name(class {
        constructor(version, options2) {
          options2 = parseOptions(options2);
          if (version instanceof SemVer) {
            if (version.loose === !!options2.loose && version.includePrerelease === !!options2.includePrerelease) {
              return version;
            } else {
              version = version.version;
            }
          } else if (typeof version !== "string") {
            throw new TypeError(`Invalid Version: ${version}`);
          }
          if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
          }
          debug32("SemVer", version, options2);
          this.options = options2;
          this.loose = !!options2.loose;
          this.includePrerelease = !!options2.includePrerelease;
          const m = version.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
          }
          this.raw = version;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug32("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug32("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug32("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        inc(release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier);
              this.inc("pre", identifier);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier);
              }
              this.inc("pre", identifier);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0) {
                this.prerelease = [0];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === "number") {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  this.prerelease.push(0);
                }
              }
              if (identifier) {
                if (this.prerelease[0] === identifier) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = [identifier, 0];
                  }
                } else {
                  this.prerelease = [identifier, 0];
                }
              }
              break;
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.format();
          this.raw = this.version;
          return this;
        }
      }, "SemVer");
      module2.exports = SemVer;
    });
    var require_parse2 = __commonJS((exports2, module2) => {
      var { MAX_LENGTH } = require_constants();
      var { re, t } = require_re();
      var SemVer = require_semver();
      var parseOptions = require_parse_options();
      var parse2 = /* @__PURE__ */ __name((version, options2) => {
        options2 = parseOptions(options2);
        if (version instanceof SemVer) {
          return version;
        }
        if (typeof version !== "string") {
          return null;
        }
        if (version.length > MAX_LENGTH) {
          return null;
        }
        const r = options2.loose ? re[t.LOOSE] : re[t.FULL];
        if (!r.test(version)) {
          return null;
        }
        try {
          return new SemVer(version, options2);
        } catch (er) {
          return null;
        }
      }, "parse");
      module2.exports = parse2;
    });
    var require_valid = __commonJS((exports2, module2) => {
      var parse2 = require_parse2();
      var valid = /* @__PURE__ */ __name((version, options2) => {
        const v = parse2(version, options2);
        return v ? v.version : null;
      }, "valid");
      module2.exports = valid;
    });
    var require_clean = __commonJS((exports2, module2) => {
      var parse2 = require_parse2();
      var clean = /* @__PURE__ */ __name((version, options2) => {
        const s = parse2(version.trim().replace(/^[=v]+/, ""), options2);
        return s ? s.version : null;
      }, "clean");
      module2.exports = clean;
    });
    var require_inc = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var inc = /* @__PURE__ */ __name((version, release, options2, identifier) => {
        if (typeof options2 === "string") {
          identifier = options2;
          options2 = void 0;
        }
        try {
          return new SemVer(version, options2).inc(release, identifier).version;
        } catch (er) {
          return null;
        }
      }, "inc");
      module2.exports = inc;
    });
    var require_compare = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var compare = /* @__PURE__ */ __name((a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose)), "compare");
      module2.exports = compare;
    });
    var require_eq = __commonJS((exports2, module2) => {
      var compare = require_compare();
      var eq = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) === 0, "eq");
      module2.exports = eq;
    });
    var require_diff = __commonJS((exports2, module2) => {
      var parse2 = require_parse2();
      var eq = require_eq();
      var diff = /* @__PURE__ */ __name((version1, version2) => {
        if (eq(version1, version2)) {
          return null;
        } else {
          const v1 = parse2(version1);
          const v2 = parse2(version2);
          const hasPre = v1.prerelease.length || v2.prerelease.length;
          const prefix = hasPre ? "pre" : "";
          const defaultResult = hasPre ? "prerelease" : "";
          for (const key in v1) {
            if (key === "major" || key === "minor" || key === "patch") {
              if (v1[key] !== v2[key]) {
                return prefix + key;
              }
            }
          }
          return defaultResult;
        }
      }, "diff");
      module2.exports = diff;
    });
    var require_major = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var major = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).major, "major");
      module2.exports = major;
    });
    var require_minor = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var minor = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).minor, "minor");
      module2.exports = minor;
    });
    var require_patch = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var patch = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).patch, "patch");
      module2.exports = patch;
    });
    var require_prerelease = __commonJS((exports2, module2) => {
      var parse2 = require_parse2();
      var prerelease = /* @__PURE__ */ __name((version, options2) => {
        const parsed = parse2(version, options2);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      }, "prerelease");
      module2.exports = prerelease;
    });
    var require_rcompare = __commonJS((exports2, module2) => {
      var compare = require_compare();
      var rcompare = /* @__PURE__ */ __name((a, b, loose) => compare(b, a, loose), "rcompare");
      module2.exports = rcompare;
    });
    var require_compare_loose = __commonJS((exports2, module2) => {
      var compare = require_compare();
      var compareLoose = /* @__PURE__ */ __name((a, b) => compare(a, b, true), "compareLoose");
      module2.exports = compareLoose;
    });
    var require_compare_build = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var compareBuild = /* @__PURE__ */ __name((a, b, loose) => {
        const versionA = new SemVer(a, loose);
        const versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
      }, "compareBuild");
      module2.exports = compareBuild;
    });
    var require_sort = __commonJS((exports2, module2) => {
      var compareBuild = require_compare_build();
      var sort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b) => compareBuild(a, b, loose)), "sort");
      module2.exports = sort;
    });
    var require_rsort = __commonJS((exports2, module2) => {
      var compareBuild = require_compare_build();
      var rsort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b) => compareBuild(b, a, loose)), "rsort");
      module2.exports = rsort;
    });
    var require_gt = __commonJS((exports2, module2) => {
      var compare = require_compare();
      var gt = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) > 0, "gt");
      module2.exports = gt;
    });
    var require_lt = __commonJS((exports2, module2) => {
      var compare = require_compare();
      var lt = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) < 0, "lt");
      module2.exports = lt;
    });
    var require_neq = __commonJS((exports2, module2) => {
      var compare = require_compare();
      var neq = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) !== 0, "neq");
      module2.exports = neq;
    });
    var require_gte = __commonJS((exports2, module2) => {
      var compare = require_compare();
      var gte = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) >= 0, "gte");
      module2.exports = gte;
    });
    var require_lte = __commonJS((exports2, module2) => {
      var compare = require_compare();
      var lte = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) <= 0, "lte");
      module2.exports = lte;
    });
    var require_cmp = __commonJS((exports2, module2) => {
      var eq = require_eq();
      var neq = require_neq();
      var gt = require_gt();
      var gte = require_gte();
      var lt = require_lt();
      var lte = require_lte();
      var cmp = /* @__PURE__ */ __name((a, op, b, loose) => {
        switch (op) {
          case "===":
            if (typeof a === "object")
              a = a.version;
            if (typeof b === "object")
              b = b.version;
            return a === b;
          case "!==":
            if (typeof a === "object")
              a = a.version;
            if (typeof b === "object")
              b = b.version;
            return a !== b;
          case "":
          case "=":
          case "==":
            return eq(a, b, loose);
          case "!=":
            return neq(a, b, loose);
          case ">":
            return gt(a, b, loose);
          case ">=":
            return gte(a, b, loose);
          case "<":
            return lt(a, b, loose);
          case "<=":
            return lte(a, b, loose);
          default:
            throw new TypeError(`Invalid operator: ${op}`);
        }
      }, "cmp");
      module2.exports = cmp;
    });
    var require_coerce = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var parse2 = require_parse2();
      var { re, t } = require_re();
      var coerce = /* @__PURE__ */ __name((version, options2) => {
        if (version instanceof SemVer) {
          return version;
        }
        if (typeof version === "number") {
          version = String(version);
        }
        if (typeof version !== "string") {
          return null;
        }
        options2 = options2 || {};
        let match = null;
        if (!options2.rtl) {
          match = version.match(re[t.COERCE]);
        } else {
          let next;
          while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
              match = next;
            }
            re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
          }
          re[t.COERCERTL].lastIndex = -1;
        }
        if (match === null)
          return null;
        return parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options2);
      }, "coerce");
      module2.exports = coerce;
    });
    var require_iterator = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = function(Yallist) {
        Yallist.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
    });
    var require_yallist = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = Yallist;
      Yallist.Node = Node;
      Yallist.create = Yallist;
      function Yallist(list) {
        var self2 = this;
        if (!(self2 instanceof Yallist)) {
          self2 = new Yallist();
        }
        self2.tail = null;
        self2.head = null;
        self2.length = 0;
        if (list && typeof list.forEach === "function") {
          list.forEach(function(item) {
            self2.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i = 0, l = arguments.length; i < l; i++) {
            self2.push(arguments[i]);
          }
        }
        return self2;
      }
      __name(Yallist, "Yallist");
      Yallist.prototype.removeNode = function(node) {
        if (node.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      Yallist.prototype.unshiftNode = function(node) {
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      Yallist.prototype.pushNode = function(node) {
        if (node === this.tail) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
          tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
          this.head = node;
        }
        this.length++;
      };
      Yallist.prototype.push = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          push(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.unshift = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          unshift(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.pop = function() {
        if (!this.tail) {
          return void 0;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.shift = function() {
        if (!this.head) {
          return void 0;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i = 0; walker !== null; i++) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.next;
        }
      };
      Yallist.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.prev;
        }
      };
      Yallist.prototype.get = function(n) {
        for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
          walker = walker.next;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.getReverse = function(n) {
        for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
          walker = walker.prev;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist.prototype.reduce = function(fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = 0; walker !== null; i++) {
          acc = fn(acc, walker.value, i);
          walker = walker.next;
        }
        return acc;
      };
      Yallist.prototype.reduceReverse = function(fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = this.length - 1; walker !== null; i--) {
          acc = fn(acc, walker.value, i);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist.prototype.toArray = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.head; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist.prototype.toArrayReverse = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.tail; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist.prototype.slice = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
          walker = walker.next;
        }
        for (; walker !== null && i < to; i++, walker = walker.next) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.sliceReverse = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
          walker = walker.prev;
        }
        for (; walker !== null && i > from; i--, walker = walker.prev) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
          walker = walker.next;
        }
        var ret = [];
        for (var i = 0; walker && i < deleteCount; i++) {
          ret.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i = 0; i < nodes.length; i++) {
          walker = insert(this, walker, nodes[i]);
        }
        return ret;
      };
      Yallist.prototype.reverse = function() {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next;
          walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self2, node, value) {
        var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
        if (inserted.next === null) {
          self2.tail = inserted;
        }
        if (inserted.prev === null) {
          self2.head = inserted;
        }
        self2.length++;
        return inserted;
      }
      __name(insert, "insert");
      function push(self2, item) {
        self2.tail = new Node(item, self2.tail, null, self2);
        if (!self2.head) {
          self2.head = self2.tail;
        }
        self2.length++;
      }
      __name(push, "push");
      function unshift(self2, item) {
        self2.head = new Node(item, null, self2.head, self2);
        if (!self2.tail) {
          self2.tail = self2.head;
        }
        self2.length++;
      }
      __name(unshift, "unshift");
      function Node(value, prev, next, list) {
        if (!(this instanceof Node)) {
          return new Node(value, prev, next, list);
        }
        this.list = list;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      __name(Node, "Node");
      try {
        require_iterator()(Yallist);
      } catch (er) {
      }
    });
    var require_lru_cache = __commonJS((exports2, module2) => {
      "use strict";
      var Yallist = require_yallist();
      var MAX = Symbol("max");
      var LENGTH = Symbol("length");
      var LENGTH_CALCULATOR = Symbol("lengthCalculator");
      var ALLOW_STALE = Symbol("allowStale");
      var MAX_AGE = Symbol("maxAge");
      var DISPOSE = Symbol("dispose");
      var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
      var LRU_LIST = Symbol("lruList");
      var CACHE = Symbol("cache");
      var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
      var naiveLength = /* @__PURE__ */ __name(() => 1, "naiveLength");
      var LRUCache = /* @__PURE__ */ __name(class {
        constructor(options2) {
          if (typeof options2 === "number")
            options2 = { max: options2 };
          if (!options2)
            options2 = {};
          if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
            throw new TypeError("max must be a non-negative number");
          const max2 = this[MAX] = options2.max || Infinity;
          const lc = options2.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
          this[ALLOW_STALE] = options2.stale || false;
          if (options2.maxAge && typeof options2.maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options2.maxAge || 0;
          this[DISPOSE] = options2.dispose;
          this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
          this.reset();
        }
        set max(mL) {
          if (typeof mL !== "number" || mL < 0)
            throw new TypeError("max must be a non-negative number");
          this[MAX] = mL || Infinity;
          trim(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== "number")
            throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA;
          trim(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        set lengthCalculator(lC) {
          if (typeof lC !== "function")
            lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k) => k.key);
        }
        values() {
          return this[LRU_LIST].toArray().map((k) => k.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter((h) => h);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET])
                this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX]) {
            if (this[DISPOSE])
              this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key))
            return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, true);
        }
        peek(key) {
          return get(this, key, false);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          if (!node)
            return null;
          del(this, node);
          return node.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get(this, key, false));
        }
      }, "LRUCache");
      var get = /* @__PURE__ */ __name((self2, key, doUse) => {
        const node = self2[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self2, hit)) {
            del(self2, node);
            if (!self2[ALLOW_STALE])
              return void 0;
          } else {
            if (doUse) {
              if (self2[UPDATE_AGE_ON_GET])
                node.value.now = Date.now();
              self2[LRU_LIST].unshiftNode(node);
            }
          }
          return hit.value;
        }
      }, "get");
      var isStale = /* @__PURE__ */ __name((self2, hit) => {
        if (!hit || !hit.maxAge && !self2[MAX_AGE])
          return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
      }, "isStale");
      var trim = /* @__PURE__ */ __name((self2) => {
        if (self2[LENGTH] > self2[MAX]) {
          for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
            const prev = walker.prev;
            del(self2, walker);
            walker = prev;
          }
        }
      }, "trim");
      var del = /* @__PURE__ */ __name((self2, node) => {
        if (node) {
          const hit = node.value;
          if (self2[DISPOSE])
            self2[DISPOSE](hit.key, hit.value);
          self2[LENGTH] -= hit.length;
          self2[CACHE].delete(hit.key);
          self2[LRU_LIST].removeNode(node);
        }
      }, "del");
      var Entry = /* @__PURE__ */ __name(class {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      }, "Entry");
      var forEachStep = /* @__PURE__ */ __name((self2, fn, node, thisp) => {
        let hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        }
        if (hit)
          fn.call(thisp, hit.value, hit.key, self2);
      }, "forEachStep");
      module2.exports = LRUCache;
    });
    var require_range = __commonJS((exports2, module2) => {
      var Range = /* @__PURE__ */ __name(class {
        constructor(range, options2) {
          options2 = parseOptions(options2);
          if (range instanceof Range) {
            if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
              return range;
            } else {
              return new Range(range.raw, options2);
            }
          }
          if (range instanceof Comparator) {
            this.raw = range.value;
            this.set = [[range]];
            this.format();
            return this;
          }
          this.options = options2;
          this.loose = !!options2.loose;
          this.includePrerelease = !!options2.includePrerelease;
          this.raw = range;
          this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${range}`);
          }
          if (this.set.length > 1) {
            const first = this.set[0];
            this.set = this.set.filter((c) => !isNullSet(c[0]));
            if (this.set.length === 0)
              this.set = [first];
            else if (this.set.length > 1) {
              for (const c of this.set) {
                if (c.length === 1 && isAny(c[0])) {
                  this.set = [c];
                  break;
                }
              }
            }
          }
          this.format();
        }
        format() {
          this.range = this.set.map((comps) => {
            return comps.join(" ").trim();
          }).join("||").trim();
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range) {
          range = range.trim();
          const memoOpts = Object.keys(this.options).join(",");
          const memoKey = `parseRange:${memoOpts}:${range}`;
          const cached = cache.get(memoKey);
          if (cached)
            return cached;
          const loose = this.options.loose;
          const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
          debug32("hyphen replace", range);
          range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
          debug32("comparator trim", range, re[t.COMPARATORTRIM]);
          range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
          range = range.replace(re[t.CARETTRIM], caretTrimReplace);
          range = range.split(/\s+/).join(" ");
          const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
          const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
          const l = rangeList.length;
          const rangeMap = new Map();
          for (const comp of rangeList) {
            if (isNullSet(comp))
              return [comp];
            rangeMap.set(comp.value, comp);
          }
          if (rangeMap.size > 1 && rangeMap.has(""))
            rangeMap.delete("");
          const result = [...rangeMap.values()];
          cache.set(memoKey, result);
          return result;
        }
        intersects(range, options2) {
          if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some((thisComparators) => {
            return isSatisfiable(thisComparators, options2) && range.set.some((rangeComparators) => {
              return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
                return rangeComparators.every((rangeComparator) => {
                  return thisComparator.intersects(rangeComparator, options2);
                });
              });
            });
          });
        }
        test(version) {
          if (!version) {
            return false;
          }
          if (typeof version === "string") {
            try {
              version = new SemVer(version, this.options);
            } catch (er) {
              return false;
            }
          }
          for (let i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version, this.options)) {
              return true;
            }
          }
          return false;
        }
      }, "Range");
      module2.exports = Range;
      var LRU = require_lru_cache();
      var cache = new LRU({ max: 1e3 });
      var parseOptions = require_parse_options();
      var Comparator = require_comparator();
      var debug32 = require_debug();
      var SemVer = require_semver();
      var {
        re,
        t,
        comparatorTrimReplace,
        tildeTrimReplace,
        caretTrimReplace
      } = require_re();
      var isNullSet = /* @__PURE__ */ __name((c) => c.value === "<0.0.0-0", "isNullSet");
      var isAny = /* @__PURE__ */ __name((c) => c.value === "", "isAny");
      var isSatisfiable = /* @__PURE__ */ __name((comparators, options2) => {
        let result = true;
        const remainingComparators = comparators.slice();
        let testComparator = remainingComparators.pop();
        while (result && remainingComparators.length) {
          result = remainingComparators.every((otherComparator) => {
            return testComparator.intersects(otherComparator, options2);
          });
          testComparator = remainingComparators.pop();
        }
        return result;
      }, "isSatisfiable");
      var parseComparator = /* @__PURE__ */ __name((comp, options2) => {
        debug32("comp", comp, options2);
        comp = replaceCarets(comp, options2);
        debug32("caret", comp);
        comp = replaceTildes(comp, options2);
        debug32("tildes", comp);
        comp = replaceXRanges(comp, options2);
        debug32("xrange", comp);
        comp = replaceStars(comp, options2);
        debug32("stars", comp);
        return comp;
      }, "parseComparator");
      var isX = /* @__PURE__ */ __name((id) => !id || id.toLowerCase() === "x" || id === "*", "isX");
      var replaceTildes = /* @__PURE__ */ __name((comp, options2) => comp.trim().split(/\s+/).map((comp2) => {
        return replaceTilde(comp2, options2);
      }).join(" "), "replaceTildes");
      var replaceTilde = /* @__PURE__ */ __name((comp, options2) => {
        const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
        return comp.replace(r, (_, M, m, p, pr) => {
          debug32("tilde", comp, _, M, m, p, pr);
          let ret;
          if (isX(M)) {
            ret = "";
          } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
          } else if (pr) {
            debug32("replaceTilde pr", pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
          }
          debug32("tilde return", ret);
          return ret;
        });
      }, "replaceTilde");
      var replaceCarets = /* @__PURE__ */ __name((comp, options2) => comp.trim().split(/\s+/).map((comp2) => {
        return replaceCaret(comp2, options2);
      }).join(" "), "replaceCarets");
      var replaceCaret = /* @__PURE__ */ __name((comp, options2) => {
        debug32("caret", comp, options2);
        const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
        const z = options2.includePrerelease ? "-0" : "";
        return comp.replace(r, (_, M, m, p, pr) => {
          debug32("caret", comp, _, M, m, p, pr);
          let ret;
          if (isX(M)) {
            ret = "";
          } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            if (M === "0") {
              ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
              ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
          } else if (pr) {
            debug32("replaceCaret pr", pr);
            if (M === "0") {
              if (m === "0") {
                ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
          } else {
            debug32("no pr");
            if (M === "0") {
              if (m === "0") {
                ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
          }
          debug32("caret return", ret);
          return ret;
        });
      }, "replaceCaret");
      var replaceXRanges = /* @__PURE__ */ __name((comp, options2) => {
        debug32("replaceXRanges", comp, options2);
        return comp.split(/\s+/).map((comp2) => {
          return replaceXRange(comp2, options2);
        }).join(" ");
      }, "replaceXRanges");
      var replaceXRange = /* @__PURE__ */ __name((comp, options2) => {
        comp = comp.trim();
        const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
        return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
          debug32("xRange", comp, ret, gtlt, M, m, p, pr);
          const xM = isX(M);
          const xm = xM || isX(m);
          const xp = xm || isX(p);
          const anyX = xp;
          if (gtlt === "=" && anyX) {
            gtlt = "";
          }
          pr = options2.includePrerelease ? "-0" : "";
          if (xM) {
            if (gtlt === ">" || gtlt === "<") {
              ret = "<0.0.0-0";
            } else {
              ret = "*";
            }
          } else if (gtlt && anyX) {
            if (xm) {
              m = 0;
            }
            p = 0;
            if (gtlt === ">") {
              gtlt = ">=";
              if (xm) {
                M = +M + 1;
                m = 0;
                p = 0;
              } else {
                m = +m + 1;
                p = 0;
              }
            } else if (gtlt === "<=") {
              gtlt = "<";
              if (xm) {
                M = +M + 1;
              } else {
                m = +m + 1;
              }
            }
            if (gtlt === "<")
              pr = "-0";
            ret = `${gtlt + M}.${m}.${p}${pr}`;
          } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
          } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
          }
          debug32("xRange return", ret);
          return ret;
        });
      }, "replaceXRange");
      var replaceStars = /* @__PURE__ */ __name((comp, options2) => {
        debug32("replaceStars", comp, options2);
        return comp.trim().replace(re[t.STAR], "");
      }, "replaceStars");
      var replaceGTE0 = /* @__PURE__ */ __name((comp, options2) => {
        debug32("replaceGTE0", comp, options2);
        return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
      }, "replaceGTE0");
      var hyphenReplace = /* @__PURE__ */ __name((incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
        if (isX(fM)) {
          from = "";
        } else if (isX(fm)) {
          from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        } else if (isX(fp)) {
          from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        } else if (fpr) {
          from = `>=${from}`;
        } else {
          from = `>=${from}${incPr ? "-0" : ""}`;
        }
        if (isX(tM)) {
          to = "";
        } else if (isX(tm)) {
          to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
          to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
          to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
          to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
          to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
      }, "hyphenReplace");
      var testSet = /* @__PURE__ */ __name((set, version, options2) => {
        for (let i = 0; i < set.length; i++) {
          if (!set[i].test(version)) {
            return false;
          }
        }
        if (version.prerelease.length && !options2.includePrerelease) {
          for (let i = 0; i < set.length; i++) {
            debug32(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
              continue;
            }
            if (set[i].semver.prerelease.length > 0) {
              const allowed = set[i].semver;
              if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                return true;
              }
            }
          }
          return false;
        }
        return true;
      }, "testSet");
    });
    var require_comparator = __commonJS((exports2, module2) => {
      var ANY = Symbol("SemVer ANY");
      var Comparator = /* @__PURE__ */ __name(class {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options2) {
          options2 = parseOptions(options2);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options2.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          debug32("comparator", comp, options2);
          this.options = options2;
          this.loose = !!options2.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug32("comp", this);
        }
        parse(comp) {
          const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
          const m = comp.match(r);
          if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m[1] !== void 0 ? m[1] : "";
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer(m[2], this.options.loose);
          }
        }
        toString() {
          return this.value;
        }
        test(version) {
          debug32("Comparator.test", version, this.options.loose);
          if (this.semver === ANY || version === ANY) {
            return true;
          }
          if (typeof version === "string") {
            try {
              version = new SemVer(version, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp(version, this.operator, this.semver, this.options);
        }
        intersects(comp, options2) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (!options2 || typeof options2 !== "object") {
            options2 = {
              loose: !!options2,
              includePrerelease: false
            };
          }
          if (this.operator === "") {
            if (this.value === "") {
              return true;
            }
            return new Range(comp.value, options2).test(this.value);
          } else if (comp.operator === "") {
            if (comp.value === "") {
              return true;
            }
            return new Range(this.value, options2).test(comp.semver);
          }
          const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
          const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
          const sameSemVer = this.semver.version === comp.semver.version;
          const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
          const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
          const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        }
      }, "Comparator");
      module2.exports = Comparator;
      var parseOptions = require_parse_options();
      var { re, t } = require_re();
      var cmp = require_cmp();
      var debug32 = require_debug();
      var SemVer = require_semver();
      var Range = require_range();
    });
    var require_satisfies = __commonJS((exports2, module2) => {
      var Range = require_range();
      var satisfies = /* @__PURE__ */ __name((version, range, options2) => {
        try {
          range = new Range(range, options2);
        } catch (er) {
          return false;
        }
        return range.test(version);
      }, "satisfies");
      module2.exports = satisfies;
    });
    var require_to_comparators = __commonJS((exports2, module2) => {
      var Range = require_range();
      var toComparators = /* @__PURE__ */ __name((range, options2) => new Range(range, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" ")), "toComparators");
      module2.exports = toComparators;
    });
    var require_max_satisfying = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var Range = require_range();
      var maxSatisfying = /* @__PURE__ */ __name((versions, range, options2) => {
        let max2 = null;
        let maxSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options2);
        } catch (er) {
          return null;
        }
        versions.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!max2 || maxSV.compare(v) === -1) {
              max2 = v;
              maxSV = new SemVer(max2, options2);
            }
          }
        });
        return max2;
      }, "maxSatisfying");
      module2.exports = maxSatisfying;
    });
    var require_min_satisfying = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var Range = require_range();
      var minSatisfying = /* @__PURE__ */ __name((versions, range, options2) => {
        let min2 = null;
        let minSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options2);
        } catch (er) {
          return null;
        }
        versions.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!min2 || minSV.compare(v) === 1) {
              min2 = v;
              minSV = new SemVer(min2, options2);
            }
          }
        });
        return min2;
      }, "minSatisfying");
      module2.exports = minSatisfying;
    });
    var require_min_version = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var Range = require_range();
      var gt = require_gt();
      var minVersion = /* @__PURE__ */ __name((range, loose) => {
        range = new Range(range, loose);
        let minver = new SemVer("0.0.0");
        if (range.test(minver)) {
          return minver;
        }
        minver = new SemVer("0.0.0-0");
        if (range.test(minver)) {
          return minver;
        }
        minver = null;
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let setMin = null;
          comparators.forEach((comparator) => {
            const compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case ">":
                if (compver.prerelease.length === 0) {
                  compver.patch++;
                } else {
                  compver.prerelease.push(0);
                }
                compver.raw = compver.format();
              case "":
              case ">=":
                if (!setMin || gt(compver, setMin)) {
                  setMin = compver;
                }
                break;
              case "<":
              case "<=":
                break;
              default:
                throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
          });
          if (setMin && (!minver || gt(minver, setMin)))
            minver = setMin;
        }
        if (minver && range.test(minver)) {
          return minver;
        }
        return null;
      }, "minVersion");
      module2.exports = minVersion;
    });
    var require_valid2 = __commonJS((exports2, module2) => {
      var Range = require_range();
      var validRange = /* @__PURE__ */ __name((range, options2) => {
        try {
          return new Range(range, options2).range || "*";
        } catch (er) {
          return null;
        }
      }, "validRange");
      module2.exports = validRange;
    });
    var require_outside = __commonJS((exports2, module2) => {
      var SemVer = require_semver();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var Range = require_range();
      var satisfies = require_satisfies();
      var gt = require_gt();
      var lt = require_lt();
      var lte = require_lte();
      var gte = require_gte();
      var outside = /* @__PURE__ */ __name((version, range, hilo, options2) => {
        version = new SemVer(version, options2);
        range = new Range(range, options2);
        let gtfn, ltefn, ltfn, comp, ecomp;
        switch (hilo) {
          case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
          case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version, range, options2)) {
          return false;
        }
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let high = null;
          let low = null;
          comparators.forEach((comparator) => {
            if (comparator.semver === ANY) {
              comparator = new Comparator(">=0.0.0");
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options2)) {
              high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options2)) {
              low = comparator;
            }
          });
          if (high.operator === comp || high.operator === ecomp) {
            return false;
          }
          if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
          } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
          }
        }
        return true;
      }, "outside");
      module2.exports = outside;
    });
    var require_gtr = __commonJS((exports2, module2) => {
      var outside = require_outside();
      var gtr = /* @__PURE__ */ __name((version, range, options2) => outside(version, range, ">", options2), "gtr");
      module2.exports = gtr;
    });
    var require_ltr = __commonJS((exports2, module2) => {
      var outside = require_outside();
      var ltr = /* @__PURE__ */ __name((version, range, options2) => outside(version, range, "<", options2), "ltr");
      module2.exports = ltr;
    });
    var require_intersects = __commonJS((exports2, module2) => {
      var Range = require_range();
      var intersects = /* @__PURE__ */ __name((r1, r2, options2) => {
        r1 = new Range(r1, options2);
        r2 = new Range(r2, options2);
        return r1.intersects(r2);
      }, "intersects");
      module2.exports = intersects;
    });
    var require_simplify = __commonJS((exports2, module2) => {
      var satisfies = require_satisfies();
      var compare = require_compare();
      module2.exports = (versions, range, options2) => {
        const set = [];
        let min2 = null;
        let prev = null;
        const v = versions.sort((a, b) => compare(a, b, options2));
        for (const version of v) {
          const included = satisfies(version, range, options2);
          if (included) {
            prev = version;
            if (!min2)
              min2 = version;
          } else {
            if (prev) {
              set.push([min2, prev]);
            }
            prev = null;
            min2 = null;
          }
        }
        if (min2)
          set.push([min2, null]);
        const ranges = [];
        for (const [min22, max2] of set) {
          if (min22 === max2)
            ranges.push(min22);
          else if (!max2 && min22 === v[0])
            ranges.push("*");
          else if (!max2)
            ranges.push(`>=${min22}`);
          else if (min22 === v[0])
            ranges.push(`<=${max2}`);
          else
            ranges.push(`${min22} - ${max2}`);
        }
        const simplified = ranges.join(" || ");
        const original = typeof range.raw === "string" ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
      };
    });
    var require_subset = __commonJS((exports2, module2) => {
      var Range = require_range();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var satisfies = require_satisfies();
      var compare = require_compare();
      var subset = /* @__PURE__ */ __name((sub2, dom, options2 = {}) => {
        if (sub2 === dom)
          return true;
        sub2 = new Range(sub2, options2);
        dom = new Range(dom, options2);
        let sawNonNull = false;
        OUTER:
          for (const simpleSub of sub2.set) {
            for (const simpleDom of dom.set) {
              const isSub = simpleSubset(simpleSub, simpleDom, options2);
              sawNonNull = sawNonNull || isSub !== null;
              if (isSub)
                continue OUTER;
            }
            if (sawNonNull)
              return false;
          }
        return true;
      }, "subset");
      var simpleSubset = /* @__PURE__ */ __name((sub2, dom, options2) => {
        if (sub2 === dom)
          return true;
        if (sub2.length === 1 && sub2[0].semver === ANY) {
          if (dom.length === 1 && dom[0].semver === ANY)
            return true;
          else if (options2.includePrerelease)
            sub2 = [new Comparator(">=0.0.0-0")];
          else
            sub2 = [new Comparator(">=0.0.0")];
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
          if (options2.includePrerelease)
            return true;
          else
            dom = [new Comparator(">=0.0.0")];
        }
        const eqSet = new Set();
        let gt, lt;
        for (const c of sub2) {
          if (c.operator === ">" || c.operator === ">=")
            gt = higherGT(gt, c, options2);
          else if (c.operator === "<" || c.operator === "<=")
            lt = lowerLT(lt, c, options2);
          else
            eqSet.add(c.semver);
        }
        if (eqSet.size > 1)
          return null;
        let gtltComp;
        if (gt && lt) {
          gtltComp = compare(gt.semver, lt.semver, options2);
          if (gtltComp > 0)
            return null;
          else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
            return null;
        }
        for (const eq of eqSet) {
          if (gt && !satisfies(eq, String(gt), options2))
            return null;
          if (lt && !satisfies(eq, String(lt), options2))
            return null;
          for (const c of dom) {
            if (!satisfies(eq, String(c), options2))
              return false;
          }
          return true;
        }
        let higher, lower;
        let hasDomLT, hasDomGT;
        let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
          needDomLTPre = false;
        }
        for (const c of dom) {
          hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
          hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
          if (gt) {
            if (needDomGTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                needDomGTPre = false;
              }
            }
            if (c.operator === ">" || c.operator === ">=") {
              higher = higherGT(gt, c, options2);
              if (higher === c && higher !== gt)
                return false;
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options2))
              return false;
          }
          if (lt) {
            if (needDomLTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                needDomLTPre = false;
              }
            }
            if (c.operator === "<" || c.operator === "<=") {
              lower = lowerLT(lt, c, options2);
              if (lower === c && lower !== lt)
                return false;
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options2))
              return false;
          }
          if (!c.operator && (lt || gt) && gtltComp !== 0)
            return false;
        }
        if (gt && hasDomLT && !lt && gtltComp !== 0)
          return false;
        if (lt && hasDomGT && !gt && gtltComp !== 0)
          return false;
        if (needDomGTPre || needDomLTPre)
          return false;
        return true;
      }, "simpleSubset");
      var higherGT = /* @__PURE__ */ __name((a, b, options2) => {
        if (!a)
          return b;
        const comp = compare(a.semver, b.semver, options2);
        return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
      }, "higherGT");
      var lowerLT = /* @__PURE__ */ __name((a, b, options2) => {
        if (!a)
          return b;
        const comp = compare(a.semver, b.semver, options2);
        return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
      }, "lowerLT");
      module2.exports = subset;
    });
    var require_semver2 = __commonJS((exports2, module2) => {
      var internalRe = require_re();
      module2.exports = {
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
        SemVer: require_semver(),
        compareIdentifiers: require_identifiers().compareIdentifiers,
        rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
        parse: require_parse2(),
        valid: require_valid(),
        clean: require_clean(),
        inc: require_inc(),
        diff: require_diff(),
        major: require_major(),
        minor: require_minor(),
        patch: require_patch(),
        prerelease: require_prerelease(),
        compare: require_compare(),
        rcompare: require_rcompare(),
        compareLoose: require_compare_loose(),
        compareBuild: require_compare_build(),
        sort: require_sort(),
        rsort: require_rsort(),
        gt: require_gt(),
        lt: require_lt(),
        eq: require_eq(),
        neq: require_neq(),
        gte: require_gte(),
        lte: require_lte(),
        cmp: require_cmp(),
        coerce: require_coerce(),
        Comparator: require_comparator(),
        Range: require_range(),
        satisfies: require_satisfies(),
        toComparators: require_to_comparators(),
        maxSatisfying: require_max_satisfying(),
        minSatisfying: require_min_satisfying(),
        minVersion: require_min_version(),
        validRange: require_valid2(),
        outside: require_outside(),
        gtr: require_gtr(),
        ltr: require_ltr(),
        intersects: require_intersects(),
        simplifyRange: require_simplify(),
        subset: require_subset()
      };
    });
    var require_make_dir = __commonJS((exports2, module2) => {
      "use strict";
      var fs7 = __require("fs");
      var path22 = __require("path");
      var { promisify: promisify3 } = __require("util");
      var semver = require_semver2();
      var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
      var checkPath = /* @__PURE__ */ __name((pth) => {
        if (process.platform === "win32") {
          const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path22.parse(pth).root, ""));
          if (pathHasInvalidWinCharacters) {
            const error2 = new Error(`Path contains invalid characters: ${pth}`);
            error2.code = "EINVAL";
            throw error2;
          }
        }
      }, "checkPath");
      var processOptions = /* @__PURE__ */ __name((options2) => {
        const defaults = {
          mode: 511,
          fs: fs7
        };
        return {
          ...defaults,
          ...options2
        };
      }, "processOptions");
      var permissionError = /* @__PURE__ */ __name((pth) => {
        const error2 = new Error(`operation not permitted, mkdir '${pth}'`);
        error2.code = "EPERM";
        error2.errno = -4048;
        error2.path = pth;
        error2.syscall = "mkdir";
        return error2;
      }, "permissionError");
      var makeDir = /* @__PURE__ */ __name(async (input, options2) => {
        checkPath(input);
        options2 = processOptions(options2);
        const mkdir = promisify3(options2.fs.mkdir);
        const stat = promisify3(options2.fs.stat);
        if (useNativeRecursiveOption && options2.fs.mkdir === fs7.mkdir) {
          const pth = path22.resolve(input);
          await mkdir(pth, {
            mode: options2.mode,
            recursive: true
          });
          return pth;
        }
        const make = /* @__PURE__ */ __name(async (pth) => {
          try {
            await mkdir(pth, options2.mode);
            return pth;
          } catch (error2) {
            if (error2.code === "EPERM") {
              throw error2;
            }
            if (error2.code === "ENOENT") {
              if (path22.dirname(pth) === pth) {
                throw permissionError(pth);
              }
              if (error2.message.includes("null bytes")) {
                throw error2;
              }
              await make(path22.dirname(pth));
              return make(pth);
            }
            try {
              const stats = await stat(pth);
              if (!stats.isDirectory()) {
                throw new Error("The path is not a directory");
              }
            } catch (_) {
              throw error2;
            }
            return pth;
          }
        }, "make");
        return make(path22.resolve(input));
      }, "makeDir");
      module2.exports = makeDir;
      module2.exports.sync = (input, options2) => {
        checkPath(input);
        options2 = processOptions(options2);
        if (useNativeRecursiveOption && options2.fs.mkdirSync === fs7.mkdirSync) {
          const pth = path22.resolve(input);
          fs7.mkdirSync(pth, {
            mode: options2.mode,
            recursive: true
          });
          return pth;
        }
        const make = /* @__PURE__ */ __name((pth) => {
          try {
            options2.fs.mkdirSync(pth, options2.mode);
          } catch (error2) {
            if (error2.code === "EPERM") {
              throw error2;
            }
            if (error2.code === "ENOENT") {
              if (path22.dirname(pth) === pth) {
                throw permissionError(pth);
              }
              if (error2.message.includes("null bytes")) {
                throw error2;
              }
              make(path22.dirname(pth));
              return make(pth);
            }
            try {
              if (!options2.fs.statSync(pth).isDirectory()) {
                throw new Error("The path is not a directory");
              }
            } catch (_) {
              throw error2;
            }
          }
          return pth;
        }, "make");
        return make(path22.resolve(input));
      };
    });
    var require_indent_string = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = (string, count = 1, options2) => {
        options2 = {
          indent: " ",
          includeEmptyLines: false,
          ...options2
        };
        if (typeof string !== "string") {
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
        }
        if (typeof count !== "number") {
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
        }
        if (typeof options2.indent !== "string") {
          throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options2.indent}\``);
        }
        if (count === 0) {
          return string;
        }
        const regex = options2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return string.replace(regex, options2.indent.repeat(count));
      };
    });
    var require_clean_stack = __commonJS((exports2, module2) => {
      "use strict";
      var os2 = __require("os");
      var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
      var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
      var homeDir = typeof os2.homedir === "undefined" ? "" : os2.homedir();
      module2.exports = (stack, options2) => {
        options2 = Object.assign({ pretty: false }, options2);
        return stack.replace(/\\/g, "/").split("\n").filter((line) => {
          const pathMatches = line.match(extractPathRegex);
          if (pathMatches === null || !pathMatches[1]) {
            return true;
          }
          const match = pathMatches[1];
          if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
            return false;
          }
          return !pathRegex.test(match);
        }).filter((line) => line.trim() !== "").map((line) => {
          if (options2.pretty) {
            return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
          }
          return line;
        }).join("\n");
      };
    });
    var require_aggregate_error = __commonJS((exports2, module2) => {
      "use strict";
      var indentString = require_indent_string();
      var cleanStack = require_clean_stack();
      var cleanInternalStack = /* @__PURE__ */ __name((stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, ""), "cleanInternalStack");
      var AggregateError = /* @__PURE__ */ __name(class extends Error {
        constructor(errors2) {
          if (!Array.isArray(errors2)) {
            throw new TypeError(`Expected input to be an Array, got ${typeof errors2}`);
          }
          errors2 = [...errors2].map((error2) => {
            if (error2 instanceof Error) {
              return error2;
            }
            if (error2 !== null && typeof error2 === "object") {
              return Object.assign(new Error(error2.message), error2);
            }
            return new Error(error2);
          });
          let message = errors2.map((error2) => {
            return typeof error2.stack === "string" ? cleanInternalStack(cleanStack(error2.stack)) : String(error2);
          }).join("\n");
          message = "\n" + indentString(message, 4);
          super(message);
          this.name = "AggregateError";
          Object.defineProperty(this, "_errors", { value: errors2 });
        }
        *[Symbol.iterator]() {
          for (const error2 of this._errors) {
            yield error2;
          }
        }
      }, "AggregateError");
      module2.exports = AggregateError;
    });
    var require_p_map = __commonJS((exports2, module2) => {
      "use strict";
      var AggregateError = require_aggregate_error();
      module2.exports = async (iterable, mapper, {
        concurrency = Infinity,
        stopOnError = true
      } = {}) => {
        return new Promise((resolve2, reject2) => {
          if (typeof mapper !== "function") {
            throw new TypeError("Mapper function is required");
          }
          if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
            throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
          }
          const result = [];
          const errors2 = [];
          const iterator = iterable[Symbol.iterator]();
          let isRejected = false;
          let isIterableDone = false;
          let resolvingCount = 0;
          let currentIndex = 0;
          const next = /* @__PURE__ */ __name(() => {
            if (isRejected) {
              return;
            }
            const nextItem = iterator.next();
            const index = currentIndex;
            currentIndex++;
            if (nextItem.done) {
              isIterableDone = true;
              if (resolvingCount === 0) {
                if (!stopOnError && errors2.length !== 0) {
                  reject2(new AggregateError(errors2));
                } else {
                  resolve2(result);
                }
              }
              return;
            }
            resolvingCount++;
            (async () => {
              try {
                const element = await nextItem.value;
                result[index] = await mapper(element, index);
                resolvingCount--;
                next();
              } catch (error2) {
                if (stopOnError) {
                  isRejected = true;
                  reject2(error2);
                } else {
                  errors2.push(error2);
                  resolvingCount--;
                  next();
                }
              }
            })();
          }, "next");
          for (let i = 0; i < concurrency; i++) {
            next();
            if (isIterableDone) {
              break;
            }
          }
        });
      };
    });
    var require_p_filter = __commonJS((exports2, module2) => {
      "use strict";
      var pMap = require_p_map();
      var pFilter = /* @__PURE__ */ __name(async (iterable, filterer, options2) => {
        const values = await pMap(iterable, (element, index) => Promise.all([filterer(element, index), element]), options2);
        return values.filter((value) => Boolean(value[0])).map((value) => value[1]);
      }, "pFilter");
      module2.exports = pFilter;
      module2.exports.default = pFilter;
    });
    var require_temp_dir = __commonJS((exports2, module2) => {
      "use strict";
      var fs7 = __require("fs");
      var os2 = __require("os");
      var tempDirectorySymbol = Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
      if (!global[tempDirectorySymbol]) {
        Object.defineProperty(global, tempDirectorySymbol, {
          value: fs7.realpathSync(os2.tmpdir())
        });
      }
      module2.exports = global[tempDirectorySymbol];
    });
    var require_chmod = __commonJS((exports2) => {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var fs7 = __importStar(__require("fs"));
      function default_1(file2) {
        const s = fs7.statSync(file2);
        const newMode = s.mode | 64 | 8 | 1;
        if (s.mode === newMode)
          return;
        const base8 = newMode.toString(8).slice(-3);
        fs7.chmodSync(file2, base8);
      }
      __name(default_1, "default_1");
      exports2.default = default_1;
    });
    var require_commondir = __commonJS((exports2, module2) => {
      var path22 = __require("path");
      module2.exports = function(basedir, relfiles) {
        if (relfiles) {
          var files = relfiles.map(function(r) {
            return path22.resolve(basedir, r);
          });
        } else {
          var files = basedir;
        }
        var res = files.slice(1).reduce(function(ps, file2) {
          if (!file2.match(/^([A-Za-z]:)?\/|\\/)) {
            throw new Error("relative path without a basedir");
          }
          var xs = file2.split(/\/+|\\+/);
          for (var i = 0; ps[i] === xs[i] && i < Math.min(ps.length, xs.length); i++)
            ;
          return ps.slice(0, i);
        }, files[0].split(/\/+|\\+/));
        return res.length > 1 ? res.join("/") : "/";
      };
    });
    var require_p_try = __commonJS((exports2, module2) => {
      "use strict";
      var pTry = /* @__PURE__ */ __name((fn, ...arguments_) => new Promise((resolve2) => {
        resolve2(fn(...arguments_));
      }), "pTry");
      module2.exports = pTry;
      module2.exports.default = pTry;
    });
    var require_p_limit = __commonJS((exports2, module2) => {
      "use strict";
      var pTry = require_p_try();
      var pLimit = /* @__PURE__ */ __name((concurrency) => {
        if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
          return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
        }
        const queue = [];
        let activeCount = 0;
        const next = /* @__PURE__ */ __name(() => {
          activeCount--;
          if (queue.length > 0) {
            queue.shift()();
          }
        }, "next");
        const run = /* @__PURE__ */ __name((fn, resolve2, ...args) => {
          activeCount++;
          const result = pTry(fn, ...args);
          resolve2(result);
          result.then(next, next);
        }, "run");
        const enqueue = /* @__PURE__ */ __name((fn, resolve2, ...args) => {
          if (activeCount < concurrency) {
            run(fn, resolve2, ...args);
          } else {
            queue.push(run.bind(null, fn, resolve2, ...args));
          }
        }, "enqueue");
        const generator = /* @__PURE__ */ __name((fn, ...args) => new Promise((resolve2) => enqueue(fn, resolve2, ...args)), "generator");
        Object.defineProperties(generator, {
          activeCount: {
            get: () => activeCount
          },
          pendingCount: {
            get: () => queue.length
          },
          clearQueue: {
            value: () => {
              queue.length = 0;
            }
          }
        });
        return generator;
      }, "pLimit");
      module2.exports = pLimit;
      module2.exports.default = pLimit;
    });
    var require_p_locate = __commonJS((exports2, module2) => {
      "use strict";
      var pLimit = require_p_limit();
      var EndError = /* @__PURE__ */ __name(class extends Error {
        constructor(value) {
          super();
          this.value = value;
        }
      }, "EndError");
      var testElement = /* @__PURE__ */ __name(async (element, tester) => tester(await element), "testElement");
      var finder = /* @__PURE__ */ __name(async (element) => {
        const values = await Promise.all(element);
        if (values[1] === true) {
          throw new EndError(values[0]);
        }
        return false;
      }, "finder");
      var pLocate = /* @__PURE__ */ __name(async (iterable, tester, options2) => {
        options2 = {
          concurrency: Infinity,
          preserveOrder: true,
          ...options2
        };
        const limit = pLimit(options2.concurrency);
        const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
        const checkLimit = pLimit(options2.preserveOrder ? 1 : Infinity);
        try {
          await Promise.all(items.map((element) => checkLimit(finder, element)));
        } catch (error2) {
          if (error2 instanceof EndError) {
            return error2.value;
          }
          throw error2;
        }
      }, "pLocate");
      module2.exports = pLocate;
      module2.exports.default = pLocate;
    });
    var require_locate_path = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var fs7 = __require("fs");
      var { promisify: promisify3 } = __require("util");
      var pLocate = require_p_locate();
      var fsStat = promisify3(fs7.stat);
      var fsLStat = promisify3(fs7.lstat);
      var typeMappings = {
        directory: "isDirectory",
        file: "isFile"
      };
      function checkType({ type }) {
        if (type in typeMappings) {
          return;
        }
        throw new Error(`Invalid type specified: ${type}`);
      }
      __name(checkType, "checkType");
      var matchType = /* @__PURE__ */ __name((type, stat) => type === void 0 || stat[typeMappings[type]](), "matchType");
      module2.exports = async (paths, options2) => {
        options2 = {
          cwd: process.cwd(),
          type: "file",
          allowSymlinks: true,
          ...options2
        };
        checkType(options2);
        const statFn = options2.allowSymlinks ? fsStat : fsLStat;
        return pLocate(paths, async (path_) => {
          try {
            const stat = await statFn(path22.resolve(options2.cwd, path_));
            return matchType(options2.type, stat);
          } catch (_) {
            return false;
          }
        }, options2);
      };
      module2.exports.sync = (paths, options2) => {
        options2 = {
          cwd: process.cwd(),
          allowSymlinks: true,
          type: "file",
          ...options2
        };
        checkType(options2);
        const statFn = options2.allowSymlinks ? fs7.statSync : fs7.lstatSync;
        for (const path_ of paths) {
          try {
            const stat = statFn(path22.resolve(options2.cwd, path_));
            if (matchType(options2.type, stat)) {
              return path_;
            }
          } catch (_) {
          }
        }
      };
    });
    var require_path_exists = __commonJS((exports2, module2) => {
      "use strict";
      var fs7 = __require("fs");
      var { promisify: promisify3 } = __require("util");
      var pAccess = promisify3(fs7.access);
      module2.exports = async (path22) => {
        try {
          await pAccess(path22);
          return true;
        } catch (_) {
          return false;
        }
      };
      module2.exports.sync = (path22) => {
        try {
          fs7.accessSync(path22);
          return true;
        } catch (_) {
          return false;
        }
      };
    });
    var require_find_up = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var locatePath = require_locate_path();
      var pathExists = require_path_exists();
      var stop = Symbol("findUp.stop");
      module2.exports = async (name, options2 = {}) => {
        let directory = path22.resolve(options2.cwd || "");
        const { root } = path22.parse(directory);
        const paths = [].concat(name);
        const runMatcher = /* @__PURE__ */ __name(async (locateOptions) => {
          if (typeof name !== "function") {
            return locatePath(paths, locateOptions);
          }
          const foundPath = await name(locateOptions.cwd);
          if (typeof foundPath === "string") {
            return locatePath([foundPath], locateOptions);
          }
          return foundPath;
        }, "runMatcher");
        while (true) {
          const foundPath = await runMatcher({ ...options2, cwd: directory });
          if (foundPath === stop) {
            return;
          }
          if (foundPath) {
            return path22.resolve(directory, foundPath);
          }
          if (directory === root) {
            return;
          }
          directory = path22.dirname(directory);
        }
      };
      module2.exports.sync = (name, options2 = {}) => {
        let directory = path22.resolve(options2.cwd || "");
        const { root } = path22.parse(directory);
        const paths = [].concat(name);
        const runMatcher = /* @__PURE__ */ __name((locateOptions) => {
          if (typeof name !== "function") {
            return locatePath.sync(paths, locateOptions);
          }
          const foundPath = name(locateOptions.cwd);
          if (typeof foundPath === "string") {
            return locatePath.sync([foundPath], locateOptions);
          }
          return foundPath;
        }, "runMatcher");
        while (true) {
          const foundPath = runMatcher({ ...options2, cwd: directory });
          if (foundPath === stop) {
            return;
          }
          if (foundPath) {
            return path22.resolve(directory, foundPath);
          }
          if (directory === root) {
            return;
          }
          directory = path22.dirname(directory);
        }
      };
      module2.exports.exists = pathExists;
      module2.exports.sync.exists = pathExists.sync;
      module2.exports.stop = stop;
    });
    var require_pkg_dir = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var findUp = require_find_up();
      var pkgDir = /* @__PURE__ */ __name(async (cwd) => {
        const filePath = await findUp("package.json", { cwd });
        return filePath && path22.dirname(filePath);
      }, "pkgDir");
      module2.exports = pkgDir;
      module2.exports.default = pkgDir;
      module2.exports.sync = (cwd) => {
        const filePath = findUp.sync("package.json", { cwd });
        return filePath && path22.dirname(filePath);
      };
    });
    var require_find_cache_dir = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var fs7 = __require("fs");
      var commonDir = require_commondir();
      var pkgDir = require_pkg_dir();
      var makeDir = require_make_dir();
      var { env, cwd } = process;
      var isWritable = /* @__PURE__ */ __name((path32) => {
        try {
          fs7.accessSync(path32, fs7.constants.W_OK);
          return true;
        } catch (_) {
          return false;
        }
      }, "isWritable");
      function useDirectory(directory, options2) {
        if (options2.create) {
          makeDir.sync(directory);
        }
        if (options2.thunk) {
          return (...arguments_) => path22.join(directory, ...arguments_);
        }
        return directory;
      }
      __name(useDirectory, "useDirectory");
      function getNodeModuleDirectory(directory) {
        const nodeModules = path22.join(directory, "node_modules");
        if (!isWritable(nodeModules) && (fs7.existsSync(nodeModules) || !isWritable(path22.join(directory)))) {
          return;
        }
        return nodeModules;
      }
      __name(getNodeModuleDirectory, "getNodeModuleDirectory");
      module2.exports = (options2 = {}) => {
        if (env.CACHE_DIR && !["true", "false", "1", "0"].includes(env.CACHE_DIR)) {
          return useDirectory(path22.join(env.CACHE_DIR, "find-cache-dir"), options2);
        }
        let { cwd: directory = cwd() } = options2;
        if (options2.files) {
          directory = commonDir(directory, options2.files);
        }
        directory = pkgDir.sync(directory);
        if (!directory) {
          return;
        }
        const nodeModules = getNodeModuleDirectory(directory);
        if (!nodeModules) {
          return void 0;
        }
        return useDirectory(path22.join(directory, "node_modules", ".cache", options2.name), options2);
      };
    });
    var require_util2 = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getDownloadUrl = exports2.getCacheDir = exports2.getRootCacheDir = void 0;
      var debug_12 = __importDefault2(require_dist());
      var get_platform_12 = require_dist2();
      var find_cache_dir_1 = __importDefault2(require_find_cache_dir());
      var fs_12 = __importDefault2(__require("fs"));
      var make_dir_12 = __importDefault2(require_make_dir());
      var os_1 = __importDefault2(__require("os"));
      var path_12 = __importDefault2(__require("path"));
      var download_1 = require_download();
      var debug32 = (0, debug_12.default)("prisma:cache-dir");
      async function getRootCacheDir() {
        if (os_1.default.platform() === "win32") {
          const cacheDir = (0, find_cache_dir_1.default)({ name: "prisma", create: true });
          if (cacheDir) {
            return cacheDir;
          }
          if (process.env.APPDATA) {
            return path_12.default.join(process.env.APPDATA, "Prisma");
          }
        }
        if (process.env.AWS_LAMBDA_FUNCTION_VERSION) {
          try {
            await (0, make_dir_12.default)(`/tmp/prisma-download`);
            return `/tmp/prisma-download`;
          } catch (e) {
            return null;
          }
        }
        return path_12.default.join(os_1.default.homedir(), ".cache/prisma");
      }
      __name(getRootCacheDir, "getRootCacheDir");
      exports2.getRootCacheDir = getRootCacheDir;
      async function getCacheDir(channel2, version, platform2) {
        const rootCacheDir = await getRootCacheDir();
        if (!rootCacheDir) {
          return null;
        }
        const cacheDir = path_12.default.join(rootCacheDir, channel2, version, platform2);
        try {
          if (!fs_12.default.existsSync(cacheDir)) {
            await (0, make_dir_12.default)(cacheDir);
          }
        } catch (e) {
          debug32("The following error is being caught and just there for debugging:");
          debug32(e);
          return null;
        }
        return cacheDir;
      }
      __name(getCacheDir, "getCacheDir");
      exports2.getCacheDir = getCacheDir;
      function getDownloadUrl(channel2, version, platform2, binaryName, extension = ".gz") {
        const baseUrl = process.env.PRISMA_BINARIES_MIRROR || process.env.PRISMA_ENGINES_MIRROR || "https://binaries.prisma.sh";
        const finalExtension = platform2 === "windows" && download_1.BinaryType.libqueryEngine !== binaryName ? `.exe${extension}` : extension;
        if (binaryName === download_1.BinaryType.libqueryEngine) {
          binaryName = (0, get_platform_12.getNodeAPIName)(platform2, "url");
        }
        return `${baseUrl}/${channel2}/${version}/${platform2}/${binaryName}${finalExtension}`;
      }
      __name(getDownloadUrl, "getDownloadUrl");
      exports2.getDownloadUrl = getDownloadUrl;
    });
    var require_old = __commonJS((exports2) => {
      var pathModule = __require("path");
      var isWindows = process.platform === "win32";
      var fs7 = __require("fs");
      var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
      function rethrow() {
        var callback;
        if (DEBUG) {
          var backtrace = new Error();
          callback = debugCallback;
        } else
          callback = missingCallback;
        return callback;
        function debugCallback(err) {
          if (err) {
            backtrace.message = err.message;
            err = backtrace;
            missingCallback(err);
          }
        }
        __name(debugCallback, "debugCallback");
        function missingCallback(err) {
          if (err) {
            if (process.throwDeprecation)
              throw err;
            else if (!process.noDeprecation) {
              var msg = "fs: missing callback " + (err.stack || err.message);
              if (process.traceDeprecation)
                console.trace(msg);
              else
                console.error(msg);
            }
          }
        }
        __name(missingCallback, "missingCallback");
      }
      __name(rethrow, "rethrow");
      function maybeCallback(cb) {
        return typeof cb === "function" ? cb : rethrow();
      }
      __name(maybeCallback, "maybeCallback");
      var normalize = pathModule.normalize;
      if (isWindows) {
        nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
      } else {
        nextPartRe = /(.*?)(?:[\/]+|$)/g;
      }
      var nextPartRe;
      if (isWindows) {
        splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
      } else {
        splitRootRe = /^[\/]*/;
      }
      var splitRootRe;
      exports2.realpathSync = /* @__PURE__ */ __name(function realpathSync2(p, cache) {
        p = pathModule.resolve(p);
        if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
          return cache[p];
        }
        var original = p, seenLinks = {}, knownHard = {};
        var pos;
        var current;
        var base;
        var previous;
        start();
        function start() {
          var m = splitRootRe.exec(p);
          pos = m[0].length;
          current = m[0];
          base = m[0];
          previous = "";
          if (isWindows && !knownHard[base]) {
            fs7.lstatSync(base);
            knownHard[base] = true;
          }
        }
        __name(start, "start");
        while (pos < p.length) {
          nextPartRe.lastIndex = pos;
          var result = nextPartRe.exec(p);
          previous = current;
          current += result[0];
          base = previous + result[1];
          pos = nextPartRe.lastIndex;
          if (knownHard[base] || cache && cache[base] === base) {
            continue;
          }
          var resolvedLink;
          if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            resolvedLink = cache[base];
          } else {
            var stat = fs7.lstatSync(base);
            if (!stat.isSymbolicLink()) {
              knownHard[base] = true;
              if (cache)
                cache[base] = base;
              continue;
            }
            var linkTarget = null;
            if (!isWindows) {
              var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
              if (seenLinks.hasOwnProperty(id)) {
                linkTarget = seenLinks[id];
              }
            }
            if (linkTarget === null) {
              fs7.statSync(base);
              linkTarget = fs7.readlinkSync(base);
            }
            resolvedLink = pathModule.resolve(previous, linkTarget);
            if (cache)
              cache[base] = resolvedLink;
            if (!isWindows)
              seenLinks[id] = linkTarget;
          }
          p = pathModule.resolve(resolvedLink, p.slice(pos));
          start();
        }
        if (cache)
          cache[original] = p;
        return p;
      }, "realpathSync");
      exports2.realpath = /* @__PURE__ */ __name(function realpath(p, cache, cb) {
        if (typeof cb !== "function") {
          cb = maybeCallback(cache);
          cache = null;
        }
        p = pathModule.resolve(p);
        if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
          return process.nextTick(cb.bind(null, null, cache[p]));
        }
        var original = p, seenLinks = {}, knownHard = {};
        var pos;
        var current;
        var base;
        var previous;
        start();
        function start() {
          var m = splitRootRe.exec(p);
          pos = m[0].length;
          current = m[0];
          base = m[0];
          previous = "";
          if (isWindows && !knownHard[base]) {
            fs7.lstat(base, function(err) {
              if (err)
                return cb(err);
              knownHard[base] = true;
              LOOP();
            });
          } else {
            process.nextTick(LOOP);
          }
        }
        __name(start, "start");
        function LOOP() {
          if (pos >= p.length) {
            if (cache)
              cache[original] = p;
            return cb(null, p);
          }
          nextPartRe.lastIndex = pos;
          var result = nextPartRe.exec(p);
          previous = current;
          current += result[0];
          base = previous + result[1];
          pos = nextPartRe.lastIndex;
          if (knownHard[base] || cache && cache[base] === base) {
            return process.nextTick(LOOP);
          }
          if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            return gotResolvedLink(cache[base]);
          }
          return fs7.lstat(base, gotStat);
        }
        __name(LOOP, "LOOP");
        function gotStat(err, stat) {
          if (err)
            return cb(err);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            return process.nextTick(LOOP);
          }
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              return gotTarget(null, seenLinks[id], base);
            }
          }
          fs7.stat(base, function(err2) {
            if (err2)
              return cb(err2);
            fs7.readlink(base, function(err3, target) {
              if (!isWindows)
                seenLinks[id] = target;
              gotTarget(err3, target);
            });
          });
        }
        __name(gotStat, "gotStat");
        function gotTarget(err, target, base2) {
          if (err)
            return cb(err);
          var resolvedLink = pathModule.resolve(previous, target);
          if (cache)
            cache[base2] = resolvedLink;
          gotResolvedLink(resolvedLink);
        }
        __name(gotTarget, "gotTarget");
        function gotResolvedLink(resolvedLink) {
          p = pathModule.resolve(resolvedLink, p.slice(pos));
          start();
        }
        __name(gotResolvedLink, "gotResolvedLink");
      }, "realpath");
    });
    var require_fs = __commonJS((exports2, module2) => {
      module2.exports = realpath;
      realpath.realpath = realpath;
      realpath.sync = realpathSync2;
      realpath.realpathSync = realpathSync2;
      realpath.monkeypatch = monkeypatch;
      realpath.unmonkeypatch = unmonkeypatch;
      var fs7 = __require("fs");
      var origRealpath = fs7.realpath;
      var origRealpathSync = fs7.realpathSync;
      var version = process.version;
      var ok = /^v[0-5]\./.test(version);
      var old = require_old();
      function newError(er) {
        return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
      }
      __name(newError, "newError");
      function realpath(p, cache, cb) {
        if (ok) {
          return origRealpath(p, cache, cb);
        }
        if (typeof cache === "function") {
          cb = cache;
          cache = null;
        }
        origRealpath(p, cache, function(er, result) {
          if (newError(er)) {
            old.realpath(p, cache, cb);
          } else {
            cb(er, result);
          }
        });
      }
      __name(realpath, "realpath");
      function realpathSync2(p, cache) {
        if (ok) {
          return origRealpathSync(p, cache);
        }
        try {
          return origRealpathSync(p, cache);
        } catch (er) {
          if (newError(er)) {
            return old.realpathSync(p, cache);
          } else {
            throw er;
          }
        }
      }
      __name(realpathSync2, "realpathSync");
      function monkeypatch() {
        fs7.realpath = realpath;
        fs7.realpathSync = realpathSync2;
      }
      __name(monkeypatch, "monkeypatch");
      function unmonkeypatch() {
        fs7.realpath = origRealpath;
        fs7.realpathSync = origRealpathSync;
      }
      __name(unmonkeypatch, "unmonkeypatch");
    });
    var require_concat_map = __commonJS((exports2, module2) => {
      module2.exports = function(xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          if (isArray(x))
            res.push.apply(res, x);
          else
            res.push(x);
        }
        return res;
      };
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
    });
    var require_balanced_match = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      __name(balanced, "balanced");
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      __name(maybeMatch, "maybeMatch");
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
      __name(range, "range");
    });
    var require_brace_expansion = __commonJS((exports2, module2) => {
      var concatMap = require_concat_map();
      var balanced = require_balanced_match();
      module2.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      __name(numeric, "numeric");
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      __name(escapeBraces, "escapeBraces");
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      __name(unescapeBraces, "unescapeBraces");
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      __name(parseCommaParts, "parseCommaParts");
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand(escapeBraces(str), true).map(unescapeBraces);
      }
      __name(expandTop, "expandTop");
      function embrace(str) {
        return "{" + str + "}";
      }
      __name(embrace, "embrace");
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      __name(isPadded, "isPadded");
      function lte(i, y) {
        return i <= y;
      }
      __name(lte, "lte");
      function gte(i, y) {
        return i >= y;
      }
      __name(gte, "gte");
      function expand(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m || /\$$/.test(m.pre))
          return [str];
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              var post = m.post.length ? expand(m.post, false) : [""];
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [""];
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = concatMap(n, function(el) {
            return expand(el, false);
          });
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
        return expansions;
      }
      __name(expand, "expand");
    });
    var require_minimatch = __commonJS((exports2, module2) => {
      module2.exports = minimatch;
      minimatch.Minimatch = Minimatch;
      var path22 = { sep: "/" };
      try {
        path22 = __require("path");
      } catch (er) {
      }
      var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
      var expand = require_brace_expansion();
      var plTypes = {
        "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
        "?": { open: "(?:", close: ")?" },
        "+": { open: "(?:", close: ")+" },
        "*": { open: "(?:", close: ")*" },
        "@": { open: "(?:", close: ")" }
      };
      var qmark = "[^/]";
      var star = qmark + "*?";
      var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
      var reSpecials = charSet("().*{}+?[]^$\\!");
      function charSet(s) {
        return s.split("").reduce(function(set, c) {
          set[c] = true;
          return set;
        }, {});
      }
      __name(charSet, "charSet");
      var slashSplit = /\/+/;
      minimatch.filter = filter;
      function filter(pattern, options2) {
        options2 = options2 || {};
        return function(p, i, list) {
          return minimatch(p, pattern, options2);
        };
      }
      __name(filter, "filter");
      function ext(a, b) {
        a = a || {};
        b = b || {};
        var t = {};
        Object.keys(b).forEach(function(k) {
          t[k] = b[k];
        });
        Object.keys(a).forEach(function(k) {
          t[k] = a[k];
        });
        return t;
      }
      __name(ext, "ext");
      minimatch.defaults = function(def) {
        if (!def || !Object.keys(def).length)
          return minimatch;
        var orig = minimatch;
        var m = /* @__PURE__ */ __name(function minimatch2(p, pattern, options2) {
          return orig.minimatch(p, pattern, ext(def, options2));
        }, "minimatch2");
        m.Minimatch = /* @__PURE__ */ __name(function Minimatch2(pattern, options2) {
          return new orig.Minimatch(pattern, ext(def, options2));
        }, "Minimatch2");
        return m;
      };
      Minimatch.defaults = function(def) {
        if (!def || !Object.keys(def).length)
          return Minimatch;
        return minimatch.defaults(def).Minimatch;
      };
      function minimatch(p, pattern, options2) {
        if (typeof pattern !== "string") {
          throw new TypeError("glob pattern string required");
        }
        if (!options2)
          options2 = {};
        if (!options2.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        if (pattern.trim() === "")
          return p === "";
        return new Minimatch(pattern, options2).match(p);
      }
      __name(minimatch, "minimatch");
      function Minimatch(pattern, options2) {
        if (!(this instanceof Minimatch)) {
          return new Minimatch(pattern, options2);
        }
        if (typeof pattern !== "string") {
          throw new TypeError("glob pattern string required");
        }
        if (!options2)
          options2 = {};
        pattern = pattern.trim();
        if (path22.sep !== "/") {
          pattern = pattern.split(path22.sep).join("/");
        }
        this.options = options2;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.make();
      }
      __name(Minimatch, "Minimatch");
      Minimatch.prototype.debug = function() {
      };
      Minimatch.prototype.make = make;
      function make() {
        if (this._made)
          return;
        var pattern = this.pattern;
        var options2 = this.options;
        if (!options2.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        var set = this.globSet = this.braceExpand();
        if (options2.debug)
          this.debug = console.error;
        this.debug(this.pattern, set);
        set = this.globParts = set.map(function(s) {
          return s.split(slashSplit);
        });
        this.debug(this.pattern, set);
        set = set.map(function(s, si, set2) {
          return s.map(this.parse, this);
        }, this);
        this.debug(this.pattern, set);
        set = set.filter(function(s) {
          return s.indexOf(false) === -1;
        });
        this.debug(this.pattern, set);
        this.set = set;
      }
      __name(make, "make");
      Minimatch.prototype.parseNegate = parseNegate;
      function parseNegate() {
        var pattern = this.pattern;
        var negate = false;
        var options2 = this.options;
        var negateOffset = 0;
        if (options2.nonegate)
          return;
        for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      __name(parseNegate, "parseNegate");
      minimatch.braceExpand = function(pattern, options2) {
        return braceExpand(pattern, options2);
      };
      Minimatch.prototype.braceExpand = braceExpand;
      function braceExpand(pattern, options2) {
        if (!options2) {
          if (this instanceof Minimatch) {
            options2 = this.options;
          } else {
            options2 = {};
          }
        }
        pattern = typeof pattern === "undefined" ? this.pattern : pattern;
        if (typeof pattern === "undefined") {
          throw new TypeError("undefined pattern");
        }
        if (options2.nobrace || !pattern.match(/\{.*\}/)) {
          return [pattern];
        }
        return expand(pattern);
      }
      __name(braceExpand, "braceExpand");
      Minimatch.prototype.parse = parse2;
      var SUBPARSE = {};
      function parse2(pattern, isSub) {
        if (pattern.length > 1024 * 64) {
          throw new TypeError("pattern is too long");
        }
        var options2 = this.options;
        if (!options2.noglobstar && pattern === "**")
          return GLOBSTAR;
        if (pattern === "")
          return "";
        var re = "";
        var hasMagic = !!options2.nocase;
        var escaping = false;
        var patternListStack = [];
        var negativeLists = [];
        var stateChar;
        var inClass = false;
        var reClassStart = -1;
        var classStart = -1;
        var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        var self2 = this;
        function clearStateChar() {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            self2.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        }
        __name(clearStateChar, "clearStateChar");
        for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping && reSpecials[c]) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/":
              return false;
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              self2.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options2.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              var pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }
              if (inClass) {
                var cs = pattern.substring(classStart + 1, i);
                try {
                  RegExp("[" + cs + "]");
                } catch (er) {
                  var sp = this.parse(cs, SUBPARSE);
                  re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                  hasMagic = hasMagic || sp[1];
                  inClass = false;
                  continue;
                }
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (escaping) {
                escaping = false;
              } else if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          var tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        var addPatternStart = false;
        switch (re.charAt(0)) {
          case ".":
          case "[":
          case "(":
            addPatternStart = true;
        }
        for (var n = negativeLists.length - 1; n > -1; n--) {
          var nl = negativeLists[n];
          var nlBefore = re.slice(0, nl.reStart);
          var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
          var nlAfter = re.slice(nl.reEnd);
          nlLast += nlAfter;
          var openParensBefore = nlBefore.split("(").length - 1;
          var cleanAfter = nlAfter;
          for (i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          var dollar = "";
          if (nlAfter === "" && isSub !== SUBPARSE) {
            dollar = "$";
          }
          var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
          re = newRe;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        var flags = options2.nocase ? "i" : "";
        try {
          var regExp = new RegExp("^" + re + "$", flags);
        } catch (er) {
          return new RegExp("$.");
        }
        regExp._glob = pattern;
        regExp._src = re;
        return regExp;
      }
      __name(parse2, "parse");
      minimatch.makeRe = function(pattern, options2) {
        return new Minimatch(pattern, options2 || {}).makeRe();
      };
      Minimatch.prototype.makeRe = makeRe;
      function makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        var set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        var options2 = this.options;
        var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
        var flags = options2.nocase ? "i" : "";
        var re = set.map(function(pattern) {
          return pattern.map(function(p) {
            return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
          }).join("\\/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      __name(makeRe, "makeRe");
      minimatch.match = function(list, pattern, options2) {
        options2 = options2 || {};
        var mm = new Minimatch(pattern, options2);
        list = list.filter(function(f) {
          return mm.match(f);
        });
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      Minimatch.prototype.match = match;
      function match(f, partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        var options2 = this.options;
        if (path22.sep !== "/") {
          f = f.split(path22.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        var set = this.set;
        this.debug(this.pattern, "set", set);
        var filename;
        var i;
        for (i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (i = 0; i < set.length; i++) {
          var pattern = set[i];
          var file2 = f;
          if (options2.matchBase && pattern.length === 1) {
            file2 = [filename];
          }
          var hit = this.matchOne(file2, pattern, partial);
          if (hit) {
            if (options2.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options2.flipNegate)
          return false;
        return this.negate;
      }
      __name(match, "match");
      Minimatch.prototype.matchOne = function(file2, pattern, partial) {
        var options2 = this.options;
        this.debug("matchOne", { this: this, file: file2, pattern });
        this.debug("matchOne", file2.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file2[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file2[fi] === "." || file2[fi] === ".." || !options2.dot && file2[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file2[fr];
              this.debug("\nglobstar while", file2, fr, pattern, pr, swallowee);
              if (this.matchOne(file2.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file2, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file2, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            if (options2.nocase) {
              hit = f.toLowerCase() === p.toLowerCase();
            } else {
              hit = f === p;
            }
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          var emptyFileEnd = fi === fl - 1 && file2[fi] === "";
          return emptyFileEnd;
        }
        throw new Error("wtf?");
      };
      function globUnescape(s) {
        return s.replace(/\\(.)/g, "$1");
      }
      __name(globUnescape, "globUnescape");
      function regExpEscape(s) {
        return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
      __name(regExpEscape, "regExpEscape");
    });
    var require_inherits_browser = __commonJS((exports2, module2) => {
      if (typeof Object.create === "function") {
        module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        }, "inherits");
      } else {
        module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = /* @__PURE__ */ __name(function() {
            }, "TempCtor");
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        }, "inherits");
      }
    });
    var require_inherits = __commonJS((exports2, module2) => {
      try {
        util2 = __require("util");
        if (typeof util2.inherits !== "function")
          throw "";
        module2.exports = util2.inherits;
      } catch (e) {
        module2.exports = require_inherits_browser();
      }
      var util2;
    });
    var require_path_is_absolute = __commonJS((exports2, module2) => {
      "use strict";
      function posix(path22) {
        return path22.charAt(0) === "/";
      }
      __name(posix, "posix");
      function win32(path22) {
        var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
        var result = splitDeviceRe.exec(path22);
        var device = result[1] || "";
        var isUnc = Boolean(device && device.charAt(1) !== ":");
        return Boolean(result[2] || isUnc);
      }
      __name(win32, "win32");
      module2.exports = process.platform === "win32" ? win32 : posix;
      module2.exports.posix = posix;
      module2.exports.win32 = win32;
    });
    var require_common2 = __commonJS((exports2) => {
      exports2.alphasort = alphasort;
      exports2.alphasorti = alphasorti;
      exports2.setopts = setopts;
      exports2.ownProp = ownProp;
      exports2.makeAbs = makeAbs;
      exports2.finish = finish;
      exports2.mark = mark;
      exports2.isIgnored = isIgnored;
      exports2.childrenIgnored = childrenIgnored;
      function ownProp(obj, field) {
        return Object.prototype.hasOwnProperty.call(obj, field);
      }
      __name(ownProp, "ownProp");
      var path22 = __require("path");
      var minimatch = require_minimatch();
      var isAbsolute = require_path_is_absolute();
      var Minimatch = minimatch.Minimatch;
      function alphasorti(a, b) {
        return a.toLowerCase().localeCompare(b.toLowerCase());
      }
      __name(alphasorti, "alphasorti");
      function alphasort(a, b) {
        return a.localeCompare(b);
      }
      __name(alphasort, "alphasort");
      function setupIgnores(self2, options2) {
        self2.ignore = options2.ignore || [];
        if (!Array.isArray(self2.ignore))
          self2.ignore = [self2.ignore];
        if (self2.ignore.length) {
          self2.ignore = self2.ignore.map(ignoreMap);
        }
      }
      __name(setupIgnores, "setupIgnores");
      function ignoreMap(pattern) {
        var gmatcher = null;
        if (pattern.slice(-3) === "/**") {
          var gpattern = pattern.replace(/(\/\*\*)+$/, "");
          gmatcher = new Minimatch(gpattern, { dot: true });
        }
        return {
          matcher: new Minimatch(pattern, { dot: true }),
          gmatcher
        };
      }
      __name(ignoreMap, "ignoreMap");
      function setopts(self2, pattern, options2) {
        if (!options2)
          options2 = {};
        if (options2.matchBase && pattern.indexOf("/") === -1) {
          if (options2.noglobstar) {
            throw new Error("base matching requires globstar");
          }
          pattern = "**/" + pattern;
        }
        self2.silent = !!options2.silent;
        self2.pattern = pattern;
        self2.strict = options2.strict !== false;
        self2.realpath = !!options2.realpath;
        self2.realpathCache = options2.realpathCache || Object.create(null);
        self2.follow = !!options2.follow;
        self2.dot = !!options2.dot;
        self2.mark = !!options2.mark;
        self2.nodir = !!options2.nodir;
        if (self2.nodir)
          self2.mark = true;
        self2.sync = !!options2.sync;
        self2.nounique = !!options2.nounique;
        self2.nonull = !!options2.nonull;
        self2.nosort = !!options2.nosort;
        self2.nocase = !!options2.nocase;
        self2.stat = !!options2.stat;
        self2.noprocess = !!options2.noprocess;
        self2.absolute = !!options2.absolute;
        self2.maxLength = options2.maxLength || Infinity;
        self2.cache = options2.cache || Object.create(null);
        self2.statCache = options2.statCache || Object.create(null);
        self2.symlinks = options2.symlinks || Object.create(null);
        setupIgnores(self2, options2);
        self2.changedCwd = false;
        var cwd = process.cwd();
        if (!ownProp(options2, "cwd"))
          self2.cwd = cwd;
        else {
          self2.cwd = path22.resolve(options2.cwd);
          self2.changedCwd = self2.cwd !== cwd;
        }
        self2.root = options2.root || path22.resolve(self2.cwd, "/");
        self2.root = path22.resolve(self2.root);
        if (process.platform === "win32")
          self2.root = self2.root.replace(/\\/g, "/");
        self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
        if (process.platform === "win32")
          self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
        self2.nomount = !!options2.nomount;
        options2.nonegate = true;
        options2.nocomment = true;
        self2.minimatch = new Minimatch(pattern, options2);
        self2.options = self2.minimatch.options;
      }
      __name(setopts, "setopts");
      function finish(self2) {
        var nou = self2.nounique;
        var all = nou ? [] : Object.create(null);
        for (var i = 0, l = self2.matches.length; i < l; i++) {
          var matches = self2.matches[i];
          if (!matches || Object.keys(matches).length === 0) {
            if (self2.nonull) {
              var literal = self2.minimatch.globSet[i];
              if (nou)
                all.push(literal);
              else
                all[literal] = true;
            }
          } else {
            var m = Object.keys(matches);
            if (nou)
              all.push.apply(all, m);
            else
              m.forEach(function(m2) {
                all[m2] = true;
              });
          }
        }
        if (!nou)
          all = Object.keys(all);
        if (!self2.nosort)
          all = all.sort(self2.nocase ? alphasorti : alphasort);
        if (self2.mark) {
          for (var i = 0; i < all.length; i++) {
            all[i] = self2._mark(all[i]);
          }
          if (self2.nodir) {
            all = all.filter(function(e) {
              var notDir = !/\/$/.test(e);
              var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
              if (notDir && c)
                notDir = c !== "DIR" && !Array.isArray(c);
              return notDir;
            });
          }
        }
        if (self2.ignore.length)
          all = all.filter(function(m2) {
            return !isIgnored(self2, m2);
          });
        self2.found = all;
      }
      __name(finish, "finish");
      function mark(self2, p) {
        var abs2 = makeAbs(self2, p);
        var c = self2.cache[abs2];
        var m = p;
        if (c) {
          var isDir = c === "DIR" || Array.isArray(c);
          var slash = p.slice(-1) === "/";
          if (isDir && !slash)
            m += "/";
          else if (!isDir && slash)
            m = m.slice(0, -1);
          if (m !== p) {
            var mabs = makeAbs(self2, m);
            self2.statCache[mabs] = self2.statCache[abs2];
            self2.cache[mabs] = self2.cache[abs2];
          }
        }
        return m;
      }
      __name(mark, "mark");
      function makeAbs(self2, f) {
        var abs2 = f;
        if (f.charAt(0) === "/") {
          abs2 = path22.join(self2.root, f);
        } else if (isAbsolute(f) || f === "") {
          abs2 = f;
        } else if (self2.changedCwd) {
          abs2 = path22.resolve(self2.cwd, f);
        } else {
          abs2 = path22.resolve(f);
        }
        if (process.platform === "win32")
          abs2 = abs2.replace(/\\/g, "/");
        return abs2;
      }
      __name(makeAbs, "makeAbs");
      function isIgnored(self2, path32) {
        if (!self2.ignore.length)
          return false;
        return self2.ignore.some(function(item) {
          return item.matcher.match(path32) || !!(item.gmatcher && item.gmatcher.match(path32));
        });
      }
      __name(isIgnored, "isIgnored");
      function childrenIgnored(self2, path32) {
        if (!self2.ignore.length)
          return false;
        return self2.ignore.some(function(item) {
          return !!(item.gmatcher && item.gmatcher.match(path32));
        });
      }
      __name(childrenIgnored, "childrenIgnored");
    });
    var require_sync = __commonJS((exports2, module2) => {
      module2.exports = globSync;
      globSync.GlobSync = GlobSync;
      var fs7 = __require("fs");
      var rp = require_fs();
      var minimatch = require_minimatch();
      var Minimatch = minimatch.Minimatch;
      var Glob = require_glob().Glob;
      var util2 = __require("util");
      var path22 = __require("path");
      var assert = __require("assert");
      var isAbsolute = require_path_is_absolute();
      var common = require_common2();
      var alphasort = common.alphasort;
      var alphasorti = common.alphasorti;
      var setopts = common.setopts;
      var ownProp = common.ownProp;
      var childrenIgnored = common.childrenIgnored;
      var isIgnored = common.isIgnored;
      function globSync(pattern, options2) {
        if (typeof options2 === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        return new GlobSync(pattern, options2).found;
      }
      __name(globSync, "globSync");
      function GlobSync(pattern, options2) {
        if (!pattern)
          throw new Error("must provide pattern");
        if (typeof options2 === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        if (!(this instanceof GlobSync))
          return new GlobSync(pattern, options2);
        setopts(this, pattern, options2);
        if (this.noprocess)
          return this;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        for (var i = 0; i < n; i++) {
          this._process(this.minimatch.set[i], i, false);
        }
        this._finish();
      }
      __name(GlobSync, "GlobSync");
      GlobSync.prototype._finish = function() {
        assert(this instanceof GlobSync);
        if (this.realpath) {
          var self2 = this;
          this.matches.forEach(function(matchset, index) {
            var set = self2.matches[index] = Object.create(null);
            for (var p in matchset) {
              try {
                p = self2._makeAbs(p);
                var real = rp.realpathSync(p, self2.realpathCache);
                set[real] = true;
              } catch (er) {
                if (er.syscall === "stat")
                  set[self2._makeAbs(p)] = true;
                else
                  throw er;
              }
            }
          });
        }
        common.finish(this);
      };
      GlobSync.prototype._process = function(pattern, index, inGlobStar) {
        assert(this instanceof GlobSync);
        var n = 0;
        while (typeof pattern[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern.length:
            this._processSimple(pattern.join("/"), index);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern.slice(0, n).join("/");
            break;
        }
        var remain = pattern.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
          if (!prefix || !isAbsolute(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs2 = this._makeAbs(read);
        if (childrenIgnored(this, read))
          return;
        var isGlobStar = remain[0] === minimatch.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs2, remain, index, inGlobStar);
        else
          this._processReaddir(prefix, read, abs2, remain, index, inGlobStar);
      };
      GlobSync.prototype._processReaddir = function(prefix, read, abs2, remain, index, inGlobStar) {
        var entries = this._readdir(abs2, inGlobStar);
        if (!entries)
          return;
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return;
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = Object.create(null);
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            if (prefix) {
              if (prefix.slice(-1) !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path22.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          var newPattern;
          if (prefix)
            newPattern = [prefix, e];
          else
            newPattern = [e];
          this._process(newPattern.concat(remain), index, inGlobStar);
        }
      };
      GlobSync.prototype._emitMatch = function(index, e) {
        if (isIgnored(this, e))
          return;
        var abs2 = this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute) {
          e = abs2;
        }
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs2];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        if (this.stat)
          this._stat(e);
      };
      GlobSync.prototype._readdirInGlobStar = function(abs2) {
        if (this.follow)
          return this._readdir(abs2, false);
        var entries;
        var lstat;
        var stat;
        try {
          lstat = fs7.lstatSync(abs2);
        } catch (er) {
          if (er.code === "ENOENT") {
            return null;
          }
        }
        var isSym = lstat && lstat.isSymbolicLink();
        this.symlinks[abs2] = isSym;
        if (!isSym && lstat && !lstat.isDirectory())
          this.cache[abs2] = "FILE";
        else
          entries = this._readdir(abs2, false);
        return entries;
      };
      GlobSync.prototype._readdir = function(abs2, inGlobStar) {
        var entries;
        if (inGlobStar && !ownProp(this.symlinks, abs2))
          return this._readdirInGlobStar(abs2);
        if (ownProp(this.cache, abs2)) {
          var c = this.cache[abs2];
          if (!c || c === "FILE")
            return null;
          if (Array.isArray(c))
            return c;
        }
        try {
          return this._readdirEntries(abs2, fs7.readdirSync(abs2));
        } catch (er) {
          this._readdirError(abs2, er);
          return null;
        }
      };
      GlobSync.prototype._readdirEntries = function(abs2, entries) {
        if (!this.mark && !this.stat) {
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (abs2 === "/")
              e = abs2 + e;
            else
              e = abs2 + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs2] = entries;
        return entries;
      };
      GlobSync.prototype._readdirError = function(f, er) {
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs2 = this._makeAbs(f);
            this.cache[abs2] = "FILE";
            if (abs2 === this.cwdAbs) {
              var error2 = new Error(er.code + " invalid cwd " + this.cwd);
              error2.path = this.cwd;
              error2.code = er.code;
              throw error2;
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f)] = false;
            break;
          default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict)
              throw er;
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
      };
      GlobSync.prototype._processGlobStar = function(prefix, read, abs2, remain, index, inGlobStar) {
        var entries = this._readdir(abs2, inGlobStar);
        if (!entries)
          return;
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false);
        var len = entries.length;
        var isSym = this.symlinks[abs2];
        if (isSym && inGlobStar)
          return;
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i], remainWithoutGlobStar);
          this._process(instead, index, true);
          var below = gspref.concat(entries[i], remain);
          this._process(below, index, true);
        }
      };
      GlobSync.prototype._processSimple = function(prefix, index) {
        var exists22 = this._stat(prefix);
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        if (!exists22)
          return;
        if (prefix && isAbsolute(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path22.join(this.root, prefix);
          } else {
            prefix = path22.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (process.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
      };
      GlobSync.prototype._stat = function(f) {
        var abs2 = this._makeAbs(f);
        var needDir = f.slice(-1) === "/";
        if (f.length > this.maxLength)
          return false;
        if (!this.stat && ownProp(this.cache, abs2)) {
          var c = this.cache[abs2];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return c;
          if (needDir && c === "FILE")
            return false;
        }
        var exists22;
        var stat = this.statCache[abs2];
        if (!stat) {
          var lstat;
          try {
            lstat = fs7.lstatSync(abs2);
          } catch (er) {
            if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
              this.statCache[abs2] = false;
              return false;
            }
          }
          if (lstat && lstat.isSymbolicLink()) {
            try {
              stat = fs7.statSync(abs2);
            } catch (er) {
              stat = lstat;
            }
          } else {
            stat = lstat;
          }
        }
        this.statCache[abs2] = stat;
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs2] = this.cache[abs2] || c;
        if (needDir && c === "FILE")
          return false;
        return c;
      };
      GlobSync.prototype._mark = function(p) {
        return common.mark(this, p);
      };
      GlobSync.prototype._makeAbs = function(f) {
        return common.makeAbs(this, f);
      };
    });
    var require_wrappy = __commonJS((exports2, module2) => {
      module2.exports = wrappy;
      function wrappy(fn, cb) {
        if (fn && cb)
          return wrappy(fn)(cb);
        if (typeof fn !== "function")
          throw new TypeError("need wrapper function");
        Object.keys(fn).forEach(function(k) {
          wrapper[k] = fn[k];
        });
        return wrapper;
        function wrapper() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          var ret = fn.apply(this, args);
          var cb2 = args[args.length - 1];
          if (typeof ret === "function" && ret !== cb2) {
            Object.keys(cb2).forEach(function(k) {
              ret[k] = cb2[k];
            });
          }
          return ret;
        }
        __name(wrapper, "wrapper");
      }
      __name(wrappy, "wrappy");
    });
    var require_once = __commonJS((exports2, module2) => {
      var wrappy = require_wrappy();
      module2.exports = wrappy(once);
      module2.exports.strict = wrappy(onceStrict);
      once.proto = once(function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return once(this);
          },
          configurable: true
        });
        Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return onceStrict(this);
          },
          configurable: true
        });
      });
      function once(fn) {
        var f = /* @__PURE__ */ __name(function() {
          if (f.called)
            return f.value;
          f.called = true;
          return f.value = fn.apply(this, arguments);
        }, "f");
        f.called = false;
        return f;
      }
      __name(once, "once");
      function onceStrict(fn) {
        var f = /* @__PURE__ */ __name(function() {
          if (f.called)
            throw new Error(f.onceError);
          f.called = true;
          return f.value = fn.apply(this, arguments);
        }, "f");
        var name = fn.name || "Function wrapped with `once`";
        f.onceError = name + " shouldn't be called more than once";
        f.called = false;
        return f;
      }
      __name(onceStrict, "onceStrict");
    });
    var require_inflight = __commonJS((exports2, module2) => {
      var wrappy = require_wrappy();
      var reqs = Object.create(null);
      var once = require_once();
      module2.exports = wrappy(inflight);
      function inflight(key, cb) {
        if (reqs[key]) {
          reqs[key].push(cb);
          return null;
        } else {
          reqs[key] = [cb];
          return makeres(key);
        }
      }
      __name(inflight, "inflight");
      function makeres(key) {
        return once(/* @__PURE__ */ __name(function RES() {
          var cbs = reqs[key];
          var len = cbs.length;
          var args = slice(arguments);
          try {
            for (var i = 0; i < len; i++) {
              cbs[i].apply(null, args);
            }
          } finally {
            if (cbs.length > len) {
              cbs.splice(0, len);
              process.nextTick(function() {
                RES.apply(null, args);
              });
            } else {
              delete reqs[key];
            }
          }
        }, "RES"));
      }
      __name(makeres, "makeres");
      function slice(args) {
        var length = args.length;
        var array = [];
        for (var i = 0; i < length; i++)
          array[i] = args[i];
        return array;
      }
      __name(slice, "slice");
    });
    var require_glob = __commonJS((exports2, module2) => {
      module2.exports = glob;
      var fs7 = __require("fs");
      var rp = require_fs();
      var minimatch = require_minimatch();
      var Minimatch = minimatch.Minimatch;
      var inherits = require_inherits();
      var EE = __require("events").EventEmitter;
      var path22 = __require("path");
      var assert = __require("assert");
      var isAbsolute = require_path_is_absolute();
      var globSync = require_sync();
      var common = require_common2();
      var alphasort = common.alphasort;
      var alphasorti = common.alphasorti;
      var setopts = common.setopts;
      var ownProp = common.ownProp;
      var inflight = require_inflight();
      var util2 = __require("util");
      var childrenIgnored = common.childrenIgnored;
      var isIgnored = common.isIgnored;
      var once = require_once();
      function glob(pattern, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = {};
        if (!options2)
          options2 = {};
        if (options2.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return globSync(pattern, options2);
        }
        return new Glob(pattern, options2, cb);
      }
      __name(glob, "glob");
      glob.sync = globSync;
      var GlobSync = glob.GlobSync = globSync.GlobSync;
      glob.glob = glob;
      function extend(origin, add2) {
        if (add2 === null || typeof add2 !== "object") {
          return origin;
        }
        var keys2 = Object.keys(add2);
        var i = keys2.length;
        while (i--) {
          origin[keys2[i]] = add2[keys2[i]];
        }
        return origin;
      }
      __name(extend, "extend");
      glob.hasMagic = function(pattern, options_) {
        var options2 = extend({}, options_);
        options2.noprocess = true;
        var g = new Glob(pattern, options2);
        var set = g.minimatch.set;
        if (!pattern)
          return false;
        if (set.length > 1)
          return true;
        for (var j = 0; j < set[0].length; j++) {
          if (typeof set[0][j] !== "string")
            return true;
        }
        return false;
      };
      glob.Glob = Glob;
      inherits(Glob, EE);
      function Glob(pattern, options2, cb) {
        if (typeof options2 === "function") {
          cb = options2;
          options2 = null;
        }
        if (options2 && options2.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return new GlobSync(pattern, options2);
        }
        if (!(this instanceof Glob))
          return new Glob(pattern, options2, cb);
        setopts(this, pattern, options2);
        this._didRealPath = false;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        if (typeof cb === "function") {
          cb = once(cb);
          this.on("error", cb);
          this.on("end", function(matches) {
            cb(null, matches);
          });
        }
        var self2 = this;
        this._processing = 0;
        this._emitQueue = [];
        this._processQueue = [];
        this.paused = false;
        if (this.noprocess)
          return this;
        if (n === 0)
          return done();
        var sync = true;
        for (var i = 0; i < n; i++) {
          this._process(this.minimatch.set[i], i, false, done);
        }
        sync = false;
        function done() {
          --self2._processing;
          if (self2._processing <= 0) {
            if (sync) {
              process.nextTick(function() {
                self2._finish();
              });
            } else {
              self2._finish();
            }
          }
        }
        __name(done, "done");
      }
      __name(Glob, "Glob");
      Glob.prototype._finish = function() {
        assert(this instanceof Glob);
        if (this.aborted)
          return;
        if (this.realpath && !this._didRealpath)
          return this._realpath();
        common.finish(this);
        this.emit("end", this.found);
      };
      Glob.prototype._realpath = function() {
        if (this._didRealpath)
          return;
        this._didRealpath = true;
        var n = this.matches.length;
        if (n === 0)
          return this._finish();
        var self2 = this;
        for (var i = 0; i < this.matches.length; i++)
          this._realpathSet(i, next);
        function next() {
          if (--n === 0)
            self2._finish();
        }
        __name(next, "next");
      };
      Glob.prototype._realpathSet = function(index, cb) {
        var matchset = this.matches[index];
        if (!matchset)
          return cb();
        var found = Object.keys(matchset);
        var self2 = this;
        var n = found.length;
        if (n === 0)
          return cb();
        var set = this.matches[index] = Object.create(null);
        found.forEach(function(p, i) {
          p = self2._makeAbs(p);
          rp.realpath(p, self2.realpathCache, function(er, real) {
            if (!er)
              set[real] = true;
            else if (er.syscall === "stat")
              set[p] = true;
            else
              self2.emit("error", er);
            if (--n === 0) {
              self2.matches[index] = set;
              cb();
            }
          });
        });
      };
      Glob.prototype._mark = function(p) {
        return common.mark(this, p);
      };
      Glob.prototype._makeAbs = function(f) {
        return common.makeAbs(this, f);
      };
      Glob.prototype.abort = function() {
        this.aborted = true;
        this.emit("abort");
      };
      Glob.prototype.pause = function() {
        if (!this.paused) {
          this.paused = true;
          this.emit("pause");
        }
      };
      Glob.prototype.resume = function() {
        if (this.paused) {
          this.emit("resume");
          this.paused = false;
          if (this._emitQueue.length) {
            var eq = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for (var i = 0; i < eq.length; i++) {
              var e = eq[i];
              this._emitMatch(e[0], e[1]);
            }
          }
          if (this._processQueue.length) {
            var pq = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for (var i = 0; i < pq.length; i++) {
              var p = pq[i];
              this._processing--;
              this._process(p[0], p[1], p[2], p[3]);
            }
          }
        }
      };
      Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
        assert(this instanceof Glob);
        assert(typeof cb === "function");
        if (this.aborted)
          return;
        this._processing++;
        if (this.paused) {
          this._processQueue.push([pattern, index, inGlobStar, cb]);
          return;
        }
        var n = 0;
        while (typeof pattern[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern.length:
            this._processSimple(pattern.join("/"), index, cb);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern.slice(0, n).join("/");
            break;
        }
        var remain = pattern.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
          if (!prefix || !isAbsolute(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs2 = this._makeAbs(read);
        if (childrenIgnored(this, read))
          return cb();
        var isGlobStar = remain[0] === minimatch.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs2, remain, index, inGlobStar, cb);
        else
          this._processReaddir(prefix, read, abs2, remain, index, inGlobStar, cb);
      };
      Glob.prototype._processReaddir = function(prefix, read, abs2, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs2, inGlobStar, function(er, entries) {
          return self2._processReaddir2(prefix, read, abs2, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob.prototype._processReaddir2 = function(prefix, read, abs2, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return cb();
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = Object.create(null);
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            if (prefix) {
              if (prefix !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path22.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return cb();
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          var newPattern;
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          this._process([e].concat(remain), index, inGlobStar, cb);
        }
        cb();
      };
      Glob.prototype._emitMatch = function(index, e) {
        if (this.aborted)
          return;
        if (isIgnored(this, e))
          return;
        if (this.paused) {
          this._emitQueue.push([index, e]);
          return;
        }
        var abs2 = isAbsolute(e) ? e : this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute)
          e = abs2;
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs2];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        var st = this.statCache[abs2];
        if (st)
          this.emit("stat", e, st);
        this.emit("match", e);
      };
      Glob.prototype._readdirInGlobStar = function(abs2, cb) {
        if (this.aborted)
          return;
        if (this.follow)
          return this._readdir(abs2, false, cb);
        var lstatkey = "lstat\0" + abs2;
        var self2 = this;
        var lstatcb = inflight(lstatkey, lstatcb_);
        if (lstatcb)
          fs7.lstat(abs2, lstatcb);
        function lstatcb_(er, lstat) {
          if (er && er.code === "ENOENT")
            return cb();
          var isSym = lstat && lstat.isSymbolicLink();
          self2.symlinks[abs2] = isSym;
          if (!isSym && lstat && !lstat.isDirectory()) {
            self2.cache[abs2] = "FILE";
            cb();
          } else
            self2._readdir(abs2, false, cb);
        }
        __name(lstatcb_, "lstatcb_");
      };
      Glob.prototype._readdir = function(abs2, inGlobStar, cb) {
        if (this.aborted)
          return;
        cb = inflight("readdir\0" + abs2 + "\0" + inGlobStar, cb);
        if (!cb)
          return;
        if (inGlobStar && !ownProp(this.symlinks, abs2))
          return this._readdirInGlobStar(abs2, cb);
        if (ownProp(this.cache, abs2)) {
          var c = this.cache[abs2];
          if (!c || c === "FILE")
            return cb();
          if (Array.isArray(c))
            return cb(null, c);
        }
        var self2 = this;
        fs7.readdir(abs2, readdirCb(this, abs2, cb));
      };
      function readdirCb(self2, abs2, cb) {
        return function(er, entries) {
          if (er)
            self2._readdirError(abs2, er, cb);
          else
            self2._readdirEntries(abs2, entries, cb);
        };
      }
      __name(readdirCb, "readdirCb");
      Glob.prototype._readdirEntries = function(abs2, entries, cb) {
        if (this.aborted)
          return;
        if (!this.mark && !this.stat) {
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (abs2 === "/")
              e = abs2 + e;
            else
              e = abs2 + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs2] = entries;
        return cb(null, entries);
      };
      Glob.prototype._readdirError = function(f, er, cb) {
        if (this.aborted)
          return;
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs2 = this._makeAbs(f);
            this.cache[abs2] = "FILE";
            if (abs2 === this.cwdAbs) {
              var error2 = new Error(er.code + " invalid cwd " + this.cwd);
              error2.path = this.cwd;
              error2.code = er.code;
              this.emit("error", error2);
              this.abort();
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f)] = false;
            break;
          default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict) {
              this.emit("error", er);
              this.abort();
            }
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
        return cb();
      };
      Glob.prototype._processGlobStar = function(prefix, read, abs2, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs2, inGlobStar, function(er, entries) {
          self2._processGlobStar2(prefix, read, abs2, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob.prototype._processGlobStar2 = function(prefix, read, abs2, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false, cb);
        var isSym = this.symlinks[abs2];
        var len = entries.length;
        if (isSym && inGlobStar)
          return cb();
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i], remainWithoutGlobStar);
          this._process(instead, index, true, cb);
          var below = gspref.concat(entries[i], remain);
          this._process(below, index, true, cb);
        }
        cb();
      };
      Glob.prototype._processSimple = function(prefix, index, cb) {
        var self2 = this;
        this._stat(prefix, function(er, exists22) {
          self2._processSimple2(prefix, index, er, exists22, cb);
        });
      };
      Glob.prototype._processSimple2 = function(prefix, index, er, exists22, cb) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        if (!exists22)
          return cb();
        if (prefix && isAbsolute(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path22.join(this.root, prefix);
          } else {
            prefix = path22.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (process.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
        cb();
      };
      Glob.prototype._stat = function(f, cb) {
        var abs2 = this._makeAbs(f);
        var needDir = f.slice(-1) === "/";
        if (f.length > this.maxLength)
          return cb();
        if (!this.stat && ownProp(this.cache, abs2)) {
          var c = this.cache[abs2];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return cb(null, c);
          if (needDir && c === "FILE")
            return cb();
        }
        var exists22;
        var stat = this.statCache[abs2];
        if (stat !== void 0) {
          if (stat === false)
            return cb(null, stat);
          else {
            var type = stat.isDirectory() ? "DIR" : "FILE";
            if (needDir && type === "FILE")
              return cb();
            else
              return cb(null, type, stat);
          }
        }
        var self2 = this;
        var statcb = inflight("stat\0" + abs2, lstatcb_);
        if (statcb)
          fs7.lstat(abs2, statcb);
        function lstatcb_(er, lstat) {
          if (lstat && lstat.isSymbolicLink()) {
            return fs7.stat(abs2, function(er2, stat2) {
              if (er2)
                self2._stat2(f, abs2, null, lstat, cb);
              else
                self2._stat2(f, abs2, er2, stat2, cb);
            });
          } else {
            self2._stat2(f, abs2, er, lstat, cb);
          }
        }
        __name(lstatcb_, "lstatcb_");
      };
      Glob.prototype._stat2 = function(f, abs2, er, stat, cb) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs2] = false;
          return cb();
        }
        var needDir = f.slice(-1) === "/";
        this.statCache[abs2] = stat;
        if (abs2.slice(-1) === "/" && stat && !stat.isDirectory())
          return cb(null, false, stat);
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs2] = this.cache[abs2] || c;
        if (needDir && c === "FILE")
          return cb();
        return cb(null, c, stat);
      };
    });
    var require_rimraf = __commonJS((exports2, module2) => {
      var assert = __require("assert");
      var path22 = __require("path");
      var fs7 = __require("fs");
      var glob = void 0;
      try {
        glob = require_glob();
      } catch (_err) {
      }
      var defaultGlobOpts = {
        nosort: true,
        silent: true
      };
      var timeout = 0;
      var isWindows = process.platform === "win32";
      var defaults = /* @__PURE__ */ __name((options2) => {
        const methods = [
          "unlink",
          "chmod",
          "stat",
          "lstat",
          "rmdir",
          "readdir"
        ];
        methods.forEach((m) => {
          options2[m] = options2[m] || fs7[m];
          m = m + "Sync";
          options2[m] = options2[m] || fs7[m];
        });
        options2.maxBusyTries = options2.maxBusyTries || 3;
        options2.emfileWait = options2.emfileWait || 1e3;
        if (options2.glob === false) {
          options2.disableGlob = true;
        }
        if (options2.disableGlob !== true && glob === void 0) {
          throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
        }
        options2.disableGlob = options2.disableGlob || false;
        options2.glob = options2.glob || defaultGlobOpts;
      }, "defaults");
      var rimraf = /* @__PURE__ */ __name((p, options2, cb) => {
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        assert(p, "rimraf: missing path");
        assert.equal(typeof p, "string", "rimraf: path should be a string");
        assert.equal(typeof cb, "function", "rimraf: callback function required");
        assert(options2, "rimraf: invalid options argument provided");
        assert.equal(typeof options2, "object", "rimraf: options should be object");
        defaults(options2);
        let busyTries = 0;
        let errState = null;
        let n = 0;
        const next = /* @__PURE__ */ __name((er) => {
          errState = errState || er;
          if (--n === 0)
            cb(errState);
        }, "next");
        const afterGlob = /* @__PURE__ */ __name((er, results) => {
          if (er)
            return cb(er);
          n = results.length;
          if (n === 0)
            return cb();
          results.forEach((p2) => {
            const CB = /* @__PURE__ */ __name((er2) => {
              if (er2) {
                if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options2.maxBusyTries) {
                  busyTries++;
                  return setTimeout(() => rimraf_(p2, options2, CB), busyTries * 100);
                }
                if (er2.code === "EMFILE" && timeout < options2.emfileWait) {
                  return setTimeout(() => rimraf_(p2, options2, CB), timeout++);
                }
                if (er2.code === "ENOENT")
                  er2 = null;
              }
              timeout = 0;
              next(er2);
            }, "CB");
            rimraf_(p2, options2, CB);
          });
        }, "afterGlob");
        if (options2.disableGlob || !glob.hasMagic(p))
          return afterGlob(null, [p]);
        options2.lstat(p, (er, stat) => {
          if (!er)
            return afterGlob(null, [p]);
          glob(p, options2.glob, afterGlob);
        });
      }, "rimraf");
      var rimraf_ = /* @__PURE__ */ __name((p, options2, cb) => {
        assert(p);
        assert(options2);
        assert(typeof cb === "function");
        options2.lstat(p, (er, st) => {
          if (er && er.code === "ENOENT")
            return cb(null);
          if (er && er.code === "EPERM" && isWindows)
            fixWinEPERM(p, options2, er, cb);
          if (st && st.isDirectory())
            return rmdir(p, options2, er, cb);
          options2.unlink(p, (er2) => {
            if (er2) {
              if (er2.code === "ENOENT")
                return cb(null);
              if (er2.code === "EPERM")
                return isWindows ? fixWinEPERM(p, options2, er2, cb) : rmdir(p, options2, er2, cb);
              if (er2.code === "EISDIR")
                return rmdir(p, options2, er2, cb);
            }
            return cb(er2);
          });
        });
      }, "rimraf_");
      var fixWinEPERM = /* @__PURE__ */ __name((p, options2, er, cb) => {
        assert(p);
        assert(options2);
        assert(typeof cb === "function");
        options2.chmod(p, 438, (er2) => {
          if (er2)
            cb(er2.code === "ENOENT" ? null : er);
          else
            options2.stat(p, (er3, stats) => {
              if (er3)
                cb(er3.code === "ENOENT" ? null : er);
              else if (stats.isDirectory())
                rmdir(p, options2, er, cb);
              else
                options2.unlink(p, cb);
            });
        });
      }, "fixWinEPERM");
      var fixWinEPERMSync = /* @__PURE__ */ __name((p, options2, er) => {
        assert(p);
        assert(options2);
        try {
          options2.chmodSync(p, 438);
        } catch (er2) {
          if (er2.code === "ENOENT")
            return;
          else
            throw er;
        }
        let stats;
        try {
          stats = options2.statSync(p);
        } catch (er3) {
          if (er3.code === "ENOENT")
            return;
          else
            throw er;
        }
        if (stats.isDirectory())
          rmdirSync(p, options2, er);
        else
          options2.unlinkSync(p);
      }, "fixWinEPERMSync");
      var rmdir = /* @__PURE__ */ __name((p, options2, originalEr, cb) => {
        assert(p);
        assert(options2);
        assert(typeof cb === "function");
        options2.rmdir(p, (er) => {
          if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
            rmkids(p, options2, cb);
          else if (er && er.code === "ENOTDIR")
            cb(originalEr);
          else
            cb(er);
        });
      }, "rmdir");
      var rmkids = /* @__PURE__ */ __name((p, options2, cb) => {
        assert(p);
        assert(options2);
        assert(typeof cb === "function");
        options2.readdir(p, (er, files) => {
          if (er)
            return cb(er);
          let n = files.length;
          if (n === 0)
            return options2.rmdir(p, cb);
          let errState;
          files.forEach((f) => {
            rimraf(path22.join(p, f), options2, (er2) => {
              if (errState)
                return;
              if (er2)
                return cb(errState = er2);
              if (--n === 0)
                options2.rmdir(p, cb);
            });
          });
        });
      }, "rmkids");
      var rimrafSync = /* @__PURE__ */ __name((p, options2) => {
        options2 = options2 || {};
        defaults(options2);
        assert(p, "rimraf: missing path");
        assert.equal(typeof p, "string", "rimraf: path should be a string");
        assert(options2, "rimraf: missing options");
        assert.equal(typeof options2, "object", "rimraf: options should be object");
        let results;
        if (options2.disableGlob || !glob.hasMagic(p)) {
          results = [p];
        } else {
          try {
            options2.lstatSync(p);
            results = [p];
          } catch (er) {
            results = glob.sync(p, options2.glob);
          }
        }
        if (!results.length)
          return;
        for (let i = 0; i < results.length; i++) {
          const p2 = results[i];
          let st;
          try {
            st = options2.lstatSync(p2);
          } catch (er) {
            if (er.code === "ENOENT")
              return;
            if (er.code === "EPERM" && isWindows)
              fixWinEPERMSync(p2, options2, er);
          }
          try {
            if (st && st.isDirectory())
              rmdirSync(p2, options2, null);
            else
              options2.unlinkSync(p2);
          } catch (er) {
            if (er.code === "ENOENT")
              return;
            if (er.code === "EPERM")
              return isWindows ? fixWinEPERMSync(p2, options2, er) : rmdirSync(p2, options2, er);
            if (er.code !== "EISDIR")
              throw er;
            rmdirSync(p2, options2, er);
          }
        }
      }, "rimrafSync");
      var rmdirSync = /* @__PURE__ */ __name((p, options2, originalEr) => {
        assert(p);
        assert(options2);
        try {
          options2.rmdirSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "ENOTDIR")
            throw originalEr;
          if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
            rmkidsSync(p, options2);
        }
      }, "rmdirSync");
      var rmkidsSync = /* @__PURE__ */ __name((p, options2) => {
        assert(p);
        assert(options2);
        options2.readdirSync(p).forEach((f) => rimrafSync(path22.join(p, f), options2));
        const retries = isWindows ? 100 : 1;
        let i = 0;
        do {
          let threw = true;
          try {
            const ret = options2.rmdirSync(p, options2);
            threw = false;
            return ret;
          } finally {
            if (++i < retries && threw)
              continue;
          }
        } while (true);
      }, "rmkidsSync");
      module2.exports = rimraf;
      rimraf.sync = rimrafSync;
    });
    var require_cleanupCache = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.cleanupCache = void 0;
      var fs_12 = __importDefault2(__require("fs"));
      var path_12 = __importDefault2(__require("path"));
      var util_12 = require_util2();
      var rimraf_1 = __importDefault2(require_rimraf());
      var util_22 = __require("util");
      var p_map_1 = __importDefault2(require_p_map());
      var debug_12 = __importDefault2(require_dist());
      var debug32 = (0, debug_12.default)("cleanupCache");
      var del = (0, util_22.promisify)(rimraf_1.default);
      var readdir = (0, util_22.promisify)(fs_12.default.readdir);
      var stat = (0, util_22.promisify)(fs_12.default.stat);
      async function cleanupCache(n = 5) {
        try {
          const rootCacheDir = await (0, util_12.getRootCacheDir)();
          if (!rootCacheDir) {
            debug32("no rootCacheDir found");
            return;
          }
          const channel2 = "master";
          const cacheDir = path_12.default.join(rootCacheDir, channel2);
          const dirs = await readdir(cacheDir);
          const dirsWithMeta = await Promise.all(dirs.map(async (dirName) => {
            const dir2 = path_12.default.join(cacheDir, dirName);
            const statResult = await stat(dir2);
            return {
              dir: dir2,
              created: statResult.birthtime
            };
          }));
          dirsWithMeta.sort((a, b) => a.created < b.created ? 1 : -1);
          const dirsToRemove = dirsWithMeta.slice(n);
          await (0, p_map_1.default)(dirsToRemove, (dir2) => del(dir2.dir), { concurrency: 20 });
        } catch (e) {
        }
      }
      __name(cleanupCache, "cleanupCache");
      exports2.cleanupCache = cleanupCache;
    });
    var require_retry_operation = __commonJS((exports2, module2) => {
      function RetryOperation(timeouts, options2) {
        if (typeof options2 === "boolean") {
          options2 = { forever: options2 };
        }
        this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
        this._timeouts = timeouts;
        this._options = options2 || {};
        this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
        this._operationStart = null;
        if (this._options.forever) {
          this._cachedTimeouts = this._timeouts.slice(0);
        }
      }
      __name(RetryOperation, "RetryOperation");
      module2.exports = RetryOperation;
      RetryOperation.prototype.reset = function() {
        this._attempts = 1;
        this._timeouts = this._originalTimeouts;
      };
      RetryOperation.prototype.stop = function() {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        this._timeouts = [];
        this._cachedTimeouts = null;
      };
      RetryOperation.prototype.retry = function(err) {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (!err) {
          return false;
        }
        var currentTime = new Date().getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) {
          this._errors.unshift(new Error("RetryOperation timeout occurred"));
          return false;
        }
        this._errors.push(err);
        var timeout = this._timeouts.shift();
        if (timeout === void 0) {
          if (this._cachedTimeouts) {
            this._errors.splice(this._errors.length - 1, this._errors.length);
            this._timeouts = this._cachedTimeouts.slice(0);
            timeout = this._timeouts.shift();
          } else {
            return false;
          }
        }
        var self2 = this;
        var timer = setTimeout(function() {
          self2._attempts++;
          if (self2._operationTimeoutCb) {
            self2._timeout = setTimeout(function() {
              self2._operationTimeoutCb(self2._attempts);
            }, self2._operationTimeout);
            if (self2._options.unref) {
              self2._timeout.unref();
            }
          }
          self2._fn(self2._attempts);
        }, timeout);
        if (this._options.unref) {
          timer.unref();
        }
        return true;
      };
      RetryOperation.prototype.attempt = function(fn, timeoutOps) {
        this._fn = fn;
        if (timeoutOps) {
          if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
          }
          if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
          }
        }
        var self2 = this;
        if (this._operationTimeoutCb) {
          this._timeout = setTimeout(function() {
            self2._operationTimeoutCb();
          }, self2._operationTimeout);
        }
        this._operationStart = new Date().getTime();
        this._fn(this._attempts);
      };
      RetryOperation.prototype.try = function(fn) {
        console.log("Using RetryOperation.try() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = function(fn) {
        console.log("Using RetryOperation.start() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = RetryOperation.prototype.try;
      RetryOperation.prototype.errors = function() {
        return this._errors;
      };
      RetryOperation.prototype.attempts = function() {
        return this._attempts;
      };
      RetryOperation.prototype.mainError = function() {
        if (this._errors.length === 0) {
          return null;
        }
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        for (var i = 0; i < this._errors.length; i++) {
          var error2 = this._errors[i];
          var message = error2.message;
          var count = (counts[message] || 0) + 1;
          counts[message] = count;
          if (count >= mainErrorCount) {
            mainError = error2;
            mainErrorCount = count;
          }
        }
        return mainError;
      };
    });
    var require_retry = __commonJS((exports2) => {
      var RetryOperation = require_retry_operation();
      exports2.operation = function(options2) {
        var timeouts = exports2.timeouts(options2);
        return new RetryOperation(timeouts, {
          forever: options2 && options2.forever,
          unref: options2 && options2.unref,
          maxRetryTime: options2 && options2.maxRetryTime
        });
      };
      exports2.timeouts = function(options2) {
        if (options2 instanceof Array) {
          return [].concat(options2);
        }
        var opts2 = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: false
        };
        for (var key in options2) {
          opts2[key] = options2[key];
        }
        if (opts2.minTimeout > opts2.maxTimeout) {
          throw new Error("minTimeout is greater than maxTimeout");
        }
        var timeouts = [];
        for (var i = 0; i < opts2.retries; i++) {
          timeouts.push(this.createTimeout(i, opts2));
        }
        if (options2 && options2.forever && !timeouts.length) {
          timeouts.push(this.createTimeout(i, opts2));
        }
        timeouts.sort(function(a, b) {
          return a - b;
        });
        return timeouts;
      };
      exports2.createTimeout = function(attempt, opts2) {
        var random2 = opts2.randomize ? Math.random() + 1 : 1;
        var timeout = Math.round(random2 * opts2.minTimeout * Math.pow(opts2.factor, attempt));
        timeout = Math.min(timeout, opts2.maxTimeout);
        return timeout;
      };
      exports2.wrap = function(obj, options2, methods) {
        if (options2 instanceof Array) {
          methods = options2;
          options2 = null;
        }
        if (!methods) {
          methods = [];
          for (var key in obj) {
            if (typeof obj[key] === "function") {
              methods.push(key);
            }
          }
        }
        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];
          var original = obj[method];
          obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
            var op = exports2.operation(options2);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
              if (op.retry(err)) {
                return;
              }
              if (err) {
                arguments[0] = op.mainError();
              }
              callback.apply(this, arguments);
            });
            op.attempt(function() {
              original2.apply(obj, args);
            });
          }, "retryWrapper")).bind(obj, original);
          obj[method].options = options2;
        }
      };
    });
    var require_retry2 = __commonJS((exports2, module2) => {
      module2.exports = require_retry();
    });
    var require_p_retry = __commonJS((exports2, module2) => {
      "use strict";
      var retry = require_retry2();
      var networkErrorMsgs = [
        "Failed to fetch",
        "NetworkError when attempting to fetch resource",
        "The Internet connection appears to be offline"
      ];
      var AbortError = /* @__PURE__ */ __name(class extends Error {
        constructor(message) {
          super();
          if (message instanceof Error) {
            this.originalError = message;
            ({ message } = message);
          } else {
            this.originalError = new Error(message);
            this.originalError.stack = this.stack;
          }
          this.name = "AbortError";
          this.message = message;
        }
      }, "AbortError");
      var decorateErrorWithCounts = /* @__PURE__ */ __name((error2, attemptNumber, options2) => {
        const retriesLeft = options2.retries - (attemptNumber - 1);
        error2.attemptNumber = attemptNumber;
        error2.retriesLeft = retriesLeft;
        return error2;
      }, "decorateErrorWithCounts");
      var isNetworkError = /* @__PURE__ */ __name((errorMessage) => networkErrorMsgs.includes(errorMessage), "isNetworkError");
      var pRetry2 = /* @__PURE__ */ __name((input, options2) => new Promise((resolve2, reject2) => {
        options2 = {
          onFailedAttempt: () => {
          },
          retries: 10,
          ...options2
        };
        const operation = retry.operation(options2);
        operation.attempt(async (attemptNumber) => {
          try {
            resolve2(await input(attemptNumber));
          } catch (error2) {
            if (!(error2 instanceof Error)) {
              reject2(new TypeError(`Non-error was thrown: "${error2}". You should only throw errors.`));
              return;
            }
            if (error2 instanceof AbortError) {
              operation.stop();
              reject2(error2.originalError);
            } else if (error2 instanceof TypeError && !isNetworkError(error2.message)) {
              operation.stop();
              reject2(error2);
            } else {
              decorateErrorWithCounts(error2, attemptNumber, options2);
              try {
                await options2.onFailedAttempt(error2);
              } catch (error22) {
                reject2(error22);
                return;
              }
              if (!operation.retry(error2)) {
                reject2(operation.mainError());
              }
            }
          }
        });
      }), "pRetry");
      module2.exports = pRetry2;
      module2.exports.default = pRetry2;
      module2.exports.AbortError = AbortError;
    });
    var require_lib = __commonJS((exports2, module2) => {
      "use strict";
      var conversions = {};
      module2.exports = conversions;
      function sign2(x) {
        return x < 0 ? -1 : 1;
      }
      __name(sign2, "sign");
      function evenRound(x) {
        if (x % 1 === 0.5 && (x & 1) === 0) {
          return Math.floor(x);
        } else {
          return Math.round(x);
        }
      }
      __name(evenRound, "evenRound");
      function createNumberConversion(bitLength, typeOpts) {
        if (!typeOpts.unsigned) {
          --bitLength;
        }
        const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
        const upperBound = Math.pow(2, bitLength) - 1;
        const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
        const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
        return function(V, opts2) {
          if (!opts2)
            opts2 = {};
          let x = +V;
          if (opts2.enforceRange) {
            if (!Number.isFinite(x)) {
              throw new TypeError("Argument is not a finite number");
            }
            x = sign2(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
              throw new TypeError("Argument is not in byte range");
            }
            return x;
          }
          if (!isNaN(x) && opts2.clamp) {
            x = evenRound(x);
            if (x < lowerBound)
              x = lowerBound;
            if (x > upperBound)
              x = upperBound;
            return x;
          }
          if (!Number.isFinite(x) || x === 0) {
            return 0;
          }
          x = sign2(x) * Math.floor(Math.abs(x));
          x = x % moduloVal;
          if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
          } else if (typeOpts.unsigned) {
            if (x < 0) {
              x += moduloVal;
            } else if (x === -0) {
              return 0;
            }
          }
          return x;
        };
      }
      __name(createNumberConversion, "createNumberConversion");
      conversions["void"] = function() {
        return void 0;
      };
      conversions["boolean"] = function(val) {
        return !!val;
      };
      conversions["byte"] = createNumberConversion(8, { unsigned: false });
      conversions["octet"] = createNumberConversion(8, { unsigned: true });
      conversions["short"] = createNumberConversion(16, { unsigned: false });
      conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
      conversions["long"] = createNumberConversion(32, { unsigned: false });
      conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
      conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
      conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
      conversions["double"] = function(V) {
        const x = +V;
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite floating-point value");
        }
        return x;
      };
      conversions["unrestricted double"] = function(V) {
        const x = +V;
        if (isNaN(x)) {
          throw new TypeError("Argument is NaN");
        }
        return x;
      };
      conversions["float"] = conversions["double"];
      conversions["unrestricted float"] = conversions["unrestricted double"];
      conversions["DOMString"] = function(V, opts2) {
        if (!opts2)
          opts2 = {};
        if (opts2.treatNullAsEmptyString && V === null) {
          return "";
        }
        return String(V);
      };
      conversions["ByteString"] = function(V, opts2) {
        const x = String(V);
        let c = void 0;
        for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
          if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
          }
        }
        return x;
      };
      conversions["USVString"] = function(V) {
        const S = String(V);
        const n = S.length;
        const U = [];
        for (let i = 0; i < n; ++i) {
          const c = S.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            U.push(String.fromCodePoint(c));
          } else if (56320 <= c && c <= 57343) {
            U.push(String.fromCodePoint(65533));
          } else {
            if (i === n - 1) {
              U.push(String.fromCodePoint(65533));
            } else {
              const d = S.charCodeAt(i + 1);
              if (56320 <= d && d <= 57343) {
                const a = c & 1023;
                const b = d & 1023;
                U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                ++i;
              } else {
                U.push(String.fromCodePoint(65533));
              }
            }
          }
        }
        return U.join("");
      };
      conversions["Date"] = function(V, opts2) {
        if (!(V instanceof Date)) {
          throw new TypeError("Argument is not a Date object");
        }
        if (isNaN(V)) {
          return void 0;
        }
        return V;
      };
      conversions["RegExp"] = function(V, opts2) {
        if (!(V instanceof RegExp)) {
          V = new RegExp(V);
        }
        return V;
      };
    });
    var require_utils = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports.mixin = /* @__PURE__ */ __name(function mixin(target, source) {
        const keys2 = Object.getOwnPropertyNames(source);
        for (let i = 0; i < keys2.length; ++i) {
          Object.defineProperty(target, keys2[i], Object.getOwnPropertyDescriptor(source, keys2[i]));
        }
      }, "mixin");
      module2.exports.wrapperSymbol = Symbol("wrapper");
      module2.exports.implSymbol = Symbol("impl");
      module2.exports.wrapperForImpl = function(impl) {
        return impl[module2.exports.wrapperSymbol];
      };
      module2.exports.implForWrapper = function(wrapper) {
        return wrapper[module2.exports.implSymbol];
      };
    });
    var require_mappingTable = __commonJS((exports2, module2) => {
      module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
    });
    var require_tr46 = __commonJS((exports2, module2) => {
      "use strict";
      var punycode = __require("punycode");
      var mappingTable = require_mappingTable();
      var PROCESSING_OPTIONS = {
        TRANSITIONAL: 0,
        NONTRANSITIONAL: 1
      };
      function normalize(str) {
        return str.split("\0").map(function(s) {
          return s.normalize("NFC");
        }).join("\0");
      }
      __name(normalize, "normalize");
      function findStatus(val) {
        var start = 0;
        var end = mappingTable.length - 1;
        while (start <= end) {
          var mid = Math.floor((start + end) / 2);
          var target = mappingTable[mid];
          if (target[0][0] <= val && target[0][1] >= val) {
            return target;
          } else if (target[0][0] > val) {
            end = mid - 1;
          } else {
            start = mid + 1;
          }
        }
        return null;
      }
      __name(findStatus, "findStatus");
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      function countSymbols(string) {
        return string.replace(regexAstralSymbols, "_").length;
      }
      __name(countSymbols, "countSymbols");
      function mapChars(domain_name, useSTD3, processing_option) {
        var hasError = false;
        var processed = "";
        var len = countSymbols(domain_name);
        for (var i = 0; i < len; ++i) {
          var codePoint = domain_name.codePointAt(i);
          var status = findStatus(codePoint);
          switch (status[1]) {
            case "disallowed":
              hasError = true;
              processed += String.fromCodePoint(codePoint);
              break;
            case "ignored":
              break;
            case "mapped":
              processed += String.fromCodePoint.apply(String, status[2]);
              break;
            case "deviation":
              if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
                processed += String.fromCodePoint.apply(String, status[2]);
              } else {
                processed += String.fromCodePoint(codePoint);
              }
              break;
            case "valid":
              processed += String.fromCodePoint(codePoint);
              break;
            case "disallowed_STD3_mapped":
              if (useSTD3) {
                hasError = true;
                processed += String.fromCodePoint(codePoint);
              } else {
                processed += String.fromCodePoint.apply(String, status[2]);
              }
              break;
            case "disallowed_STD3_valid":
              if (useSTD3) {
                hasError = true;
              }
              processed += String.fromCodePoint(codePoint);
              break;
          }
        }
        return {
          string: processed,
          error: hasError
        };
      }
      __name(mapChars, "mapChars");
      var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
      function validateLabel(label, processing_option) {
        if (label.substr(0, 4) === "xn--") {
          label = punycode.toUnicode(label);
          processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
        }
        var error2 = false;
        if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
          error2 = true;
        }
        var len = countSymbols(label);
        for (var i = 0; i < len; ++i) {
          var status = findStatus(label.codePointAt(i));
          if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
            error2 = true;
            break;
          }
        }
        return {
          label,
          error: error2
        };
      }
      __name(validateLabel, "validateLabel");
      function processing(domain_name, useSTD3, processing_option) {
        var result = mapChars(domain_name, useSTD3, processing_option);
        result.string = normalize(result.string);
        var labels = result.string.split(".");
        for (var i = 0; i < labels.length; ++i) {
          try {
            var validation = validateLabel(labels[i]);
            labels[i] = validation.label;
            result.error = result.error || validation.error;
          } catch (e) {
            result.error = true;
          }
        }
        return {
          string: labels.join("."),
          error: result.error
        };
      }
      __name(processing, "processing");
      module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
        var result = processing(domain_name, useSTD3, processing_option);
        var labels = result.string.split(".");
        labels = labels.map(function(l) {
          try {
            return punycode.toASCII(l);
          } catch (e) {
            result.error = true;
            return l;
          }
        });
        if (verifyDnsLength) {
          var total = labels.slice(0, labels.length - 1).join(".").length;
          if (total.length > 253 || total.length === 0) {
            result.error = true;
          }
          for (var i = 0; i < labels.length; ++i) {
            if (labels.length > 63 || labels.length === 0) {
              result.error = true;
              break;
            }
          }
        }
        if (result.error)
          return null;
        return labels.join(".");
      };
      module2.exports.toUnicode = function(domain_name, useSTD3) {
        var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
        return {
          domain: result.string,
          error: result.error
        };
      };
      module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
    });
    var require_url_state_machine = __commonJS((exports2, module2) => {
      "use strict";
      var punycode = __require("punycode");
      var tr46 = require_tr46();
      var specialSchemes = {
        ftp: 21,
        file: null,
        gopher: 70,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var failure = Symbol("failure");
      function countSymbols(str) {
        return punycode.ucs2.decode(str).length;
      }
      __name(countSymbols, "countSymbols");
      function at(input, idx) {
        const c = input[idx];
        return isNaN(c) ? void 0 : String.fromCodePoint(c);
      }
      __name(at, "at");
      function isASCIIDigit(c) {
        return c >= 48 && c <= 57;
      }
      __name(isASCIIDigit, "isASCIIDigit");
      function isASCIIAlpha(c) {
        return c >= 65 && c <= 90 || c >= 97 && c <= 122;
      }
      __name(isASCIIAlpha, "isASCIIAlpha");
      function isASCIIAlphanumeric(c) {
        return isASCIIAlpha(c) || isASCIIDigit(c);
      }
      __name(isASCIIAlphanumeric, "isASCIIAlphanumeric");
      function isASCIIHex(c) {
        return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
      }
      __name(isASCIIHex, "isASCIIHex");
      function isSingleDot(buffer) {
        return buffer === "." || buffer.toLowerCase() === "%2e";
      }
      __name(isSingleDot, "isSingleDot");
      function isDoubleDot(buffer) {
        buffer = buffer.toLowerCase();
        return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
      }
      __name(isDoubleDot, "isDoubleDot");
      function isWindowsDriveLetterCodePoints(cp1, cp2) {
        return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
      }
      __name(isWindowsDriveLetterCodePoints, "isWindowsDriveLetterCodePoints");
      function isWindowsDriveLetterString(string) {
        return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
      }
      __name(isWindowsDriveLetterString, "isWindowsDriveLetterString");
      function isNormalizedWindowsDriveLetterString(string) {
        return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
      }
      __name(isNormalizedWindowsDriveLetterString, "isNormalizedWindowsDriveLetterString");
      function containsForbiddenHostCodePoint(string) {
        return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
      }
      __name(containsForbiddenHostCodePoint, "containsForbiddenHostCodePoint");
      function containsForbiddenHostCodePointExcludingPercent(string) {
        return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
      }
      __name(containsForbiddenHostCodePointExcludingPercent, "containsForbiddenHostCodePointExcludingPercent");
      function isSpecialScheme(scheme) {
        return specialSchemes[scheme] !== void 0;
      }
      __name(isSpecialScheme, "isSpecialScheme");
      function isSpecial(url2) {
        return isSpecialScheme(url2.scheme);
      }
      __name(isSpecial, "isSpecial");
      function defaultPort(scheme) {
        return specialSchemes[scheme];
      }
      __name(defaultPort, "defaultPort");
      function percentEncode(c) {
        let hex = c.toString(16).toUpperCase();
        if (hex.length === 1) {
          hex = "0" + hex;
        }
        return "%" + hex;
      }
      __name(percentEncode, "percentEncode");
      function utf8PercentEncode(c) {
        const buf = new Buffer(c);
        let str = "";
        for (let i = 0; i < buf.length; ++i) {
          str += percentEncode(buf[i]);
        }
        return str;
      }
      __name(utf8PercentEncode, "utf8PercentEncode");
      function utf8PercentDecode(str) {
        const input = new Buffer(str);
        const output = [];
        for (let i = 0; i < input.length; ++i) {
          if (input[i] !== 37) {
            output.push(input[i]);
          } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
            output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
            i += 2;
          } else {
            output.push(input[i]);
          }
        }
        return new Buffer(output).toString();
      }
      __name(utf8PercentDecode, "utf8PercentDecode");
      function isC0ControlPercentEncode(c) {
        return c <= 31 || c > 126;
      }
      __name(isC0ControlPercentEncode, "isC0ControlPercentEncode");
      var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
      function isPathPercentEncode(c) {
        return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
      }
      __name(isPathPercentEncode, "isPathPercentEncode");
      var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
      function isUserinfoPercentEncode(c) {
        return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
      }
      __name(isUserinfoPercentEncode, "isUserinfoPercentEncode");
      function percentEncodeChar(c, encodeSetPredicate) {
        const cStr = String.fromCodePoint(c);
        if (encodeSetPredicate(c)) {
          return utf8PercentEncode(cStr);
        }
        return cStr;
      }
      __name(percentEncodeChar, "percentEncodeChar");
      function parseIPv4Number(input) {
        let R = 10;
        if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
          input = input.substring(2);
          R = 16;
        } else if (input.length >= 2 && input.charAt(0) === "0") {
          input = input.substring(1);
          R = 8;
        }
        if (input === "") {
          return 0;
        }
        const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
        if (regex.test(input)) {
          return failure;
        }
        return parseInt(input, R);
      }
      __name(parseIPv4Number, "parseIPv4Number");
      function parseIPv4(input) {
        const parts = input.split(".");
        if (parts[parts.length - 1] === "") {
          if (parts.length > 1) {
            parts.pop();
          }
        }
        if (parts.length > 4) {
          return input;
        }
        const numbers = [];
        for (const part of parts) {
          if (part === "") {
            return input;
          }
          const n = parseIPv4Number(part);
          if (n === failure) {
            return input;
          }
          numbers.push(n);
        }
        for (let i = 0; i < numbers.length - 1; ++i) {
          if (numbers[i] > 255) {
            return failure;
          }
        }
        if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
          return failure;
        }
        let ipv4 = numbers.pop();
        let counter = 0;
        for (const n of numbers) {
          ipv4 += n * Math.pow(256, 3 - counter);
          ++counter;
        }
        return ipv4;
      }
      __name(parseIPv4, "parseIPv4");
      function serializeIPv4(address) {
        let output = "";
        let n = address;
        for (let i = 1; i <= 4; ++i) {
          output = String(n % 256) + output;
          if (i !== 4) {
            output = "." + output;
          }
          n = Math.floor(n / 256);
        }
        return output;
      }
      __name(serializeIPv4, "serializeIPv4");
      function parseIPv6(input) {
        const address = [0, 0, 0, 0, 0, 0, 0, 0];
        let pieceIndex = 0;
        let compress = null;
        let pointer = 0;
        input = punycode.ucs2.decode(input);
        if (input[pointer] === 58) {
          if (input[pointer + 1] !== 58) {
            return failure;
          }
          pointer += 2;
          ++pieceIndex;
          compress = pieceIndex;
        }
        while (pointer < input.length) {
          if (pieceIndex === 8) {
            return failure;
          }
          if (input[pointer] === 58) {
            if (compress !== null) {
              return failure;
            }
            ++pointer;
            ++pieceIndex;
            compress = pieceIndex;
            continue;
          }
          let value = 0;
          let length = 0;
          while (length < 4 && isASCIIHex(input[pointer])) {
            value = value * 16 + parseInt(at(input, pointer), 16);
            ++pointer;
            ++length;
          }
          if (input[pointer] === 46) {
            if (length === 0) {
              return failure;
            }
            pointer -= length;
            if (pieceIndex > 6) {
              return failure;
            }
            let numbersSeen = 0;
            while (input[pointer] !== void 0) {
              let ipv4Piece = null;
              if (numbersSeen > 0) {
                if (input[pointer] === 46 && numbersSeen < 4) {
                  ++pointer;
                } else {
                  return failure;
                }
              }
              if (!isASCIIDigit(input[pointer])) {
                return failure;
              }
              while (isASCIIDigit(input[pointer])) {
                const number = parseInt(at(input, pointer));
                if (ipv4Piece === null) {
                  ipv4Piece = number;
                } else if (ipv4Piece === 0) {
                  return failure;
                } else {
                  ipv4Piece = ipv4Piece * 10 + number;
                }
                if (ipv4Piece > 255) {
                  return failure;
                }
                ++pointer;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              ++numbersSeen;
              if (numbersSeen === 2 || numbersSeen === 4) {
                ++pieceIndex;
              }
            }
            if (numbersSeen !== 4) {
              return failure;
            }
            break;
          } else if (input[pointer] === 58) {
            ++pointer;
            if (input[pointer] === void 0) {
              return failure;
            }
          } else if (input[pointer] !== void 0) {
            return failure;
          }
          address[pieceIndex] = value;
          ++pieceIndex;
        }
        if (compress !== null) {
          let swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex !== 0 && swaps > 0) {
            const temp = address[compress + swaps - 1];
            address[compress + swaps - 1] = address[pieceIndex];
            address[pieceIndex] = temp;
            --pieceIndex;
            --swaps;
          }
        } else if (compress === null && pieceIndex !== 8) {
          return failure;
        }
        return address;
      }
      __name(parseIPv6, "parseIPv6");
      function serializeIPv6(address) {
        let output = "";
        const seqResult = findLongestZeroSequence(address);
        const compress = seqResult.idx;
        let ignore0 = false;
        for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
          if (ignore0 && address[pieceIndex] === 0) {
            continue;
          } else if (ignore0) {
            ignore0 = false;
          }
          if (compress === pieceIndex) {
            const separator = pieceIndex === 0 ? "::" : ":";
            output += separator;
            ignore0 = true;
            continue;
          }
          output += address[pieceIndex].toString(16);
          if (pieceIndex !== 7) {
            output += ":";
          }
        }
        return output;
      }
      __name(serializeIPv6, "serializeIPv6");
      function parseHost(input, isSpecialArg) {
        if (input[0] === "[") {
          if (input[input.length - 1] !== "]") {
            return failure;
          }
          return parseIPv6(input.substring(1, input.length - 1));
        }
        if (!isSpecialArg) {
          return parseOpaqueHost(input);
        }
        const domain = utf8PercentDecode(input);
        const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
        if (asciiDomain === null) {
          return failure;
        }
        if (containsForbiddenHostCodePoint(asciiDomain)) {
          return failure;
        }
        const ipv4Host = parseIPv4(asciiDomain);
        if (typeof ipv4Host === "number" || ipv4Host === failure) {
          return ipv4Host;
        }
        return asciiDomain;
      }
      __name(parseHost, "parseHost");
      function parseOpaqueHost(input) {
        if (containsForbiddenHostCodePointExcludingPercent(input)) {
          return failure;
        }
        let output = "";
        const decoded = punycode.ucs2.decode(input);
        for (let i = 0; i < decoded.length; ++i) {
          output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
        }
        return output;
      }
      __name(parseOpaqueHost, "parseOpaqueHost");
      function findLongestZeroSequence(arr) {
        let maxIdx = null;
        let maxLen = 1;
        let currStart = null;
        let currLen = 0;
        for (let i = 0; i < arr.length; ++i) {
          if (arr[i] !== 0) {
            if (currLen > maxLen) {
              maxIdx = currStart;
              maxLen = currLen;
            }
            currStart = null;
            currLen = 0;
          } else {
            if (currStart === null) {
              currStart = i;
            }
            ++currLen;
          }
        }
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        return {
          idx: maxIdx,
          len: maxLen
        };
      }
      __name(findLongestZeroSequence, "findLongestZeroSequence");
      function serializeHost(host) {
        if (typeof host === "number") {
          return serializeIPv4(host);
        }
        if (host instanceof Array) {
          return "[" + serializeIPv6(host) + "]";
        }
        return host;
      }
      __name(serializeHost, "serializeHost");
      function trimControlChars(url2) {
        return url2.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
      }
      __name(trimControlChars, "trimControlChars");
      function trimTabAndNewline(url2) {
        return url2.replace(/\u0009|\u000A|\u000D/g, "");
      }
      __name(trimTabAndNewline, "trimTabAndNewline");
      function shortenPath(url2) {
        const path22 = url2.path;
        if (path22.length === 0) {
          return;
        }
        if (url2.scheme === "file" && path22.length === 1 && isNormalizedWindowsDriveLetter(path22[0])) {
          return;
        }
        path22.pop();
      }
      __name(shortenPath, "shortenPath");
      function includesCredentials(url2) {
        return url2.username !== "" || url2.password !== "";
      }
      __name(includesCredentials, "includesCredentials");
      function cannotHaveAUsernamePasswordPort(url2) {
        return url2.host === null || url2.host === "" || url2.cannotBeABaseURL || url2.scheme === "file";
      }
      __name(cannotHaveAUsernamePasswordPort, "cannotHaveAUsernamePasswordPort");
      function isNormalizedWindowsDriveLetter(string) {
        return /^[A-Za-z]:$/.test(string);
      }
      __name(isNormalizedWindowsDriveLetter, "isNormalizedWindowsDriveLetter");
      function URLStateMachine(input, base, encodingOverride, url2, stateOverride) {
        this.pointer = 0;
        this.input = input;
        this.base = base || null;
        this.encodingOverride = encodingOverride || "utf-8";
        this.stateOverride = stateOverride;
        this.url = url2;
        this.failure = false;
        this.parseError = false;
        if (!this.url) {
          this.url = {
            scheme: "",
            username: "",
            password: "",
            host: null,
            port: null,
            path: [],
            query: null,
            fragment: null,
            cannotBeABaseURL: false
          };
          const res2 = trimControlChars(this.input);
          if (res2 !== this.input) {
            this.parseError = true;
          }
          this.input = res2;
        }
        const res = trimTabAndNewline(this.input);
        if (res !== this.input) {
          this.parseError = true;
        }
        this.input = res;
        this.state = stateOverride || "scheme start";
        this.buffer = "";
        this.atFlag = false;
        this.arrFlag = false;
        this.passwordTokenSeenFlag = false;
        this.input = punycode.ucs2.decode(this.input);
        for (; this.pointer <= this.input.length; ++this.pointer) {
          const c = this.input[this.pointer];
          const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
          const ret = this["parse " + this.state](c, cStr);
          if (!ret) {
            break;
          } else if (ret === failure) {
            this.failure = true;
            break;
          }
        }
      }
      __name(URLStateMachine, "URLStateMachine");
      URLStateMachine.prototype["parse scheme start"] = /* @__PURE__ */ __name(function parseSchemeStart(c, cStr) {
        if (isASCIIAlpha(c)) {
          this.buffer += cStr.toLowerCase();
          this.state = "scheme";
        } else if (!this.stateOverride) {
          this.state = "no scheme";
          --this.pointer;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      }, "parseSchemeStart");
      URLStateMachine.prototype["parse scheme"] = /* @__PURE__ */ __name(function parseScheme(c, cStr) {
        if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
          this.buffer += cStr.toLowerCase();
        } else if (c === 58) {
          if (this.stateOverride) {
            if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
              return false;
            }
            if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
              return false;
            }
            if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
              return false;
            }
            if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
              return false;
            }
          }
          this.url.scheme = this.buffer;
          this.buffer = "";
          if (this.stateOverride) {
            return false;
          }
          if (this.url.scheme === "file") {
            if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
              this.parseError = true;
            }
            this.state = "file";
          } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
            this.state = "special relative or authority";
          } else if (isSpecial(this.url)) {
            this.state = "special authority slashes";
          } else if (this.input[this.pointer + 1] === 47) {
            this.state = "path or authority";
            ++this.pointer;
          } else {
            this.url.cannotBeABaseURL = true;
            this.url.path.push("");
            this.state = "cannot-be-a-base-URL path";
          }
        } else if (!this.stateOverride) {
          this.buffer = "";
          this.state = "no scheme";
          this.pointer = -1;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      }, "parseScheme");
      URLStateMachine.prototype["parse no scheme"] = /* @__PURE__ */ __name(function parseNoScheme(c) {
        if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
          return failure;
        } else if (this.base.cannotBeABaseURL && c === 35) {
          this.url.scheme = this.base.scheme;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.url.cannotBeABaseURL = true;
          this.state = "fragment";
        } else if (this.base.scheme === "file") {
          this.state = "file";
          --this.pointer;
        } else {
          this.state = "relative";
          --this.pointer;
        }
        return true;
      }, "parseNoScheme");
      URLStateMachine.prototype["parse special relative or authority"] = /* @__PURE__ */ __name(function parseSpecialRelativeOrAuthority(c) {
        if (c === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "relative";
          --this.pointer;
        }
        return true;
      }, "parseSpecialRelativeOrAuthority");
      URLStateMachine.prototype["parse path or authority"] = /* @__PURE__ */ __name(function parsePathOrAuthority(c) {
        if (c === 47) {
          this.state = "authority";
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      }, "parsePathOrAuthority");
      URLStateMachine.prototype["parse relative"] = /* @__PURE__ */ __name(function parseRelative(c) {
        this.url.scheme = this.base.scheme;
        if (isNaN(c)) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 47) {
          this.state = "relative slash";
        } else if (c === 63) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
          this.state = "relative slash";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice(0, this.base.path.length - 1);
          this.state = "path";
          --this.pointer;
        }
        return true;
      }, "parseRelative");
      URLStateMachine.prototype["parse relative slash"] = /* @__PURE__ */ __name(function parseRelativeSlash(c) {
        if (isSpecial(this.url) && (c === 47 || c === 92)) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "special authority ignore slashes";
        } else if (c === 47) {
          this.state = "authority";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.state = "path";
          --this.pointer;
        }
        return true;
      }, "parseRelativeSlash");
      URLStateMachine.prototype["parse special authority slashes"] = /* @__PURE__ */ __name(function parseSpecialAuthoritySlashes(c) {
        if (c === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "special authority ignore slashes";
          --this.pointer;
        }
        return true;
      }, "parseSpecialAuthoritySlashes");
      URLStateMachine.prototype["parse special authority ignore slashes"] = /* @__PURE__ */ __name(function parseSpecialAuthorityIgnoreSlashes(c) {
        if (c !== 47 && c !== 92) {
          this.state = "authority";
          --this.pointer;
        } else {
          this.parseError = true;
        }
        return true;
      }, "parseSpecialAuthorityIgnoreSlashes");
      URLStateMachine.prototype["parse authority"] = /* @__PURE__ */ __name(function parseAuthority(c, cStr) {
        if (c === 64) {
          this.parseError = true;
          if (this.atFlag) {
            this.buffer = "%40" + this.buffer;
          }
          this.atFlag = true;
          const len = countSymbols(this.buffer);
          for (let pointer = 0; pointer < len; ++pointer) {
            const codePoint = this.buffer.codePointAt(pointer);
            if (codePoint === 58 && !this.passwordTokenSeenFlag) {
              this.passwordTokenSeenFlag = true;
              continue;
            }
            const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
            if (this.passwordTokenSeenFlag) {
              this.url.password += encodedCodePoints;
            } else {
              this.url.username += encodedCodePoints;
            }
          }
          this.buffer = "";
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
          if (this.atFlag && this.buffer === "") {
            this.parseError = true;
            return failure;
          }
          this.pointer -= countSymbols(this.buffer) + 1;
          this.buffer = "";
          this.state = "host";
        } else {
          this.buffer += cStr;
        }
        return true;
      }, "parseAuthority");
      URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = /* @__PURE__ */ __name(function parseHostName(c, cStr) {
        if (this.stateOverride && this.url.scheme === "file") {
          --this.pointer;
          this.state = "file host";
        } else if (c === 58 && !this.arrFlag) {
          if (this.buffer === "") {
            this.parseError = true;
            return failure;
          }
          const host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          this.url.host = host;
          this.buffer = "";
          this.state = "port";
          if (this.stateOverride === "hostname") {
            return false;
          }
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
          --this.pointer;
          if (isSpecial(this.url) && this.buffer === "") {
            this.parseError = true;
            return failure;
          } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
            this.parseError = true;
            return false;
          }
          const host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          this.url.host = host;
          this.buffer = "";
          this.state = "path start";
          if (this.stateOverride) {
            return false;
          }
        } else {
          if (c === 91) {
            this.arrFlag = true;
          } else if (c === 93) {
            this.arrFlag = false;
          }
          this.buffer += cStr;
        }
        return true;
      }, "parseHostName");
      URLStateMachine.prototype["parse port"] = /* @__PURE__ */ __name(function parsePort(c, cStr) {
        if (isASCIIDigit(c)) {
          this.buffer += cStr;
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
          if (this.buffer !== "") {
            const port = parseInt(this.buffer);
            if (port > Math.pow(2, 16) - 1) {
              this.parseError = true;
              return failure;
            }
            this.url.port = port === defaultPort(this.url.scheme) ? null : port;
            this.buffer = "";
          }
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
          --this.pointer;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      }, "parsePort");
      var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
      URLStateMachine.prototype["parse file"] = /* @__PURE__ */ __name(function parseFile(c) {
        this.url.scheme = "file";
        if (c === 47 || c === 92) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "file slash";
        } else if (this.base !== null && this.base.scheme === "file") {
          if (isNaN(c)) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
          } else if (c === 63) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = "";
            this.state = "query";
          } else if (c === 35) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
            this.url.fragment = "";
            this.state = "fragment";
          } else {
            if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
              this.url.host = this.base.host;
              this.url.path = this.base.path.slice();
              shortenPath(this.url);
            } else {
              this.parseError = true;
            }
            this.state = "path";
            --this.pointer;
          }
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      }, "parseFile");
      URLStateMachine.prototype["parse file slash"] = /* @__PURE__ */ __name(function parseFileSlash(c) {
        if (c === 47 || c === 92) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "file host";
        } else {
          if (this.base !== null && this.base.scheme === "file") {
            if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
              this.url.path.push(this.base.path[0]);
            } else {
              this.url.host = this.base.host;
            }
          }
          this.state = "path";
          --this.pointer;
        }
        return true;
      }, "parseFileSlash");
      URLStateMachine.prototype["parse file host"] = /* @__PURE__ */ __name(function parseFileHost(c, cStr) {
        if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
          --this.pointer;
          if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
            this.parseError = true;
            this.state = "path";
          } else if (this.buffer === "") {
            this.url.host = "";
            if (this.stateOverride) {
              return false;
            }
            this.state = "path start";
          } else {
            let host = parseHost(this.buffer, isSpecial(this.url));
            if (host === failure) {
              return failure;
            }
            if (host === "localhost") {
              host = "";
            }
            this.url.host = host;
            if (this.stateOverride) {
              return false;
            }
            this.buffer = "";
            this.state = "path start";
          }
        } else {
          this.buffer += cStr;
        }
        return true;
      }, "parseFileHost");
      URLStateMachine.prototype["parse path start"] = /* @__PURE__ */ __name(function parsePathStart(c) {
        if (isSpecial(this.url)) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "path";
          if (c !== 47 && c !== 92) {
            --this.pointer;
          }
        } else if (!this.stateOverride && c === 63) {
          this.url.query = "";
          this.state = "query";
        } else if (!this.stateOverride && c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (c !== void 0) {
          this.state = "path";
          if (c !== 47) {
            --this.pointer;
          }
        }
        return true;
      }, "parsePathStart");
      URLStateMachine.prototype["parse path"] = /* @__PURE__ */ __name(function parsePath(c) {
        if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
          if (isSpecial(this.url) && c === 92) {
            this.parseError = true;
          }
          if (isDoubleDot(this.buffer)) {
            shortenPath(this.url);
            if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
              this.url.path.push("");
            }
          } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          } else if (!isSingleDot(this.buffer)) {
            if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
              if (this.url.host !== "" && this.url.host !== null) {
                this.parseError = true;
                this.url.host = "";
              }
              this.buffer = this.buffer[0] + ":";
            }
            this.url.path.push(this.buffer);
          }
          this.buffer = "";
          if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
            while (this.url.path.length > 1 && this.url.path[0] === "") {
              this.parseError = true;
              this.url.path.shift();
            }
          }
          if (c === 63) {
            this.url.query = "";
            this.state = "query";
          }
          if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
          }
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.buffer += percentEncodeChar(c, isPathPercentEncode);
        }
        return true;
      }, "parsePath");
      URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = /* @__PURE__ */ __name(function parseCannotBeABaseURLPath(c) {
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (!isNaN(c) && c !== 37) {
            this.parseError = true;
          }
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          if (!isNaN(c)) {
            this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
          }
        }
        return true;
      }, "parseCannotBeABaseURLPath");
      URLStateMachine.prototype["parse query"] = /* @__PURE__ */ __name(function parseQuery(c, cStr) {
        if (isNaN(c) || !this.stateOverride && c === 35) {
          if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
            this.encodingOverride = "utf-8";
          }
          const buffer = new Buffer(this.buffer);
          for (let i = 0; i < buffer.length; ++i) {
            if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
              this.url.query += percentEncode(buffer[i]);
            } else {
              this.url.query += String.fromCodePoint(buffer[i]);
            }
          }
          this.buffer = "";
          if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
          }
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.buffer += cStr;
        }
        return true;
      }, "parseQuery");
      URLStateMachine.prototype["parse fragment"] = /* @__PURE__ */ __name(function parseFragment(c) {
        if (isNaN(c)) {
        } else if (c === 0) {
          this.parseError = true;
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
        }
        return true;
      }, "parseFragment");
      function serializeURL(url2, excludeFragment) {
        let output = url2.scheme + ":";
        if (url2.host !== null) {
          output += "//";
          if (url2.username !== "" || url2.password !== "") {
            output += url2.username;
            if (url2.password !== "") {
              output += ":" + url2.password;
            }
            output += "@";
          }
          output += serializeHost(url2.host);
          if (url2.port !== null) {
            output += ":" + url2.port;
          }
        } else if (url2.host === null && url2.scheme === "file") {
          output += "//";
        }
        if (url2.cannotBeABaseURL) {
          output += url2.path[0];
        } else {
          for (const string of url2.path) {
            output += "/" + string;
          }
        }
        if (url2.query !== null) {
          output += "?" + url2.query;
        }
        if (!excludeFragment && url2.fragment !== null) {
          output += "#" + url2.fragment;
        }
        return output;
      }
      __name(serializeURL, "serializeURL");
      function serializeOrigin(tuple) {
        let result = tuple.scheme + "://";
        result += serializeHost(tuple.host);
        if (tuple.port !== null) {
          result += ":" + tuple.port;
        }
        return result;
      }
      __name(serializeOrigin, "serializeOrigin");
      module2.exports.serializeURL = serializeURL;
      module2.exports.serializeURLOrigin = function(url2) {
        switch (url2.scheme) {
          case "blob":
            try {
              return module2.exports.serializeURLOrigin(module2.exports.parseURL(url2.path[0]));
            } catch (e) {
              return "null";
            }
          case "ftp":
          case "gopher":
          case "http":
          case "https":
          case "ws":
          case "wss":
            return serializeOrigin({
              scheme: url2.scheme,
              host: url2.host,
              port: url2.port
            });
          case "file":
            return "file://";
          default:
            return "null";
        }
      };
      module2.exports.basicURLParse = function(input, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        const usm = new URLStateMachine(input, options2.baseURL, options2.encodingOverride, options2.url, options2.stateOverride);
        if (usm.failure) {
          return "failure";
        }
        return usm.url;
      };
      module2.exports.setTheUsername = function(url2, username) {
        url2.username = "";
        const decoded = punycode.ucs2.decode(username);
        for (let i = 0; i < decoded.length; ++i) {
          url2.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        }
      };
      module2.exports.setThePassword = function(url2, password) {
        url2.password = "";
        const decoded = punycode.ucs2.decode(password);
        for (let i = 0; i < decoded.length; ++i) {
          url2.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        }
      };
      module2.exports.serializeHost = serializeHost;
      module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
      module2.exports.serializeInteger = function(integer) {
        return String(integer);
      };
      module2.exports.parseURL = function(input, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return module2.exports.basicURLParse(input, { baseURL: options2.baseURL, encodingOverride: options2.encodingOverride });
      };
    });
    var require_URL_impl = __commonJS((exports2) => {
      "use strict";
      var usm = require_url_state_machine();
      exports2.implementation = /* @__PURE__ */ __name(class URLImpl {
        constructor(constructorArgs) {
          const url2 = constructorArgs[0];
          const base = constructorArgs[1];
          let parsedBase = null;
          if (base !== void 0) {
            parsedBase = usm.basicURLParse(base);
            if (parsedBase === "failure") {
              throw new TypeError("Invalid base URL");
            }
          }
          const parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
          if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
          }
          this._url = parsedURL;
        }
        get href() {
          return usm.serializeURL(this._url);
        }
        set href(v) {
          const parsedURL = usm.basicURLParse(v);
          if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
          }
          this._url = parsedURL;
        }
        get origin() {
          return usm.serializeURLOrigin(this._url);
        }
        get protocol() {
          return this._url.scheme + ":";
        }
        set protocol(v) {
          usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
        }
        get username() {
          return this._url.username;
        }
        set username(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          usm.setTheUsername(this._url, v);
        }
        get password() {
          return this._url.password;
        }
        set password(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          usm.setThePassword(this._url, v);
        }
        get host() {
          const url2 = this._url;
          if (url2.host === null) {
            return "";
          }
          if (url2.port === null) {
            return usm.serializeHost(url2.host);
          }
          return usm.serializeHost(url2.host) + ":" + usm.serializeInteger(url2.port);
        }
        set host(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
        }
        get hostname() {
          if (this._url.host === null) {
            return "";
          }
          return usm.serializeHost(this._url.host);
        }
        set hostname(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
        }
        get port() {
          if (this._url.port === null) {
            return "";
          }
          return usm.serializeInteger(this._url.port);
        }
        set port(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          if (v === "") {
            this._url.port = null;
          } else {
            usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
          }
        }
        get pathname() {
          if (this._url.cannotBeABaseURL) {
            return this._url.path[0];
          }
          if (this._url.path.length === 0) {
            return "";
          }
          return "/" + this._url.path.join("/");
        }
        set pathname(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          this._url.path = [];
          usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
        }
        get search() {
          if (this._url.query === null || this._url.query === "") {
            return "";
          }
          return "?" + this._url.query;
        }
        set search(v) {
          const url2 = this._url;
          if (v === "") {
            url2.query = null;
            return;
          }
          const input = v[0] === "?" ? v.substring(1) : v;
          url2.query = "";
          usm.basicURLParse(input, { url: url2, stateOverride: "query" });
        }
        get hash() {
          if (this._url.fragment === null || this._url.fragment === "") {
            return "";
          }
          return "#" + this._url.fragment;
        }
        set hash(v) {
          if (v === "") {
            this._url.fragment = null;
            return;
          }
          const input = v[0] === "#" ? v.substring(1) : v;
          this._url.fragment = "";
          usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
        }
        toJSON() {
          return this.href;
        }
      }, "URLImpl");
    });
    var require_URL = __commonJS((exports2, module2) => {
      "use strict";
      var conversions = require_lib();
      var utils = require_utils();
      var Impl = require_URL_impl();
      var impl = utils.implSymbol;
      function URL3(url2) {
        if (!this || this[impl] || !(this instanceof URL3)) {
          throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
        }
        if (arguments.length < 1) {
          throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
        }
        const args = [];
        for (let i = 0; i < arguments.length && i < 2; ++i) {
          args[i] = arguments[i];
        }
        args[0] = conversions["USVString"](args[0]);
        if (args[1] !== void 0) {
          args[1] = conversions["USVString"](args[1]);
        }
        module2.exports.setup(this, args);
      }
      __name(URL3, "URL");
      URL3.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        if (!this || !module2.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        const args = [];
        for (let i = 0; i < arguments.length && i < 0; ++i) {
          args[i] = arguments[i];
        }
        return this[impl].toJSON.apply(this[impl], args);
      }, "toJSON");
      Object.defineProperty(URL3.prototype, "href", {
        get() {
          return this[impl].href;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].href = V;
        },
        enumerable: true,
        configurable: true
      });
      URL3.prototype.toString = function() {
        if (!this || !module2.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this.href;
      };
      Object.defineProperty(URL3.prototype, "origin", {
        get() {
          return this[impl].origin;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "protocol", {
        get() {
          return this[impl].protocol;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].protocol = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "username", {
        get() {
          return this[impl].username;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].username = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "password", {
        get() {
          return this[impl].password;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].password = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "host", {
        get() {
          return this[impl].host;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].host = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "hostname", {
        get() {
          return this[impl].hostname;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].hostname = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "port", {
        get() {
          return this[impl].port;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].port = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "pathname", {
        get() {
          return this[impl].pathname;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].pathname = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "search", {
        get() {
          return this[impl].search;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].search = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "hash", {
        get() {
          return this[impl].hash;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].hash = V;
        },
        enumerable: true,
        configurable: true
      });
      module2.exports = {
        is(obj) {
          return !!obj && obj[impl] instanceof Impl.implementation;
        },
        create(constructorArgs, privateData) {
          let obj = Object.create(URL3.prototype);
          this.setup(obj, constructorArgs, privateData);
          return obj;
        },
        setup(obj, constructorArgs, privateData) {
          if (!privateData)
            privateData = {};
          privateData.wrapper = obj;
          obj[impl] = new Impl.implementation(constructorArgs, privateData);
          obj[impl][utils.wrapperSymbol] = obj;
        },
        interface: URL3,
        expose: {
          Window: { URL: URL3 },
          Worker: { URL: URL3 }
        }
      };
    });
    var require_public_api = __commonJS((exports2) => {
      "use strict";
      exports2.URL = require_URL().interface;
      exports2.serializeURL = require_url_state_machine().serializeURL;
      exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
      exports2.basicURLParse = require_url_state_machine().basicURLParse;
      exports2.setTheUsername = require_url_state_machine().setTheUsername;
      exports2.setThePassword = require_url_state_machine().setThePassword;
      exports2.serializeHost = require_url_state_machine().serializeHost;
      exports2.serializeInteger = require_url_state_machine().serializeInteger;
      exports2.parseURL = require_url_state_machine().parseURL;
    });
    var require_lib2 = __commonJS((exports2, module2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function _interopDefault(ex) {
        return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
      }
      __name(_interopDefault, "_interopDefault");
      var Stream = _interopDefault(__require("stream"));
      var http = _interopDefault(__require("http"));
      var Url = _interopDefault(__require("url"));
      var whatwgUrl = _interopDefault(require_public_api());
      var https2 = _interopDefault(__require("https"));
      var zlib = _interopDefault(__require("zlib"));
      var Readable = Stream.Readable;
      var BUFFER = Symbol("buffer");
      var TYPE = Symbol("type");
      var Blob = /* @__PURE__ */ __name(class {
        constructor() {
          this[TYPE] = "";
          const blobParts = arguments[0];
          const options2 = arguments[1];
          const buffers = [];
          let size = 0;
          if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for (let i = 0; i < length; i++) {
              const element = a[i];
              let buffer;
              if (element instanceof Buffer) {
                buffer = element;
              } else if (ArrayBuffer.isView(element)) {
                buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
              } else if (element instanceof ArrayBuffer) {
                buffer = Buffer.from(element);
              } else if (element instanceof Blob) {
                buffer = element[BUFFER];
              } else {
                buffer = Buffer.from(typeof element === "string" ? element : String(element));
              }
              size += buffer.length;
              buffers.push(buffer);
            }
          }
          this[BUFFER] = Buffer.concat(buffers);
          let type = options2 && options2.type !== void 0 && String(options2.type).toLowerCase();
          if (type && !/[^\u0020-\u007E]/.test(type)) {
            this[TYPE] = type;
          }
        }
        get size() {
          return this[BUFFER].length;
        }
        get type() {
          return this[TYPE];
        }
        text() {
          return Promise.resolve(this[BUFFER].toString());
        }
        arrayBuffer() {
          const buf = this[BUFFER];
          const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          return Promise.resolve(ab);
        }
        stream() {
          const readable = new Readable();
          readable._read = function() {
          };
          readable.push(this[BUFFER]);
          readable.push(null);
          return readable;
        }
        toString() {
          return "[object Blob]";
        }
        slice() {
          const size = this.size;
          const start = arguments[0];
          const end = arguments[1];
          let relativeStart, relativeEnd;
          if (start === void 0) {
            relativeStart = 0;
          } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
          } else {
            relativeStart = Math.min(start, size);
          }
          if (end === void 0) {
            relativeEnd = size;
          } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
          } else {
            relativeEnd = Math.min(end, size);
          }
          const span = Math.max(relativeEnd - relativeStart, 0);
          const buffer = this[BUFFER];
          const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
          const blob = new Blob([], { type: arguments[2] });
          blob[BUFFER] = slicedBuffer;
          return blob;
        }
      }, "Blob");
      Object.defineProperties(Blob.prototype, {
        size: { enumerable: true },
        type: { enumerable: true },
        slice: { enumerable: true }
      });
      Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
        value: "Blob",
        writable: false,
        enumerable: false,
        configurable: true
      });
      function FetchError(message, type, systemError) {
        Error.call(this, message);
        this.message = message;
        this.type = type;
        if (systemError) {
          this.code = this.errno = systemError.code;
        }
        Error.captureStackTrace(this, this.constructor);
      }
      __name(FetchError, "FetchError");
      FetchError.prototype = Object.create(Error.prototype);
      FetchError.prototype.constructor = FetchError;
      FetchError.prototype.name = "FetchError";
      var convert;
      try {
        convert = __require("encoding").convert;
      } catch (e) {
      }
      var INTERNALS = Symbol("Body internals");
      var PassThrough = Stream.PassThrough;
      function Body(body) {
        var _this = this;
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
        let size = _ref$size === void 0 ? 0 : _ref$size;
        var _ref$timeout = _ref.timeout;
        let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
        if (body == null) {
          body = null;
        } else if (isURLSearchParams(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof Stream)
          ;
        else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS] = {
          body,
          disturbed: false,
          error: null
        };
        this.size = size;
        this.timeout = timeout;
        if (body instanceof Stream) {
          body.on("error", function(err) {
            const error2 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
            _this[INTERNALS].error = error2;
          });
        }
      }
      __name(Body, "Body");
      Body.prototype = {
        get body() {
          return this[INTERNALS].body;
        },
        get bodyUsed() {
          return this[INTERNALS].disturbed;
        },
        arrayBuffer() {
          return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          });
        },
        blob() {
          let ct = this.headers && this.headers.get("content-type") || "";
          return consumeBody.call(this).then(function(buf) {
            return Object.assign(new Blob([], {
              type: ct.toLowerCase()
            }), {
              [BUFFER]: buf
            });
          });
        },
        json() {
          var _this2 = this;
          return consumeBody.call(this).then(function(buffer) {
            try {
              return JSON.parse(buffer.toString());
            } catch (err) {
              return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
            }
          });
        },
        text() {
          return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
          });
        },
        buffer() {
          return consumeBody.call(this);
        },
        textConverted() {
          var _this3 = this;
          return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
          });
        }
      };
      Object.defineProperties(Body.prototype, {
        body: { enumerable: true },
        bodyUsed: { enumerable: true },
        arrayBuffer: { enumerable: true },
        blob: { enumerable: true },
        json: { enumerable: true },
        text: { enumerable: true }
      });
      Body.mixIn = function(proto) {
        for (const name of Object.getOwnPropertyNames(Body.prototype)) {
          if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
          }
        }
      };
      function consumeBody() {
        var _this4 = this;
        if (this[INTERNALS].disturbed) {
          return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
        }
        this[INTERNALS].disturbed = true;
        if (this[INTERNALS].error) {
          return Body.Promise.reject(this[INTERNALS].error);
        }
        let body = this.body;
        if (body === null) {
          return Body.Promise.resolve(Buffer.alloc(0));
        }
        if (isBlob(body)) {
          body = body.stream();
        }
        if (Buffer.isBuffer(body)) {
          return Body.Promise.resolve(body);
        }
        if (!(body instanceof Stream)) {
          return Body.Promise.resolve(Buffer.alloc(0));
        }
        let accum = [];
        let accumBytes = 0;
        let abort = false;
        return new Body.Promise(function(resolve2, reject2) {
          let resTimeout;
          if (_this4.timeout) {
            resTimeout = setTimeout(function() {
              abort = true;
              reject2(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
            }, _this4.timeout);
          }
          body.on("error", function(err) {
            if (err.name === "AbortError") {
              abort = true;
              reject2(err);
            } else {
              reject2(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
            }
          });
          body.on("data", function(chunk) {
            if (abort || chunk === null) {
              return;
            }
            if (_this4.size && accumBytes + chunk.length > _this4.size) {
              abort = true;
              reject2(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
              return;
            }
            accumBytes += chunk.length;
            accum.push(chunk);
          });
          body.on("end", function() {
            if (abort) {
              return;
            }
            clearTimeout(resTimeout);
            try {
              resolve2(Buffer.concat(accum, accumBytes));
            } catch (err) {
              reject2(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
            }
          });
        });
      }
      __name(consumeBody, "consumeBody");
      function convertBody(buffer, headers) {
        if (typeof convert !== "function") {
          throw new Error("The package `encoding` must be installed to use the textConverted() function");
        }
        const ct = headers.get("content-type");
        let charset = "utf-8";
        let res, str;
        if (ct) {
          res = /charset=([^;]*)/i.exec(ct);
        }
        str = buffer.slice(0, 1024).toString();
        if (!res && str) {
          res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
        }
        if (!res && str) {
          res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
          if (!res) {
            res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
            if (res) {
              res.pop();
            }
          }
          if (res) {
            res = /charset=(.*)/i.exec(res.pop());
          }
        }
        if (!res && str) {
          res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
        }
        if (res) {
          charset = res.pop();
          if (charset === "gb2312" || charset === "gbk") {
            charset = "gb18030";
          }
        }
        return convert(buffer, "UTF-8", charset).toString();
      }
      __name(convertBody, "convertBody");
      function isURLSearchParams(obj) {
        if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
          return false;
        }
        return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
      }
      __name(isURLSearchParams, "isURLSearchParams");
      function isBlob(obj) {
        return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
      }
      __name(isBlob, "isBlob");
      function clone2(instance) {
        let p1, p2;
        let body = instance.body;
        if (instance.bodyUsed) {
          throw new Error("cannot clone body after it is used");
        }
        if (body instanceof Stream && typeof body.getBoundary !== "function") {
          p1 = new PassThrough();
          p2 = new PassThrough();
          body.pipe(p1);
          body.pipe(p2);
          instance[INTERNALS].body = p1;
          body = p2;
        }
        return body;
      }
      __name(clone2, "clone");
      function extractContentType(body) {
        if (body === null) {
          return null;
        } else if (typeof body === "string") {
          return "text/plain;charset=UTF-8";
        } else if (isURLSearchParams(body)) {
          return "application/x-www-form-urlencoded;charset=UTF-8";
        } else if (isBlob(body)) {
          return body.type || null;
        } else if (Buffer.isBuffer(body)) {
          return null;
        } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
          return null;
        } else if (ArrayBuffer.isView(body)) {
          return null;
        } else if (typeof body.getBoundary === "function") {
          return `multipart/form-data;boundary=${body.getBoundary()}`;
        } else if (body instanceof Stream) {
          return null;
        } else {
          return "text/plain;charset=UTF-8";
        }
      }
      __name(extractContentType, "extractContentType");
      function getTotalBytes(instance) {
        const body = instance.body;
        if (body === null) {
          return 0;
        } else if (isBlob(body)) {
          return body.size;
        } else if (Buffer.isBuffer(body)) {
          return body.length;
        } else if (body && typeof body.getLengthSync === "function") {
          if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
            return body.getLengthSync();
          }
          return null;
        } else {
          return null;
        }
      }
      __name(getTotalBytes, "getTotalBytes");
      function writeToStream(dest, instance) {
        const body = instance.body;
        if (body === null) {
          dest.end();
        } else if (isBlob(body)) {
          body.stream().pipe(dest);
        } else if (Buffer.isBuffer(body)) {
          dest.write(body);
          dest.end();
        } else {
          body.pipe(dest);
        }
      }
      __name(writeToStream, "writeToStream");
      Body.Promise = global.Promise;
      var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
      var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
      function validateName(name) {
        name = `${name}`;
        if (invalidTokenRegex.test(name) || name === "") {
          throw new TypeError(`${name} is not a legal HTTP header name`);
        }
      }
      __name(validateName, "validateName");
      function validateValue(value) {
        value = `${value}`;
        if (invalidHeaderCharRegex.test(value)) {
          throw new TypeError(`${value} is not a legal HTTP header value`);
        }
      }
      __name(validateValue, "validateValue");
      function find(map, name) {
        name = name.toLowerCase();
        for (const key in map) {
          if (key.toLowerCase() === name) {
            return key;
          }
        }
        return void 0;
      }
      __name(find, "find");
      var MAP = Symbol("map");
      var Headers = /* @__PURE__ */ __name(class {
        constructor() {
          let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          this[MAP] = Object.create(null);
          if (init instanceof Headers) {
            const rawHeaders = init.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames) {
              for (const value of rawHeaders[headerName]) {
                this.append(headerName, value);
              }
            }
            return;
          }
          if (init == null)
            ;
          else if (typeof init === "object") {
            const method = init[Symbol.iterator];
            if (method != null) {
              if (typeof method !== "function") {
                throw new TypeError("Header pairs must be iterable");
              }
              const pairs = [];
              for (const pair of init) {
                if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                  throw new TypeError("Each header pair must be iterable");
                }
                pairs.push(Array.from(pair));
              }
              for (const pair of pairs) {
                if (pair.length !== 2) {
                  throw new TypeError("Each header pair must be a name/value tuple");
                }
                this.append(pair[0], pair[1]);
              }
            } else {
              for (const key of Object.keys(init)) {
                const value = init[key];
                this.append(key, value);
              }
            }
          } else {
            throw new TypeError("Provided initializer must be an object");
          }
        }
        get(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key === void 0) {
            return null;
          }
          return this[MAP][key].join(", ");
        }
        forEach(callback) {
          let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
          let pairs = getHeaders(this);
          let i = 0;
          while (i < pairs.length) {
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
          }
        }
        set(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          this[MAP][key !== void 0 ? key : name] = [value];
        }
        append(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          if (key !== void 0) {
            this[MAP][key].push(value);
          } else {
            this[MAP][name] = [value];
          }
        }
        has(name) {
          name = `${name}`;
          validateName(name);
          return find(this[MAP], name) !== void 0;
        }
        delete(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key !== void 0) {
            delete this[MAP][key];
          }
        }
        raw() {
          return this[MAP];
        }
        keys() {
          return createHeadersIterator(this, "key");
        }
        values() {
          return createHeadersIterator(this, "value");
        }
        [Symbol.iterator]() {
          return createHeadersIterator(this, "key+value");
        }
      }, "Headers");
      Headers.prototype.entries = Headers.prototype[Symbol.iterator];
      Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
        value: "Headers",
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperties(Headers.prototype, {
        get: { enumerable: true },
        forEach: { enumerable: true },
        set: { enumerable: true },
        append: { enumerable: true },
        has: { enumerable: true },
        delete: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true }
      });
      function getHeaders(headers) {
        let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
        const keys2 = Object.keys(headers[MAP]).sort();
        return keys2.map(kind === "key" ? function(k) {
          return k.toLowerCase();
        } : kind === "value" ? function(k) {
          return headers[MAP][k].join(", ");
        } : function(k) {
          return [k.toLowerCase(), headers[MAP][k].join(", ")];
        });
      }
      __name(getHeaders, "getHeaders");
      var INTERNAL = Symbol("internal");
      function createHeadersIterator(target, kind) {
        const iterator = Object.create(HeadersIteratorPrototype);
        iterator[INTERNAL] = {
          target,
          kind,
          index: 0
        };
        return iterator;
      }
      __name(createHeadersIterator, "createHeadersIterator");
      var HeadersIteratorPrototype = Object.setPrototypeOf({
        next() {
          if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError("Value of `this` is not a HeadersIterator");
          }
          var _INTERNAL = this[INTERNAL];
          const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
          const values = getHeaders(target, kind);
          const len = values.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true
            };
          }
          this[INTERNAL].index = index + 1;
          return {
            value: values[index],
            done: false
          };
        }
      }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
      Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
        value: "HeadersIterator",
        writable: false,
        enumerable: false,
        configurable: true
      });
      function exportNodeCompatibleHeaders(headers) {
        const obj = Object.assign({ __proto__: null }, headers[MAP]);
        const hostHeaderKey = find(headers[MAP], "Host");
        if (hostHeaderKey !== void 0) {
          obj[hostHeaderKey] = obj[hostHeaderKey][0];
        }
        return obj;
      }
      __name(exportNodeCompatibleHeaders, "exportNodeCompatibleHeaders");
      function createHeadersLenient(obj) {
        const headers = new Headers();
        for (const name of Object.keys(obj)) {
          if (invalidTokenRegex.test(name)) {
            continue;
          }
          if (Array.isArray(obj[name])) {
            for (const val of obj[name]) {
              if (invalidHeaderCharRegex.test(val)) {
                continue;
              }
              if (headers[MAP][name] === void 0) {
                headers[MAP][name] = [val];
              } else {
                headers[MAP][name].push(val);
              }
            }
          } else if (!invalidHeaderCharRegex.test(obj[name])) {
            headers[MAP][name] = [obj[name]];
          }
        }
        return headers;
      }
      __name(createHeadersLenient, "createHeadersLenient");
      var INTERNALS$1 = Symbol("Response internals");
      var STATUS_CODES = http.STATUS_CODES;
      var Response = /* @__PURE__ */ __name(class {
        constructor() {
          let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          let opts2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          Body.call(this, body, opts2);
          const status = opts2.status || 200;
          const headers = new Headers(opts2.headers);
          if (body != null && !headers.has("Content-Type")) {
            const contentType = extractContentType(body);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          this[INTERNALS$1] = {
            url: opts2.url,
            status,
            statusText: opts2.statusText || STATUS_CODES[status],
            headers,
            counter: opts2.counter
          };
        }
        get url() {
          return this[INTERNALS$1].url || "";
        }
        get status() {
          return this[INTERNALS$1].status;
        }
        get ok() {
          return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
        }
        get redirected() {
          return this[INTERNALS$1].counter > 0;
        }
        get statusText() {
          return this[INTERNALS$1].statusText;
        }
        get headers() {
          return this[INTERNALS$1].headers;
        }
        clone() {
          return new Response(clone2(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
          });
        }
      }, "Response");
      Body.mixIn(Response.prototype);
      Object.defineProperties(Response.prototype, {
        url: { enumerable: true },
        status: { enumerable: true },
        ok: { enumerable: true },
        redirected: { enumerable: true },
        statusText: { enumerable: true },
        headers: { enumerable: true },
        clone: { enumerable: true }
      });
      Object.defineProperty(Response.prototype, Symbol.toStringTag, {
        value: "Response",
        writable: false,
        enumerable: false,
        configurable: true
      });
      var INTERNALS$2 = Symbol("Request internals");
      var URL3 = Url.URL || whatwgUrl.URL;
      var parse_url = Url.parse;
      var format_url = Url.format;
      function parseURL(urlStr) {
        if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
          urlStr = new URL3(urlStr).toString();
        }
        return parse_url(urlStr);
      }
      __name(parseURL, "parseURL");
      var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
      function isRequest(input) {
        return typeof input === "object" && typeof input[INTERNALS$2] === "object";
      }
      __name(isRequest, "isRequest");
      function isAbortSignal(signal) {
        const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
        return !!(proto && proto.constructor.name === "AbortSignal");
      }
      __name(isAbortSignal, "isAbortSignal");
      var Request = /* @__PURE__ */ __name(class {
        constructor(input) {
          let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          let parsedURL;
          if (!isRequest(input)) {
            if (input && input.href) {
              parsedURL = parseURL(input.href);
            } else {
              parsedURL = parseURL(`${input}`);
            }
            input = {};
          } else {
            parsedURL = parseURL(input.url);
          }
          let method = init.method || input.method || "GET";
          method = method.toUpperCase();
          if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
            throw new TypeError("Request with GET/HEAD method cannot have body");
          }
          let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone2(input) : null;
          Body.call(this, inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0
          });
          const headers = new Headers(init.headers || input.headers || {});
          if (inputBody != null && !headers.has("Content-Type")) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          let signal = isRequest(input) ? input.signal : null;
          if ("signal" in init)
            signal = init.signal;
          if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError("Expected signal to be an instanceof AbortSignal");
          }
          this[INTERNALS$2] = {
            method,
            redirect: init.redirect || input.redirect || "follow",
            headers,
            parsedURL,
            signal
          };
          this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
          this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
          this.counter = init.counter || input.counter || 0;
          this.agent = init.agent || input.agent;
        }
        get method() {
          return this[INTERNALS$2].method;
        }
        get url() {
          return format_url(this[INTERNALS$2].parsedURL);
        }
        get headers() {
          return this[INTERNALS$2].headers;
        }
        get redirect() {
          return this[INTERNALS$2].redirect;
        }
        get signal() {
          return this[INTERNALS$2].signal;
        }
        clone() {
          return new Request(this);
        }
      }, "Request");
      Body.mixIn(Request.prototype);
      Object.defineProperty(Request.prototype, Symbol.toStringTag, {
        value: "Request",
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperties(Request.prototype, {
        method: { enumerable: true },
        url: { enumerable: true },
        headers: { enumerable: true },
        redirect: { enumerable: true },
        clone: { enumerable: true },
        signal: { enumerable: true }
      });
      function getNodeRequestOptions(request4) {
        const parsedURL = request4[INTERNALS$2].parsedURL;
        const headers = new Headers(request4[INTERNALS$2].headers);
        if (!headers.has("Accept")) {
          headers.set("Accept", "*/*");
        }
        if (!parsedURL.protocol || !parsedURL.hostname) {
          throw new TypeError("Only absolute URLs are supported");
        }
        if (!/^https?:$/.test(parsedURL.protocol)) {
          throw new TypeError("Only HTTP(S) protocols are supported");
        }
        if (request4.signal && request4.body instanceof Stream.Readable && !streamDestructionSupported) {
          throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
        }
        let contentLengthValue = null;
        if (request4.body == null && /^(POST|PUT)$/i.test(request4.method)) {
          contentLengthValue = "0";
        }
        if (request4.body != null) {
          const totalBytes = getTotalBytes(request4);
          if (typeof totalBytes === "number") {
            contentLengthValue = String(totalBytes);
          }
        }
        if (contentLengthValue) {
          headers.set("Content-Length", contentLengthValue);
        }
        if (!headers.has("User-Agent")) {
          headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
        }
        if (request4.compress && !headers.has("Accept-Encoding")) {
          headers.set("Accept-Encoding", "gzip,deflate");
        }
        let agent = request4.agent;
        if (typeof agent === "function") {
          agent = agent(parsedURL);
        }
        if (!headers.has("Connection") && !agent) {
          headers.set("Connection", "close");
        }
        return Object.assign({}, parsedURL, {
          method: request4.method,
          headers: exportNodeCompatibleHeaders(headers),
          agent
        });
      }
      __name(getNodeRequestOptions, "getNodeRequestOptions");
      function AbortError(message) {
        Error.call(this, message);
        this.type = "aborted";
        this.message = message;
        Error.captureStackTrace(this, this.constructor);
      }
      __name(AbortError, "AbortError");
      AbortError.prototype = Object.create(Error.prototype);
      AbortError.prototype.constructor = AbortError;
      AbortError.prototype.name = "AbortError";
      var PassThrough$1 = Stream.PassThrough;
      var resolve_url = Url.resolve;
      function fetch2(url2, opts2) {
        if (!fetch2.Promise) {
          throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
        }
        Body.Promise = fetch2.Promise;
        return new fetch2.Promise(function(resolve2, reject2) {
          const request4 = new Request(url2, opts2);
          const options2 = getNodeRequestOptions(request4);
          const send = (options2.protocol === "https:" ? https2 : http).request;
          const signal = request4.signal;
          let response = null;
          const abort = /* @__PURE__ */ __name(function abort2() {
            let error2 = new AbortError("The user aborted a request.");
            reject2(error2);
            if (request4.body && request4.body instanceof Stream.Readable) {
              request4.body.destroy(error2);
            }
            if (!response || !response.body)
              return;
            response.body.emit("error", error2);
          }, "abort2");
          if (signal && signal.aborted) {
            abort();
            return;
          }
          const abortAndFinalize = /* @__PURE__ */ __name(function abortAndFinalize2() {
            abort();
            finalize();
          }, "abortAndFinalize2");
          const req = send(options2);
          let reqTimeout;
          if (signal) {
            signal.addEventListener("abort", abortAndFinalize);
          }
          function finalize() {
            req.abort();
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
            clearTimeout(reqTimeout);
          }
          __name(finalize, "finalize");
          if (request4.timeout) {
            req.once("socket", function(socket) {
              reqTimeout = setTimeout(function() {
                reject2(new FetchError(`network timeout at: ${request4.url}`, "request-timeout"));
                finalize();
              }, request4.timeout);
            });
          }
          req.on("error", function(err) {
            reject2(new FetchError(`request to ${request4.url} failed, reason: ${err.message}`, "system", err));
            finalize();
          });
          req.on("response", function(res) {
            clearTimeout(reqTimeout);
            const headers = createHeadersLenient(res.headers);
            if (fetch2.isRedirect(res.statusCode)) {
              const location = headers.get("Location");
              const locationURL = location === null ? null : resolve_url(request4.url, location);
              switch (request4.redirect) {
                case "error":
                  reject2(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request4.url}`, "no-redirect"));
                  finalize();
                  return;
                case "manual":
                  if (locationURL !== null) {
                    try {
                      headers.set("Location", locationURL);
                    } catch (err) {
                      reject2(err);
                    }
                  }
                  break;
                case "follow":
                  if (locationURL === null) {
                    break;
                  }
                  if (request4.counter >= request4.follow) {
                    reject2(new FetchError(`maximum redirect reached at: ${request4.url}`, "max-redirect"));
                    finalize();
                    return;
                  }
                  const requestOpts = {
                    headers: new Headers(request4.headers),
                    follow: request4.follow,
                    counter: request4.counter + 1,
                    agent: request4.agent,
                    compress: request4.compress,
                    method: request4.method,
                    body: request4.body,
                    signal: request4.signal,
                    timeout: request4.timeout,
                    size: request4.size
                  };
                  if (res.statusCode !== 303 && request4.body && getTotalBytes(request4) === null) {
                    reject2(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                    finalize();
                    return;
                  }
                  if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request4.method === "POST") {
                    requestOpts.method = "GET";
                    requestOpts.body = void 0;
                    requestOpts.headers.delete("content-length");
                  }
                  resolve2(fetch2(new Request(locationURL, requestOpts)));
                  finalize();
                  return;
              }
            }
            res.once("end", function() {
              if (signal)
                signal.removeEventListener("abort", abortAndFinalize);
            });
            let body = res.pipe(new PassThrough$1());
            const response_options = {
              url: request4.url,
              status: res.statusCode,
              statusText: res.statusMessage,
              headers,
              size: request4.size,
              timeout: request4.timeout,
              counter: request4.counter
            };
            const codings = headers.get("Content-Encoding");
            if (!request4.compress || request4.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
              response = new Response(body, response_options);
              resolve2(response);
              return;
            }
            const zlibOptions = {
              flush: zlib.Z_SYNC_FLUSH,
              finishFlush: zlib.Z_SYNC_FLUSH
            };
            if (codings == "gzip" || codings == "x-gzip") {
              body = body.pipe(zlib.createGunzip(zlibOptions));
              response = new Response(body, response_options);
              resolve2(response);
              return;
            }
            if (codings == "deflate" || codings == "x-deflate") {
              const raw2 = res.pipe(new PassThrough$1());
              raw2.once("data", function(chunk) {
                if ((chunk[0] & 15) === 8) {
                  body = body.pipe(zlib.createInflate());
                } else {
                  body = body.pipe(zlib.createInflateRaw());
                }
                response = new Response(body, response_options);
                resolve2(response);
              });
              return;
            }
            if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
              body = body.pipe(zlib.createBrotliDecompress());
              response = new Response(body, response_options);
              resolve2(response);
              return;
            }
            response = new Response(body, response_options);
            resolve2(response);
          });
          writeToStream(req, request4);
        });
      }
      __name(fetch2, "fetch");
      fetch2.isRedirect = function(code) {
        return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
      };
      fetch2.Promise = global.Promise;
      module2.exports = exports2 = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = exports2;
      exports2.Headers = Headers;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.FetchError = FetchError;
    });
    var require_common3 = __commonJS((exports2, module2) => {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        __name(selectColor, "selectColor");
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug32(...args) {
            if (!debug32.enabled) {
              return;
            }
            const self2 = debug32;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format2];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          __name(debug32, "debug3");
          debug32.namespace = namespace;
          debug32.useColors = createDebug.useColors();
          debug32.color = createDebug.selectColor(namespace);
          debug32.extend = extend;
          debug32.destroy = createDebug.destroy;
          Object.defineProperty(debug32, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug32);
          }
          return debug32;
        }
        __name(createDebug, "createDebug");
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        __name(extend, "extend");
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        __name(enable, "enable");
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        __name(disable, "disable");
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        __name(enabled, "enabled");
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        __name(toNamespace, "toNamespace");
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        __name(coerce, "coerce");
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        __name(destroy, "destroy");
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      __name(setup, "setup");
      module2.exports = setup;
    });
    var require_browser = __commonJS((exports2, module2) => {
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      __name(useColors, "useColors");
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      __name(formatArgs, "formatArgs");
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      __name(save, "save");
      function load() {
        let r;
        try {
          r = exports2.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      __name(load, "load");
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      __name(localstorage, "localstorage");
      module2.exports = require_common3()(exports2);
      var { formatters } = module2.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    });
    var require_node2 = __commonJS((exports2, module2) => {
      var tty = __require("tty");
      var util2 = __require("util");
      exports2.init = init;
      exports2.log = log4;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.destroy = util2.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      exports2.colors = [6, 2, 3, 4, 5, 1];
      try {
        const supportsColor = require_supports_color();
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports2.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
          ];
        }
      } catch (error2) {
      }
      exports2.inspectOpts = Object.keys(process.env).filter((key) => {
        return /^debug_/i.test(key);
      }).reduce((obj, key) => {
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
          return k.toUpperCase();
        });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }
      __name(useColors, "useColors");
      function formatArgs(args) {
        const { namespace: name, useColors: useColors2 } = this;
        if (useColors2) {
          const c = this.color;
          const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
          const prefix = `  ${colorCode};1m${name} [0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      __name(formatArgs, "formatArgs");
      function getDate() {
        if (exports2.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }
      __name(getDate, "getDate");
      function log4(...args) {
        return process.stderr.write(util2.format(...args) + "\n");
      }
      __name(log4, "log");
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      __name(save, "save");
      function load() {
        return process.env.DEBUG;
      }
      __name(load, "load");
      function init(debug32) {
        debug32.inspectOpts = {};
        const keys2 = Object.keys(exports2.inspectOpts);
        for (let i = 0; i < keys2.length; i++) {
          debug32.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
        }
      }
      __name(init, "init");
      module2.exports = require_common3()(exports2);
      var { formatters } = module2.exports;
      formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
      };
      formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v, this.inspectOpts);
      };
    });
    var require_src = __commonJS((exports2, module2) => {
      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module2.exports = require_browser();
      } else {
        module2.exports = require_node2();
      }
    });
    var require_promisify = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function promisify3(fn) {
        return function(req, opts2) {
          return new Promise((resolve2, reject2) => {
            fn.call(this, req, opts2, (err, rtn) => {
              if (err) {
                reject2(err);
              } else {
                resolve2(rtn);
              }
            });
          });
        };
      }
      __name(promisify3, "promisify");
      exports2.default = promisify3;
    });
    var require_src2 = __commonJS((exports2, module2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      var events_1 = __require("events");
      var debug_12 = __importDefault2(require_src());
      var promisify_1 = __importDefault2(require_promisify());
      var debug32 = debug_12.default("agent-base");
      function isAgent(v) {
        return Boolean(v) && typeof v.addRequest === "function";
      }
      __name(isAgent, "isAgent");
      function isSecureEndpoint() {
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      __name(isSecureEndpoint, "isSecureEndpoint");
      function createAgent(callback, opts2) {
        return new createAgent.Agent(callback, opts2);
      }
      __name(createAgent, "createAgent");
      (function(createAgent2) {
        class Agent2 extends events_1.EventEmitter {
          constructor(callback, _opts) {
            super();
            let opts2 = _opts;
            if (typeof callback === "function") {
              this.callback = callback;
            } else if (callback) {
              opts2 = callback;
            }
            this.timeout = null;
            if (opts2 && typeof opts2.timeout === "number") {
              this.timeout = opts2.timeout;
            }
            this.maxFreeSockets = 1;
            this.maxSockets = 1;
            this.maxTotalSockets = Infinity;
            this.sockets = {};
            this.freeSockets = {};
            this.requests = {};
            this.options = {};
          }
          get defaultPort() {
            if (typeof this.explicitDefaultPort === "number") {
              return this.explicitDefaultPort;
            }
            return isSecureEndpoint() ? 443 : 80;
          }
          set defaultPort(v) {
            this.explicitDefaultPort = v;
          }
          get protocol() {
            if (typeof this.explicitProtocol === "string") {
              return this.explicitProtocol;
            }
            return isSecureEndpoint() ? "https:" : "http:";
          }
          set protocol(v) {
            this.explicitProtocol = v;
          }
          callback(req, opts2, fn) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
          }
          addRequest(req, _opts) {
            const opts2 = Object.assign({}, _opts);
            if (typeof opts2.secureEndpoint !== "boolean") {
              opts2.secureEndpoint = isSecureEndpoint();
            }
            if (opts2.host == null) {
              opts2.host = "localhost";
            }
            if (opts2.port == null) {
              opts2.port = opts2.secureEndpoint ? 443 : 80;
            }
            if (opts2.protocol == null) {
              opts2.protocol = opts2.secureEndpoint ? "https:" : "http:";
            }
            if (opts2.host && opts2.path) {
              delete opts2.path;
            }
            delete opts2.agent;
            delete opts2.hostname;
            delete opts2._defaultAgent;
            delete opts2.defaultPort;
            delete opts2.createConnection;
            req._last = true;
            req.shouldKeepAlive = false;
            let timedOut = false;
            let timeoutId = null;
            const timeoutMs = opts2.timeout || this.timeout;
            const onerror = /* @__PURE__ */ __name((err) => {
              if (req._hadError)
                return;
              req.emit("error", err);
              req._hadError = true;
            }, "onerror");
            const ontimeout = /* @__PURE__ */ __name(() => {
              timeoutId = null;
              timedOut = true;
              const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
              err.code = "ETIMEOUT";
              onerror(err);
            }, "ontimeout");
            const callbackError = /* @__PURE__ */ __name((err) => {
              if (timedOut)
                return;
              if (timeoutId !== null) {
                clearTimeout(timeoutId);
                timeoutId = null;
              }
              onerror(err);
            }, "callbackError");
            const onsocket = /* @__PURE__ */ __name((socket) => {
              if (timedOut)
                return;
              if (timeoutId != null) {
                clearTimeout(timeoutId);
                timeoutId = null;
              }
              if (isAgent(socket)) {
                debug32("Callback returned another Agent instance %o", socket.constructor.name);
                socket.addRequest(req, opts2);
                return;
              }
              if (socket) {
                socket.once("free", () => {
                  this.freeSocket(socket, opts2);
                });
                req.onSocket(socket);
                return;
              }
              const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
              onerror(err);
            }, "onsocket");
            if (typeof this.callback !== "function") {
              onerror(new Error("`callback` is not defined"));
              return;
            }
            if (!this.promisifiedCallback) {
              if (this.callback.length >= 3) {
                debug32("Converting legacy callback function to promise");
                this.promisifiedCallback = promisify_1.default(this.callback);
              } else {
                this.promisifiedCallback = this.callback;
              }
            }
            if (typeof timeoutMs === "number" && timeoutMs > 0) {
              timeoutId = setTimeout(ontimeout, timeoutMs);
            }
            if ("port" in opts2 && typeof opts2.port !== "number") {
              opts2.port = Number(opts2.port);
            }
            try {
              debug32("Resolving socket for %o request: %o", opts2.protocol, `${req.method} ${req.path}`);
              Promise.resolve(this.promisifiedCallback(req, opts2)).then(onsocket, callbackError);
            } catch (err) {
              Promise.reject(err).catch(callbackError);
            }
          }
          freeSocket(socket, opts2) {
            debug32("Freeing socket %o %o", socket.constructor.name, opts2);
            socket.destroy();
          }
          destroy() {
            debug32("Destroying agent %o", this.constructor.name);
          }
        }
        __name(Agent2, "Agent");
        createAgent2.Agent = Agent2;
        createAgent2.prototype = createAgent2.Agent.prototype;
      })(createAgent || (createAgent = {}));
      module2.exports = createAgent;
    });
    var require_parse_proxy_response = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var debug_12 = __importDefault2(require_src());
      var debug32 = debug_12.default("https-proxy-agent:parse-proxy-response");
      function parseProxyResponse(socket) {
        return new Promise((resolve2, reject2) => {
          let buffersLength = 0;
          const buffers = [];
          function read() {
            const b = socket.read();
            if (b)
              ondata(b);
            else
              socket.once("readable", read);
          }
          __name(read, "read");
          function cleanup() {
            socket.removeListener("end", onend);
            socket.removeListener("error", onerror);
            socket.removeListener("close", onclose);
            socket.removeListener("readable", read);
          }
          __name(cleanup, "cleanup");
          function onclose(err) {
            debug32("onclose had error %o", err);
          }
          __name(onclose, "onclose");
          function onend() {
            debug32("onend");
          }
          __name(onend, "onend");
          function onerror(err) {
            cleanup();
            debug32("onerror %o", err);
            reject2(err);
          }
          __name(onerror, "onerror");
          function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf("\r\n\r\n");
            if (endOfHeaders === -1) {
              debug32("have not received end of HTTP headers yet...");
              read();
              return;
            }
            const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
            const statusCode = +firstLine.split(" ")[1];
            debug32("got proxy server response: %o", firstLine);
            resolve2({
              statusCode,
              buffered
            });
          }
          __name(ondata, "ondata");
          socket.on("error", onerror);
          socket.on("close", onclose);
          socket.on("end", onend);
          read();
        });
      }
      __name(parseProxyResponse, "parseProxyResponse");
      exports2.default = parseProxyResponse;
    });
    var require_agent = __commonJS((exports2) => {
      "use strict";
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve2) {
            resolve2(value);
          });
        }
        __name(adopt, "adopt");
        return new (P2 || (P2 = Promise))(function(resolve2, reject2) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject2(e);
            }
          }
          __name(fulfilled, "fulfilled");
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject2(e);
            }
          }
          __name(rejected, "rejected");
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          __name(step, "step");
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var net_1 = __importDefault2(__require("net"));
      var tls_1 = __importDefault2(__require("tls"));
      var url_1 = __importDefault2(__require("url"));
      var assert_1 = __importDefault2(__require("assert"));
      var debug_12 = __importDefault2(require_src());
      var agent_base_1 = require_src2();
      var parse_proxy_response_1 = __importDefault2(require_parse_proxy_response());
      var debug32 = debug_12.default("https-proxy-agent:agent");
      var HttpsProxyAgent = /* @__PURE__ */ __name(class extends agent_base_1.Agent {
        constructor(_opts) {
          let opts2;
          if (typeof _opts === "string") {
            opts2 = url_1.default.parse(_opts);
          } else {
            opts2 = _opts;
          }
          if (!opts2) {
            throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
          }
          debug32("creating new HttpsProxyAgent instance: %o", opts2);
          super(opts2);
          const proxy = Object.assign({}, opts2);
          this.secureProxy = opts2.secureProxy || isHTTPS(proxy.protocol);
          proxy.host = proxy.hostname || proxy.host;
          if (typeof proxy.port === "string") {
            proxy.port = parseInt(proxy.port, 10);
          }
          if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
          }
          if (this.secureProxy && !("ALPNProtocols" in proxy)) {
            proxy.ALPNProtocols = ["http 1.1"];
          }
          if (proxy.host && proxy.path) {
            delete proxy.path;
            delete proxy.pathname;
          }
          this.proxy = proxy;
        }
        callback(req, opts2) {
          return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            let socket;
            if (secureProxy) {
              debug32("Creating `tls.Socket`: %o", proxy);
              socket = tls_1.default.connect(proxy);
            } else {
              debug32("Creating `net.Socket`: %o", proxy);
              socket = net_1.default.connect(proxy);
            }
            const headers = Object.assign({}, proxy.headers);
            const hostname = `${opts2.host}:${opts2.port}`;
            let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
            if (proxy.auth) {
              headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
            }
            let { host, port, secureEndpoint } = opts2;
            if (!isDefaultPort(port, secureEndpoint)) {
              host += `:${port}`;
            }
            headers.Host = host;
            headers.Connection = "close";
            for (const name of Object.keys(headers)) {
              payload += `${name}: ${headers[name]}\r
`;
            }
            const proxyResponsePromise = parse_proxy_response_1.default(socket);
            socket.write(`${payload}\r
`);
            const { statusCode, buffered } = yield proxyResponsePromise;
            if (statusCode === 200) {
              req.once("socket", resume);
              if (opts2.secureEndpoint) {
                const servername = opts2.servername || opts2.host;
                if (!servername) {
                  throw new Error('Could not determine "servername"');
                }
                debug32("Upgrading socket connection to TLS");
                return tls_1.default.connect(Object.assign(Object.assign({}, omit3(opts2, "host", "hostname", "path", "port")), {
                  socket,
                  servername
                }));
              }
              return socket;
            }
            socket.destroy();
            const fakeSocket = new net_1.default.Socket();
            fakeSocket.readable = true;
            req.once("socket", (s) => {
              debug32("replaying proxy buffer for failed request");
              assert_1.default(s.listenerCount("data") > 0);
              s.push(buffered);
              s.push(null);
            });
            return fakeSocket;
          });
        }
      }, "HttpsProxyAgent");
      exports2.default = HttpsProxyAgent;
      function resume(socket) {
        socket.resume();
      }
      __name(resume, "resume");
      function isDefaultPort(port, secure) {
        return Boolean(!secure && port === 80 || secure && port === 443);
      }
      __name(isDefaultPort, "isDefaultPort");
      function isHTTPS(protocol) {
        return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
      }
      __name(isHTTPS, "isHTTPS");
      function omit3(obj, ...keys2) {
        const ret = {};
        let key;
        for (key in obj) {
          if (!keys2.includes(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      __name(omit3, "omit");
    });
    var require_dist3 = __commonJS((exports2, module2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      var agent_1 = __importDefault2(require_agent());
      function createHttpsProxyAgent(opts2) {
        return new agent_1.default(opts2);
      }
      __name(createHttpsProxyAgent, "createHttpsProxyAgent");
      (function(createHttpsProxyAgent2) {
        createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
        createHttpsProxyAgent2.prototype = agent_1.default.prototype;
      })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
      module2.exports = createHttpsProxyAgent;
    });
    var require_dist4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function once(emitter, name, { signal } = {}) {
        return new Promise((resolve2, reject2) => {
          function cleanup() {
            signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", cleanup);
            emitter.removeListener(name, onEvent);
            emitter.removeListener("error", onError);
          }
          __name(cleanup, "cleanup");
          function onEvent(...args) {
            cleanup();
            resolve2(args);
          }
          __name(onEvent, "onEvent");
          function onError(err) {
            cleanup();
            reject2(err);
          }
          __name(onError, "onError");
          signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", cleanup);
          emitter.on(name, onEvent);
          emitter.on("error", onError);
        });
      }
      __name(once, "once");
      exports2.default = once;
    });
    var require_agent2 = __commonJS((exports2) => {
      "use strict";
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve2) {
            resolve2(value);
          });
        }
        __name(adopt, "adopt");
        return new (P2 || (P2 = Promise))(function(resolve2, reject2) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject2(e);
            }
          }
          __name(fulfilled, "fulfilled");
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject2(e);
            }
          }
          __name(rejected, "rejected");
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          __name(step, "step");
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var net_1 = __importDefault2(__require("net"));
      var tls_1 = __importDefault2(__require("tls"));
      var url_1 = __importDefault2(__require("url"));
      var debug_12 = __importDefault2(require_src());
      var once_1 = __importDefault2(require_dist4());
      var agent_base_1 = require_src2();
      var debug32 = (0, debug_12.default)("http-proxy-agent");
      function isHTTPS(protocol) {
        return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
      }
      __name(isHTTPS, "isHTTPS");
      var HttpProxyAgent = /* @__PURE__ */ __name(class extends agent_base_1.Agent {
        constructor(_opts) {
          let opts2;
          if (typeof _opts === "string") {
            opts2 = url_1.default.parse(_opts);
          } else {
            opts2 = _opts;
          }
          if (!opts2) {
            throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
          }
          debug32("Creating new HttpProxyAgent instance: %o", opts2);
          super(opts2);
          const proxy = Object.assign({}, opts2);
          this.secureProxy = opts2.secureProxy || isHTTPS(proxy.protocol);
          proxy.host = proxy.hostname || proxy.host;
          if (typeof proxy.port === "string") {
            proxy.port = parseInt(proxy.port, 10);
          }
          if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
          }
          if (proxy.host && proxy.path) {
            delete proxy.path;
            delete proxy.pathname;
          }
          this.proxy = proxy;
        }
        callback(req, opts2) {
          return __awaiter(this, void 0, void 0, function* () {
            const { proxy, secureProxy } = this;
            const parsed = url_1.default.parse(req.path);
            if (!parsed.protocol) {
              parsed.protocol = "http:";
            }
            if (!parsed.hostname) {
              parsed.hostname = opts2.hostname || opts2.host || null;
            }
            if (parsed.port == null && typeof opts2.port) {
              parsed.port = String(opts2.port);
            }
            if (parsed.port === "80") {
              parsed.port = "";
            }
            req.path = url_1.default.format(parsed);
            if (proxy.auth) {
              req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
            }
            let socket;
            if (secureProxy) {
              debug32("Creating `tls.Socket`: %o", proxy);
              socket = tls_1.default.connect(proxy);
            } else {
              debug32("Creating `net.Socket`: %o", proxy);
              socket = net_1.default.connect(proxy);
            }
            if (req._header) {
              let first;
              let endOfHeaders;
              debug32("Regenerating stored HTTP header string for request");
              req._header = null;
              req._implicitHeader();
              if (req.output && req.output.length > 0) {
                debug32("Patching connection write() output buffer with updated header");
                first = req.output[0];
                endOfHeaders = first.indexOf("\r\n\r\n") + 4;
                req.output[0] = req._header + first.substring(endOfHeaders);
                debug32("Output buffer: %o", req.output);
              } else if (req.outputData && req.outputData.length > 0) {
                debug32("Patching connection write() output buffer with updated header");
                first = req.outputData[0].data;
                endOfHeaders = first.indexOf("\r\n\r\n") + 4;
                req.outputData[0].data = req._header + first.substring(endOfHeaders);
                debug32("Output buffer: %o", req.outputData[0].data);
              }
            }
            yield (0, once_1.default)(socket, "connect");
            return socket;
          });
        }
      }, "HttpProxyAgent");
      exports2.default = HttpProxyAgent;
    });
    var require_dist5 = __commonJS((exports2, module2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      var agent_1 = __importDefault2(require_agent2());
      function createHttpProxyAgent(opts2) {
        return new agent_1.default(opts2);
      }
      __name(createHttpProxyAgent, "createHttpProxyAgent");
      (function(createHttpProxyAgent2) {
        createHttpProxyAgent2.HttpProxyAgent = agent_1.default;
        createHttpProxyAgent2.prototype = agent_1.default.prototype;
      })(createHttpProxyAgent || (createHttpProxyAgent = {}));
      module2.exports = createHttpProxyAgent;
    });
    var require_getProxyAgent = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getProxyAgent = void 0;
      var https_proxy_agent_1 = __importDefault2(require_dist3());
      var http_proxy_agent_1 = __importDefault2(require_dist5());
      var url_1 = __importDefault2(__require("url"));
      function formatHostname(hostname) {
        return hostname.replace(/^\.*/, ".").toLowerCase();
      }
      __name(formatHostname, "formatHostname");
      function parseNoProxyZone(zone) {
        zone = zone.trim().toLowerCase();
        const zoneParts = zone.split(":", 2);
        const zoneHost = formatHostname(zoneParts[0]);
        const zonePort = zoneParts[1];
        const hasPort = zone.includes(":");
        return { hostname: zoneHost, port: zonePort, hasPort };
      }
      __name(parseNoProxyZone, "parseNoProxyZone");
      function uriInNoProxy(uri, noProxy) {
        const port = uri.port || (uri.protocol === "https:" ? "443" : "80");
        const hostname = formatHostname(uri.hostname);
        const noProxyList = noProxy.split(",");
        return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
          const isMatchedAt = hostname.indexOf(noProxyZone.hostname);
          const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
          if (noProxyZone.hasPort) {
            return port === noProxyZone.port && hostnameMatched;
          }
          return hostnameMatched;
        });
      }
      __name(uriInNoProxy, "uriInNoProxy");
      function getProxyFromURI(uri) {
        const noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
        if (noProxy === "*") {
          return null;
        }
        if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
          return null;
        }
        if (uri.protocol === "http:") {
          return process.env.HTTP_PROXY || process.env.http_proxy || null;
        }
        if (uri.protocol === "https:") {
          return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
        }
        return null;
      }
      __name(getProxyFromURI, "getProxyFromURI");
      function getProxyAgent(url2) {
        const uri = url_1.default.parse(url2);
        const proxy = getProxyFromURI(uri);
        if (!proxy) {
          return void 0;
        }
        if (uri.protocol === "http:") {
          return (0, http_proxy_agent_1.default)(proxy);
        }
        if (uri.protocol === "https:") {
          return (0, https_proxy_agent_1.default)(proxy);
        }
        return void 0;
      }
      __name(getProxyAgent, "getProxyAgent");
      exports2.getProxyAgent = getProxyAgent;
    });
    var require_crypto_random_string = __commonJS((exports2, module2) => {
      "use strict";
      var crypto3 = __require("crypto");
      module2.exports = (length) => {
        if (!Number.isFinite(length)) {
          throw new TypeError("Expected a finite number");
        }
        return crypto3.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
      };
    });
    var require_unique_string = __commonJS((exports2, module2) => {
      "use strict";
      var cryptoRandomString = require_crypto_random_string();
      module2.exports = () => cryptoRandomString(32);
    });
    var require_array_union = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = (...arguments_) => {
        return [...new Set([].concat(...arguments_))];
      };
    });
    var require_merge2 = __commonJS((exports2, module2) => {
      "use strict";
      var Stream = __require("stream");
      var PassThrough = Stream.PassThrough;
      var slice = Array.prototype.slice;
      module2.exports = merge2;
      function merge2() {
        const streamsQueue = [];
        const args = slice.call(arguments);
        let merging = false;
        let options2 = args[args.length - 1];
        if (options2 && !Array.isArray(options2) && options2.pipe == null) {
          args.pop();
        } else {
          options2 = {};
        }
        const doEnd = options2.end !== false;
        const doPipeError = options2.pipeError === true;
        if (options2.objectMode == null) {
          options2.objectMode = true;
        }
        if (options2.highWaterMark == null) {
          options2.highWaterMark = 64 * 1024;
        }
        const mergedStream = PassThrough(options2);
        function addStream() {
          for (let i = 0, len = arguments.length; i < len; i++) {
            streamsQueue.push(pauseStreams(arguments[i], options2));
          }
          mergeStream();
          return this;
        }
        __name(addStream, "addStream");
        function mergeStream() {
          if (merging) {
            return;
          }
          merging = true;
          let streams = streamsQueue.shift();
          if (!streams) {
            process.nextTick(endStream);
            return;
          }
          if (!Array.isArray(streams)) {
            streams = [streams];
          }
          let pipesCount = streams.length + 1;
          function next() {
            if (--pipesCount > 0) {
              return;
            }
            merging = false;
            mergeStream();
          }
          __name(next, "next");
          function pipe(stream3) {
            function onend() {
              stream3.removeListener("merge2UnpipeEnd", onend);
              stream3.removeListener("end", onend);
              if (doPipeError) {
                stream3.removeListener("error", onerror);
              }
              next();
            }
            __name(onend, "onend");
            function onerror(err) {
              mergedStream.emit("error", err);
            }
            __name(onerror, "onerror");
            if (stream3._readableState.endEmitted) {
              return next();
            }
            stream3.on("merge2UnpipeEnd", onend);
            stream3.on("end", onend);
            if (doPipeError) {
              stream3.on("error", onerror);
            }
            stream3.pipe(mergedStream, { end: false });
            stream3.resume();
          }
          __name(pipe, "pipe");
          for (let i = 0; i < streams.length; i++) {
            pipe(streams[i]);
          }
          next();
        }
        __name(mergeStream, "mergeStream");
        function endStream() {
          merging = false;
          mergedStream.emit("queueDrain");
          if (doEnd) {
            mergedStream.end();
          }
        }
        __name(endStream, "endStream");
        mergedStream.setMaxListeners(0);
        mergedStream.add = addStream;
        mergedStream.on("unpipe", function(stream3) {
          stream3.emit("merge2UnpipeEnd");
        });
        if (args.length) {
          addStream.apply(null, args);
        }
        return mergedStream;
      }
      __name(merge2, "merge2");
      function pauseStreams(streams, options2) {
        if (!Array.isArray(streams)) {
          if (!streams._readableState && streams.pipe) {
            streams = streams.pipe(PassThrough(options2));
          }
          if (!streams._readableState || !streams.pause || !streams.pipe) {
            throw new Error("Only readable stream can be merged.");
          }
          streams.pause();
        } else {
          for (let i = 0, len = streams.length; i < len; i++) {
            streams[i] = pauseStreams(streams[i], options2);
          }
        }
        return streams;
      }
      __name(pauseStreams, "pauseStreams");
    });
    var require_array = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.splitWhen = exports2.flatten = void 0;
      function flatten2(items) {
        return items.reduce((collection, item) => [].concat(collection, item), []);
      }
      __name(flatten2, "flatten");
      exports2.flatten = flatten2;
      function splitWhen(items, predicate) {
        const result = [[]];
        let groupIndex = 0;
        for (const item of items) {
          if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
          } else {
            result[groupIndex].push(item);
          }
        }
        return result;
      }
      __name(splitWhen, "splitWhen");
      exports2.splitWhen = splitWhen;
    });
    var require_errno = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isEnoentCodeError = void 0;
      function isEnoentCodeError(error2) {
        return error2.code === "ENOENT";
      }
      __name(isEnoentCodeError, "isEnoentCodeError");
      exports2.isEnoentCodeError = isEnoentCodeError;
    });
    var require_fs2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createDirentFromStats = void 0;
      var DirentFromStats = /* @__PURE__ */ __name(class {
        constructor(name, stats) {
          this.name = name;
          this.isBlockDevice = stats.isBlockDevice.bind(stats);
          this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
          this.isDirectory = stats.isDirectory.bind(stats);
          this.isFIFO = stats.isFIFO.bind(stats);
          this.isFile = stats.isFile.bind(stats);
          this.isSocket = stats.isSocket.bind(stats);
          this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
        }
      }, "DirentFromStats");
      function createDirentFromStats(name, stats) {
        return new DirentFromStats(name, stats);
      }
      __name(createDirentFromStats, "createDirentFromStats");
      exports2.createDirentFromStats = createDirentFromStats;
    });
    var require_path = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
      var path22 = __require("path");
      var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
      var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
      function unixify(filepath) {
        return filepath.replace(/\\/g, "/");
      }
      __name(unixify, "unixify");
      exports2.unixify = unixify;
      function makeAbsolute(cwd, filepath) {
        return path22.resolve(cwd, filepath);
      }
      __name(makeAbsolute, "makeAbsolute");
      exports2.makeAbsolute = makeAbsolute;
      function escape(pattern) {
        return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
      }
      __name(escape, "escape");
      exports2.escape = escape;
      function removeLeadingDotSegment(entry) {
        if (entry.charAt(0) === ".") {
          const secondCharactery = entry.charAt(1);
          if (secondCharactery === "/" || secondCharactery === "\\") {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
          }
        }
        return entry;
      }
      __name(removeLeadingDotSegment, "removeLeadingDotSegment");
      exports2.removeLeadingDotSegment = removeLeadingDotSegment;
    });
    var require_is_extglob = __commonJS((exports2, module2) => {
      module2.exports = /* @__PURE__ */ __name(function isExtglob(str) {
        if (typeof str !== "string" || str === "") {
          return false;
        }
        var match;
        while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
          if (match[2])
            return true;
          str = str.slice(match.index + match[0].length);
        }
        return false;
      }, "isExtglob");
    });
    var require_is_glob = __commonJS((exports2, module2) => {
      var isExtglob = require_is_extglob();
      var chars = { "{": "}", "(": ")", "[": "]" };
      var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
      var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
      module2.exports = /* @__PURE__ */ __name(function isGlob(str, options2) {
        if (typeof str !== "string" || str === "") {
          return false;
        }
        if (isExtglob(str)) {
          return true;
        }
        var regex = strictRegex;
        var match;
        if (options2 && options2.strict === false) {
          regex = relaxedRegex;
        }
        while (match = regex.exec(str)) {
          if (match[2])
            return true;
          var idx = match.index + match[0].length;
          var open = match[1];
          var close = open ? chars[open] : null;
          if (open && close) {
            var n = str.indexOf(close, idx);
            if (n !== -1) {
              idx = n + 1;
            }
          }
          str = str.slice(idx);
        }
        return false;
      }, "isGlob");
    });
    var require_glob_parent = __commonJS((exports2, module2) => {
      "use strict";
      var isGlob = require_is_glob();
      var pathPosixDirname = __require("path").posix.dirname;
      var isWin32 = __require("os").platform() === "win32";
      var slash = "/";
      var backslash = /\\/g;
      var escaped = /\\([!*?|[\](){}])/g;
      module2.exports = /* @__PURE__ */ __name(function globParent(str, opts2) {
        var options2 = Object.assign({ flipBackslashes: true }, opts2);
        if (options2.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
          str = str.replace(backslash, slash);
        }
        if (isEnclosure(str)) {
          str += slash;
        }
        str += "a";
        do {
          str = pathPosixDirname(str);
        } while (isGlobby(str));
        return str.replace(escaped, "$1");
      }, "globParent");
      function isEnclosure(str) {
        var lastChar = str.slice(-1);
        var enclosureStart;
        switch (lastChar) {
          case "}":
            enclosureStart = "{";
            break;
          case "]":
            enclosureStart = "[";
            break;
          default:
            return false;
        }
        var foundIndex = str.indexOf(enclosureStart);
        if (foundIndex < 0) {
          return false;
        }
        return str.slice(foundIndex + 1, -1).includes(slash);
      }
      __name(isEnclosure, "isEnclosure");
      function isGlobby(str) {
        if (/\([^()]+$/.test(str)) {
          return true;
        }
        if (str[0] === "{" || str[0] === "[") {
          return true;
        }
        if (/[^\\][{[]/.test(str)) {
          return true;
        }
        return isGlob(str);
      }
      __name(isGlobby, "isGlobby");
    });
    var require_utils2 = __commonJS((exports2) => {
      "use strict";
      exports2.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
      exports2.exceedsLimit = (min2, max2, step = 1, limit) => {
        if (limit === false)
          return false;
        if (!exports2.isInteger(min2) || !exports2.isInteger(max2))
          return false;
        return (Number(max2) - Number(min2)) / Number(step) >= limit;
      };
      exports2.escapeNode = (block, n = 0, type) => {
        let node = block.nodes[n];
        if (!node)
          return;
        if (type && node.type === type || node.type === "open" || node.type === "close") {
          if (node.escaped !== true) {
            node.value = "\\" + node.value;
            node.escaped = true;
          }
        }
      };
      exports2.encloseBrace = (node) => {
        if (node.type !== "brace")
          return false;
        if (node.commas >> 0 + node.ranges >> 0 === 0) {
          node.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isInvalidBrace = (block) => {
        if (block.type !== "brace")
          return false;
        if (block.invalid === true || block.dollar)
          return true;
        if (block.commas >> 0 + block.ranges >> 0 === 0) {
          block.invalid = true;
          return true;
        }
        if (block.open !== true || block.close !== true) {
          block.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isOpenOrClose = (node) => {
        if (node.type === "open" || node.type === "close") {
          return true;
        }
        return node.open === true || node.close === true;
      };
      exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
        if (node.type === "text")
          acc.push(node.value);
        if (node.type === "range")
          node.type = "text";
        return acc;
      }, []);
      exports2.flatten = (...args) => {
        const result = [];
        const flat = /* @__PURE__ */ __name((arr) => {
          for (let i = 0; i < arr.length; i++) {
            let ele = arr[i];
            Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
          }
          return result;
        }, "flat");
        flat(args);
        return result;
      };
    });
    var require_stringify = __commonJS((exports2, module2) => {
      "use strict";
      var utils = require_utils2();
      module2.exports = (ast, options2 = {}) => {
        let stringify2 = /* @__PURE__ */ __name((node, parent = {}) => {
          let invalidBlock = options2.escapeInvalid && utils.isInvalidBrace(parent);
          let invalidNode = node.invalid === true && options2.escapeInvalid === true;
          let output = "";
          if (node.value) {
            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
              return "\\" + node.value;
            }
            return node.value;
          }
          if (node.value) {
            return node.value;
          }
          if (node.nodes) {
            for (let child of node.nodes) {
              output += stringify2(child);
            }
          }
          return output;
        }, "stringify");
        return stringify2(ast);
      };
    });
    var require_is_number = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = function(num) {
        if (typeof num === "number") {
          return num - num === 0;
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
        }
        return false;
      };
    });
    var require_to_regex_range = __commonJS((exports2, module2) => {
      "use strict";
      var isNumber = require_is_number();
      var toRegexRange = /* @__PURE__ */ __name((min2, max2, options2) => {
        if (isNumber(min2) === false) {
          throw new TypeError("toRegexRange: expected the first argument to be a number");
        }
        if (max2 === void 0 || min2 === max2) {
          return String(min2);
        }
        if (isNumber(max2) === false) {
          throw new TypeError("toRegexRange: expected the second argument to be a number.");
        }
        let opts2 = { relaxZeros: true, ...options2 };
        if (typeof opts2.strictZeros === "boolean") {
          opts2.relaxZeros = opts2.strictZeros === false;
        }
        let relax = String(opts2.relaxZeros);
        let shorthand = String(opts2.shorthand);
        let capture = String(opts2.capture);
        let wrap = String(opts2.wrap);
        let cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap;
        if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
          return toRegexRange.cache[cacheKey].result;
        }
        let a = Math.min(min2, max2);
        let b = Math.max(min2, max2);
        if (Math.abs(a - b) === 1) {
          let result = min2 + "|" + max2;
          if (opts2.capture) {
            return `(${result})`;
          }
          if (opts2.wrap === false) {
            return result;
          }
          return `(?:${result})`;
        }
        let isPadded = hasPadding(min2) || hasPadding(max2);
        let state = { min: min2, max: max2, a, b };
        let positives = [];
        let negatives = [];
        if (isPadded) {
          state.isPadded = isPadded;
          state.maxLen = String(state.max).length;
        }
        if (a < 0) {
          let newMin = b < 0 ? Math.abs(b) : 1;
          negatives = splitToPatterns(newMin, Math.abs(a), state, opts2);
          a = state.a = 0;
        }
        if (b >= 0) {
          positives = splitToPatterns(a, b, state, opts2);
        }
        state.negatives = negatives;
        state.positives = positives;
        state.result = collatePatterns(negatives, positives, opts2);
        if (opts2.capture === true) {
          state.result = `(${state.result})`;
        } else if (opts2.wrap !== false && positives.length + negatives.length > 1) {
          state.result = `(?:${state.result})`;
        }
        toRegexRange.cache[cacheKey] = state;
        return state.result;
      }, "toRegexRange");
      function collatePatterns(neg, pos, options2) {
        let onlyNegative = filterPatterns(neg, pos, "-", false, options2) || [];
        let onlyPositive = filterPatterns(pos, neg, "", false, options2) || [];
        let intersected = filterPatterns(neg, pos, "-?", true, options2) || [];
        let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
        return subpatterns.join("|");
      }
      __name(collatePatterns, "collatePatterns");
      function splitToRanges(min2, max2) {
        let nines = 1;
        let zeros = 1;
        let stop = countNines(min2, nines);
        let stops = new Set([max2]);
        while (min2 <= stop && stop <= max2) {
          stops.add(stop);
          nines += 1;
          stop = countNines(min2, nines);
        }
        stop = countZeros(max2 + 1, zeros) - 1;
        while (min2 < stop && stop <= max2) {
          stops.add(stop);
          zeros += 1;
          stop = countZeros(max2 + 1, zeros) - 1;
        }
        stops = [...stops];
        stops.sort(compare);
        return stops;
      }
      __name(splitToRanges, "splitToRanges");
      function rangeToPattern(start, stop, options2) {
        if (start === stop) {
          return { pattern: start, count: [], digits: 0 };
        }
        let zipped = zip(start, stop);
        let digits = zipped.length;
        let pattern = "";
        let count = 0;
        for (let i = 0; i < digits; i++) {
          let [startDigit, stopDigit] = zipped[i];
          if (startDigit === stopDigit) {
            pattern += startDigit;
          } else if (startDigit !== "0" || stopDigit !== "9") {
            pattern += toCharacterClass(startDigit, stopDigit, options2);
          } else {
            count++;
          }
        }
        if (count) {
          pattern += options2.shorthand === true ? "\\d" : "[0-9]";
        }
        return { pattern, count: [count], digits };
      }
      __name(rangeToPattern, "rangeToPattern");
      function splitToPatterns(min2, max2, tok, options2) {
        let ranges = splitToRanges(min2, max2);
        let tokens = [];
        let start = min2;
        let prev;
        for (let i = 0; i < ranges.length; i++) {
          let max22 = ranges[i];
          let obj = rangeToPattern(String(start), String(max22), options2);
          let zeros = "";
          if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.count.length > 1) {
              prev.count.pop();
            }
            prev.count.push(obj.count[0]);
            prev.string = prev.pattern + toQuantifier(prev.count);
            start = max22 + 1;
            continue;
          }
          if (tok.isPadded) {
            zeros = padZeros(max22, tok, options2);
          }
          obj.string = zeros + obj.pattern + toQuantifier(obj.count);
          tokens.push(obj);
          start = max22 + 1;
          prev = obj;
        }
        return tokens;
      }
      __name(splitToPatterns, "splitToPatterns");
      function filterPatterns(arr, comparison, prefix, intersection, options2) {
        let result = [];
        for (let ele of arr) {
          let { string } = ele;
          if (!intersection && !contains(comparison, "string", string)) {
            result.push(prefix + string);
          }
          if (intersection && contains(comparison, "string", string)) {
            result.push(prefix + string);
          }
        }
        return result;
      }
      __name(filterPatterns, "filterPatterns");
      function zip(a, b) {
        let arr = [];
        for (let i = 0; i < a.length; i++)
          arr.push([a[i], b[i]]);
        return arr;
      }
      __name(zip, "zip");
      function compare(a, b) {
        return a > b ? 1 : b > a ? -1 : 0;
      }
      __name(compare, "compare");
      function contains(arr, key, val) {
        return arr.some((ele) => ele[key] === val);
      }
      __name(contains, "contains");
      function countNines(min2, len) {
        return Number(String(min2).slice(0, -len) + "9".repeat(len));
      }
      __name(countNines, "countNines");
      function countZeros(integer, zeros) {
        return integer - integer % Math.pow(10, zeros);
      }
      __name(countZeros, "countZeros");
      function toQuantifier(digits) {
        let [start = 0, stop = ""] = digits;
        if (stop || start > 1) {
          return `{${start + (stop ? "," + stop : "")}}`;
        }
        return "";
      }
      __name(toQuantifier, "toQuantifier");
      function toCharacterClass(a, b, options2) {
        return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
      }
      __name(toCharacterClass, "toCharacterClass");
      function hasPadding(str) {
        return /^-?(0+)\d/.test(str);
      }
      __name(hasPadding, "hasPadding");
      function padZeros(value, tok, options2) {
        if (!tok.isPadded) {
          return value;
        }
        let diff = Math.abs(tok.maxLen - String(value).length);
        let relax = options2.relaxZeros !== false;
        switch (diff) {
          case 0:
            return "";
          case 1:
            return relax ? "0?" : "0";
          case 2:
            return relax ? "0{0,2}" : "00";
          default: {
            return relax ? `0{0,${diff}}` : `0{${diff}}`;
          }
        }
      }
      __name(padZeros, "padZeros");
      toRegexRange.cache = {};
      toRegexRange.clearCache = () => toRegexRange.cache = {};
      module2.exports = toRegexRange;
    });
    var require_fill_range = __commonJS((exports2, module2) => {
      "use strict";
      var util2 = __require("util");
      var toRegexRange = require_to_regex_range();
      var isObject2 = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object" && !Array.isArray(val), "isObject");
      var transform = /* @__PURE__ */ __name((toNumber) => {
        return (value) => toNumber === true ? Number(value) : String(value);
      }, "transform");
      var isValidValue = /* @__PURE__ */ __name((value) => {
        return typeof value === "number" || typeof value === "string" && value !== "";
      }, "isValidValue");
      var isNumber = /* @__PURE__ */ __name((num) => Number.isInteger(+num), "isNumber");
      var zeros = /* @__PURE__ */ __name((input) => {
        let value = `${input}`;
        let index = -1;
        if (value[0] === "-")
          value = value.slice(1);
        if (value === "0")
          return false;
        while (value[++index] === "0")
          ;
        return index > 0;
      }, "zeros");
      var stringify2 = /* @__PURE__ */ __name((start, end, options2) => {
        if (typeof start === "string" || typeof end === "string") {
          return true;
        }
        return options2.stringify === true;
      }, "stringify");
      var pad = /* @__PURE__ */ __name((input, maxLength, toNumber) => {
        if (maxLength > 0) {
          let dash = input[0] === "-" ? "-" : "";
          if (dash)
            input = input.slice(1);
          input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
        }
        if (toNumber === false) {
          return String(input);
        }
        return input;
      }, "pad");
      var toMaxLen = /* @__PURE__ */ __name((input, maxLength) => {
        let negative = input[0] === "-" ? "-" : "";
        if (negative) {
          input = input.slice(1);
          maxLength--;
        }
        while (input.length < maxLength)
          input = "0" + input;
        return negative ? "-" + input : input;
      }, "toMaxLen");
      var toSequence = /* @__PURE__ */ __name((parts, options2) => {
        parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
        parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
        let prefix = options2.capture ? "" : "?:";
        let positives = "";
        let negatives = "";
        let result;
        if (parts.positives.length) {
          positives = parts.positives.join("|");
        }
        if (parts.negatives.length) {
          negatives = `-(${prefix}${parts.negatives.join("|")})`;
        }
        if (positives && negatives) {
          result = `${positives}|${negatives}`;
        } else {
          result = positives || negatives;
        }
        if (options2.wrap) {
          return `(${prefix}${result})`;
        }
        return result;
      }, "toSequence");
      var toRange = /* @__PURE__ */ __name((a, b, isNumbers, options2) => {
        if (isNumbers) {
          return toRegexRange(a, b, { wrap: false, ...options2 });
        }
        let start = String.fromCharCode(a);
        if (a === b)
          return start;
        let stop = String.fromCharCode(b);
        return `[${start}-${stop}]`;
      }, "toRange");
      var toRegex = /* @__PURE__ */ __name((start, end, options2) => {
        if (Array.isArray(start)) {
          let wrap = options2.wrap === true;
          let prefix = options2.capture ? "" : "?:";
          return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
        }
        return toRegexRange(start, end, options2);
      }, "toRegex");
      var rangeError = /* @__PURE__ */ __name((...args) => {
        return new RangeError("Invalid range arguments: " + util2.inspect(...args));
      }, "rangeError");
      var invalidRange = /* @__PURE__ */ __name((start, end, options2) => {
        if (options2.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }, "invalidRange");
      var invalidStep = /* @__PURE__ */ __name((step, options2) => {
        if (options2.strictRanges === true) {
          throw new TypeError(`Expected step "${step}" to be a number`);
        }
        return [];
      }, "invalidStep");
      var fillNumbers = /* @__PURE__ */ __name((start, end, step = 1, options2 = {}) => {
        let a = Number(start);
        let b = Number(end);
        if (!Number.isInteger(a) || !Number.isInteger(b)) {
          if (options2.strictRanges === true)
            throw rangeError([start, end]);
          return [];
        }
        if (a === 0)
          a = 0;
        if (b === 0)
          b = 0;
        let descending = a > b;
        let startString = String(start);
        let endString = String(end);
        let stepString = String(step);
        step = Math.max(Math.abs(step), 1);
        let padded = zeros(startString) || zeros(endString) || zeros(stepString);
        let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
        let toNumber = padded === false && stringify2(start, end, options2) === false;
        let format2 = options2.transform || transform(toNumber);
        if (options2.toRegex && step === 1) {
          return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options2);
        }
        let parts = { negatives: [], positives: [] };
        let push = /* @__PURE__ */ __name((num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num)), "push");
        let range = [];
        let index = 0;
        while (descending ? a >= b : a <= b) {
          if (options2.toRegex === true && step > 1) {
            push(a);
          } else {
            range.push(pad(format2(a, index), maxLen, toNumber));
          }
          a = descending ? a - step : a + step;
          index++;
        }
        if (options2.toRegex === true) {
          return step > 1 ? toSequence(parts, options2) : toRegex(range, null, { wrap: false, ...options2 });
        }
        return range;
      }, "fillNumbers");
      var fillLetters = /* @__PURE__ */ __name((start, end, step = 1, options2 = {}) => {
        if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
          return invalidRange(start, end, options2);
        }
        let format2 = options2.transform || ((val) => String.fromCharCode(val));
        let a = `${start}`.charCodeAt(0);
        let b = `${end}`.charCodeAt(0);
        let descending = a > b;
        let min2 = Math.min(a, b);
        let max2 = Math.max(a, b);
        if (options2.toRegex && step === 1) {
          return toRange(min2, max2, false, options2);
        }
        let range = [];
        let index = 0;
        while (descending ? a >= b : a <= b) {
          range.push(format2(a, index));
          a = descending ? a - step : a + step;
          index++;
        }
        if (options2.toRegex === true) {
          return toRegex(range, null, { wrap: false, options: options2 });
        }
        return range;
      }, "fillLetters");
      var fill = /* @__PURE__ */ __name((start, end, step, options2 = {}) => {
        if (end == null && isValidValue(start)) {
          return [start];
        }
        if (!isValidValue(start) || !isValidValue(end)) {
          return invalidRange(start, end, options2);
        }
        if (typeof step === "function") {
          return fill(start, end, 1, { transform: step });
        }
        if (isObject2(step)) {
          return fill(start, end, 0, step);
        }
        let opts2 = { ...options2 };
        if (opts2.capture === true)
          opts2.wrap = true;
        step = step || opts2.step || 1;
        if (!isNumber(step)) {
          if (step != null && !isObject2(step))
            return invalidStep(step, opts2);
          return fill(start, end, 1, step);
        }
        if (isNumber(start) && isNumber(end)) {
          return fillNumbers(start, end, step, opts2);
        }
        return fillLetters(start, end, Math.max(Math.abs(step), 1), opts2);
      }, "fill");
      module2.exports = fill;
    });
    var require_compile = __commonJS((exports2, module2) => {
      "use strict";
      var fill = require_fill_range();
      var utils = require_utils2();
      var compile = /* @__PURE__ */ __name((ast, options2 = {}) => {
        let walk = /* @__PURE__ */ __name((node, parent = {}) => {
          let invalidBlock = utils.isInvalidBrace(parent);
          let invalidNode = node.invalid === true && options2.escapeInvalid === true;
          let invalid = invalidBlock === true || invalidNode === true;
          let prefix = options2.escapeInvalid === true ? "\\" : "";
          let output = "";
          if (node.isOpen === true) {
            return prefix + node.value;
          }
          if (node.isClose === true) {
            return prefix + node.value;
          }
          if (node.type === "open") {
            return invalid ? prefix + node.value : "(";
          }
          if (node.type === "close") {
            return invalid ? prefix + node.value : ")";
          }
          if (node.type === "comma") {
            return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
          }
          if (node.value) {
            return node.value;
          }
          if (node.nodes && node.ranges > 0) {
            let args = utils.reduce(node.nodes);
            let range = fill(...args, { ...options2, wrap: false, toRegex: true });
            if (range.length !== 0) {
              return args.length > 1 && range.length > 1 ? `(${range})` : range;
            }
          }
          if (node.nodes) {
            for (let child of node.nodes) {
              output += walk(child, node);
            }
          }
          return output;
        }, "walk");
        return walk(ast);
      }, "compile");
      module2.exports = compile;
    });
    var require_expand = __commonJS((exports2, module2) => {
      "use strict";
      var fill = require_fill_range();
      var stringify2 = require_stringify();
      var utils = require_utils2();
      var append = /* @__PURE__ */ __name((queue = "", stash = "", enclose = false) => {
        let result = [];
        queue = [].concat(queue);
        stash = [].concat(stash);
        if (!stash.length)
          return queue;
        if (!queue.length) {
          return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
        }
        for (let item of queue) {
          if (Array.isArray(item)) {
            for (let value of item) {
              result.push(append(value, stash, enclose));
            }
          } else {
            for (let ele of stash) {
              if (enclose === true && typeof ele === "string")
                ele = `{${ele}}`;
              result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
            }
          }
        }
        return utils.flatten(result);
      }, "append");
      var expand = /* @__PURE__ */ __name((ast, options2 = {}) => {
        let rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit;
        let walk = /* @__PURE__ */ __name((node, parent = {}) => {
          node.queue = [];
          let p = parent;
          let q = parent.queue;
          while (p.type !== "brace" && p.type !== "root" && p.parent) {
            p = p.parent;
            q = p.queue;
          }
          if (node.invalid || node.dollar) {
            q.push(append(q.pop(), stringify2(node, options2)));
            return;
          }
          if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
            q.push(append(q.pop(), ["{}"]));
            return;
          }
          if (node.nodes && node.ranges > 0) {
            let args = utils.reduce(node.nodes);
            if (utils.exceedsLimit(...args, options2.step, rangeLimit)) {
              throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
            }
            let range = fill(...args, options2);
            if (range.length === 0) {
              range = stringify2(node, options2);
            }
            q.push(append(q.pop(), range));
            node.nodes = [];
            return;
          }
          let enclose = utils.encloseBrace(node);
          let queue = node.queue;
          let block = node;
          while (block.type !== "brace" && block.type !== "root" && block.parent) {
            block = block.parent;
            queue = block.queue;
          }
          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i];
            if (child.type === "comma" && node.type === "brace") {
              if (i === 1)
                queue.push("");
              queue.push("");
              continue;
            }
            if (child.type === "close") {
              q.push(append(q.pop(), queue, enclose));
              continue;
            }
            if (child.value && child.type !== "open") {
              queue.push(append(queue.pop(), child.value));
              continue;
            }
            if (child.nodes) {
              walk(child, node);
            }
          }
          return queue;
        }, "walk");
        return utils.flatten(walk(ast));
      }, "expand");
      module2.exports = expand;
    });
    var require_constants2 = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = {
        MAX_LENGTH: 1024 * 64,
        CHAR_0: "0",
        CHAR_9: "9",
        CHAR_UPPERCASE_A: "A",
        CHAR_LOWERCASE_A: "a",
        CHAR_UPPERCASE_Z: "Z",
        CHAR_LOWERCASE_Z: "z",
        CHAR_LEFT_PARENTHESES: "(",
        CHAR_RIGHT_PARENTHESES: ")",
        CHAR_ASTERISK: "*",
        CHAR_AMPERSAND: "&",
        CHAR_AT: "@",
        CHAR_BACKSLASH: "\\",
        CHAR_BACKTICK: "`",
        CHAR_CARRIAGE_RETURN: "\r",
        CHAR_CIRCUMFLEX_ACCENT: "^",
        CHAR_COLON: ":",
        CHAR_COMMA: ",",
        CHAR_DOLLAR: "$",
        CHAR_DOT: ".",
        CHAR_DOUBLE_QUOTE: '"',
        CHAR_EQUAL: "=",
        CHAR_EXCLAMATION_MARK: "!",
        CHAR_FORM_FEED: "\f",
        CHAR_FORWARD_SLASH: "/",
        CHAR_HASH: "#",
        CHAR_HYPHEN_MINUS: "-",
        CHAR_LEFT_ANGLE_BRACKET: "<",
        CHAR_LEFT_CURLY_BRACE: "{",
        CHAR_LEFT_SQUARE_BRACKET: "[",
        CHAR_LINE_FEED: "\n",
        CHAR_NO_BREAK_SPACE: "\xA0",
        CHAR_PERCENT: "%",
        CHAR_PLUS: "+",
        CHAR_QUESTION_MARK: "?",
        CHAR_RIGHT_ANGLE_BRACKET: ">",
        CHAR_RIGHT_CURLY_BRACE: "}",
        CHAR_RIGHT_SQUARE_BRACKET: "]",
        CHAR_SEMICOLON: ";",
        CHAR_SINGLE_QUOTE: "'",
        CHAR_SPACE: " ",
        CHAR_TAB: "	",
        CHAR_UNDERSCORE: "_",
        CHAR_VERTICAL_LINE: "|",
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      };
    });
    var require_parse3 = __commonJS((exports2, module2) => {
      "use strict";
      var stringify2 = require_stringify();
      var {
        MAX_LENGTH,
        CHAR_BACKSLASH,
        CHAR_BACKTICK,
        CHAR_COMMA,
        CHAR_DOT,
        CHAR_LEFT_PARENTHESES,
        CHAR_RIGHT_PARENTHESES,
        CHAR_LEFT_CURLY_BRACE,
        CHAR_RIGHT_CURLY_BRACE,
        CHAR_LEFT_SQUARE_BRACKET,
        CHAR_RIGHT_SQUARE_BRACKET,
        CHAR_DOUBLE_QUOTE,
        CHAR_SINGLE_QUOTE,
        CHAR_NO_BREAK_SPACE,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE
      } = require_constants2();
      var parse2 = /* @__PURE__ */ __name((input, options2 = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        let opts2 = options2 || {};
        let max2 = typeof opts2.maxLength === "number" ? Math.min(MAX_LENGTH, opts2.maxLength) : MAX_LENGTH;
        if (input.length > max2) {
          throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
        }
        let ast = { type: "root", input, nodes: [] };
        let stack = [ast];
        let block = ast;
        let prev = ast;
        let brackets = 0;
        let length = input.length;
        let index = 0;
        let depth = 0;
        let value;
        let memo = {};
        const advance = /* @__PURE__ */ __name(() => input[index++], "advance");
        const push = /* @__PURE__ */ __name((node) => {
          if (node.type === "text" && prev.type === "dot") {
            prev.type = "text";
          }
          if (prev && prev.type === "text" && node.type === "text") {
            prev.value += node.value;
            return;
          }
          block.nodes.push(node);
          node.parent = block;
          node.prev = prev;
          prev = node;
          return node;
        }, "push");
        push({ type: "bos" });
        while (index < length) {
          block = stack[stack.length - 1];
          value = advance();
          if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
            continue;
          }
          if (value === CHAR_BACKSLASH) {
            push({ type: "text", value: (options2.keepEscaping ? value : "") + advance() });
            continue;
          }
          if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({ type: "text", value: "\\" + value });
            continue;
          }
          if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            let closed = true;
            let next;
            while (index < length && (next = advance())) {
              value += next;
              if (next === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                continue;
              }
              if (next === CHAR_BACKSLASH) {
                value += advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                brackets--;
                if (brackets === 0) {
                  break;
                }
              }
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_PARENTHESES) {
            block = push({ type: "paren", nodes: [] });
            stack.push(block);
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_RIGHT_PARENTHESES) {
            if (block.type !== "paren") {
              push({ type: "text", value });
              continue;
            }
            block = stack.pop();
            push({ type: "text", value });
            block = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            let open = value;
            let next;
            if (options2.keepQuotes !== true) {
              value = "";
            }
            while (index < length && (next = advance())) {
              if (next === CHAR_BACKSLASH) {
                value += next + advance();
                continue;
              }
              if (next === open) {
                if (options2.keepQuotes === true)
                  value += next;
                break;
              }
              value += next;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
            let brace = {
              type: "brace",
              open: true,
              close: false,
              dollar,
              depth,
              commas: 0,
              ranges: 0,
              nodes: []
            };
            block = push(brace);
            stack.push(block);
            push({ type: "open", value });
            continue;
          }
          if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block.type !== "brace") {
              push({ type: "text", value });
              continue;
            }
            let type = "close";
            block = stack.pop();
            block.close = true;
            push({ type, value });
            depth--;
            block = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_COMMA && depth > 0) {
            if (block.ranges > 0) {
              block.ranges = 0;
              let open = block.nodes.shift();
              block.nodes = [open, { type: "text", value: stringify2(block) }];
            }
            push({ type: "comma", value });
            block.commas++;
            continue;
          }
          if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
            let siblings = block.nodes;
            if (depth === 0 || siblings.length === 0) {
              push({ type: "text", value });
              continue;
            }
            if (prev.type === "dot") {
              block.range = [];
              prev.value += value;
              prev.type = "range";
              if (block.nodes.length !== 3 && block.nodes.length !== 5) {
                block.invalid = true;
                block.ranges = 0;
                prev.type = "text";
                continue;
              }
              block.ranges++;
              block.args = [];
              continue;
            }
            if (prev.type === "range") {
              siblings.pop();
              let before = siblings[siblings.length - 1];
              before.value += prev.value + value;
              prev = before;
              block.ranges--;
              continue;
            }
            push({ type: "dot", value });
            continue;
          }
          push({ type: "text", value });
        }
        do {
          block = stack.pop();
          if (block.type !== "root") {
            block.nodes.forEach((node) => {
              if (!node.nodes) {
                if (node.type === "open")
                  node.isOpen = true;
                if (node.type === "close")
                  node.isClose = true;
                if (!node.nodes)
                  node.type = "text";
                node.invalid = true;
              }
            });
            let parent = stack[stack.length - 1];
            let index2 = parent.nodes.indexOf(block);
            parent.nodes.splice(index2, 1, ...block.nodes);
          }
        } while (stack.length > 0);
        push({ type: "eos" });
        return ast;
      }, "parse");
      module2.exports = parse2;
    });
    var require_braces = __commonJS((exports2, module2) => {
      "use strict";
      var stringify2 = require_stringify();
      var compile = require_compile();
      var expand = require_expand();
      var parse2 = require_parse3();
      var braces = /* @__PURE__ */ __name((input, options2 = {}) => {
        let output = [];
        if (Array.isArray(input)) {
          for (let pattern of input) {
            let result = braces.create(pattern, options2);
            if (Array.isArray(result)) {
              output.push(...result);
            } else {
              output.push(result);
            }
          }
        } else {
          output = [].concat(braces.create(input, options2));
        }
        if (options2 && options2.expand === true && options2.nodupes === true) {
          output = [...new Set(output)];
        }
        return output;
      }, "braces");
      braces.parse = (input, options2 = {}) => parse2(input, options2);
      braces.stringify = (input, options2 = {}) => {
        if (typeof input === "string") {
          return stringify2(braces.parse(input, options2), options2);
        }
        return stringify2(input, options2);
      };
      braces.compile = (input, options2 = {}) => {
        if (typeof input === "string") {
          input = braces.parse(input, options2);
        }
        return compile(input, options2);
      };
      braces.expand = (input, options2 = {}) => {
        if (typeof input === "string") {
          input = braces.parse(input, options2);
        }
        let result = expand(input, options2);
        if (options2.noempty === true) {
          result = result.filter(Boolean);
        }
        if (options2.nodupes === true) {
          result = [...new Set(result)];
        }
        return result;
      };
      braces.create = (input, options2 = {}) => {
        if (input === "" || input.length < 3) {
          return [input];
        }
        return options2.expand !== true ? braces.compile(input, options2) : braces.expand(input, options2);
      };
      module2.exports = braces;
    });
    var require_constants3 = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var WIN_SLASH = "\\\\/";
      var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
      var DOT_LITERAL = "\\.";
      var PLUS_LITERAL = "\\+";
      var QMARK_LITERAL = "\\?";
      var SLASH_LITERAL = "\\/";
      var ONE_CHAR = "(?=.)";
      var QMARK = "[^/]";
      var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
      var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
      var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
      var NO_DOT = `(?!${DOT_LITERAL})`;
      var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
      var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
      var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
      var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
      var STAR = `${QMARK}*?`;
      var POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      };
      var WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
      };
      var POSIX_REGEX_SOURCE = {
        alnum: "a-zA-Z0-9",
        alpha: "a-zA-Z",
        ascii: "\\x00-\\x7F",
        blank: " \\t",
        cntrl: "\\x00-\\x1F\\x7F",
        digit: "0-9",
        graph: "\\x21-\\x7E",
        lower: "a-z",
        print: "\\x20-\\x7E ",
        punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
        space: " \\t\\r\\n\\v\\f",
        upper: "A-Z",
        word: "A-Za-z0-9_",
        xdigit: "A-Fa-f0-9"
      };
      module2.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        REPLACEMENTS: {
          "***": "*",
          "**/**": "**",
          "**/**/**": "**"
        },
        CHAR_0: 48,
        CHAR_9: 57,
        CHAR_UPPERCASE_A: 65,
        CHAR_LOWERCASE_A: 97,
        CHAR_UPPERCASE_Z: 90,
        CHAR_LOWERCASE_Z: 122,
        CHAR_LEFT_PARENTHESES: 40,
        CHAR_RIGHT_PARENTHESES: 41,
        CHAR_ASTERISK: 42,
        CHAR_AMPERSAND: 38,
        CHAR_AT: 64,
        CHAR_BACKWARD_SLASH: 92,
        CHAR_CARRIAGE_RETURN: 13,
        CHAR_CIRCUMFLEX_ACCENT: 94,
        CHAR_COLON: 58,
        CHAR_COMMA: 44,
        CHAR_DOT: 46,
        CHAR_DOUBLE_QUOTE: 34,
        CHAR_EQUAL: 61,
        CHAR_EXCLAMATION_MARK: 33,
        CHAR_FORM_FEED: 12,
        CHAR_FORWARD_SLASH: 47,
        CHAR_GRAVE_ACCENT: 96,
        CHAR_HASH: 35,
        CHAR_HYPHEN_MINUS: 45,
        CHAR_LEFT_ANGLE_BRACKET: 60,
        CHAR_LEFT_CURLY_BRACE: 123,
        CHAR_LEFT_SQUARE_BRACKET: 91,
        CHAR_LINE_FEED: 10,
        CHAR_NO_BREAK_SPACE: 160,
        CHAR_PERCENT: 37,
        CHAR_PLUS: 43,
        CHAR_QUESTION_MARK: 63,
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        CHAR_RIGHT_CURLY_BRACE: 125,
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        CHAR_SEMICOLON: 59,
        CHAR_SINGLE_QUOTE: 39,
        CHAR_SPACE: 32,
        CHAR_TAB: 9,
        CHAR_UNDERSCORE: 95,
        CHAR_VERTICAL_LINE: 124,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        SEP: path22.sep,
        extglobChars(chars) {
          return {
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" }
          };
        },
        globChars(win32) {
          return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
      };
    });
    var require_utils3 = __commonJS((exports2) => {
      "use strict";
      var path22 = __require("path");
      var win32 = process.platform === "win32";
      var {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = require_constants3();
      exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
      exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports2.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
          return match === "\\" ? "" : match;
        });
      };
      exports2.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports2.isWindows = (options2) => {
        if (options2 && typeof options2.windows === "boolean") {
          return options2.windows;
        }
        return win32 === true || path22.sep === "\\";
      };
      exports2.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports2.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports2.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports2.wrapOutput = (input, state = {}, options2 = {}) => {
        const prepend = options2.contains ? "" : "^";
        const append = options2.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    });
    var require_scan = __commonJS((exports2, module2) => {
      "use strict";
      var utils = require_utils3();
      var {
        CHAR_ASTERISK,
        CHAR_AT,
        CHAR_BACKWARD_SLASH,
        CHAR_COMMA,
        CHAR_DOT,
        CHAR_EXCLAMATION_MARK,
        CHAR_FORWARD_SLASH,
        CHAR_LEFT_CURLY_BRACE,
        CHAR_LEFT_PARENTHESES,
        CHAR_LEFT_SQUARE_BRACKET,
        CHAR_PLUS,
        CHAR_QUESTION_MARK,
        CHAR_RIGHT_CURLY_BRACE,
        CHAR_RIGHT_PARENTHESES,
        CHAR_RIGHT_SQUARE_BRACKET
      } = require_constants3();
      var isPathSeparator = /* @__PURE__ */ __name((code) => {
        return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
      }, "isPathSeparator");
      var depth = /* @__PURE__ */ __name((token) => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1;
        }
      }, "depth");
      var scan = /* @__PURE__ */ __name((input, options2) => {
        const opts2 = options2 || {};
        const length = input.length - 1;
        const scanToEnd = opts2.parts === true || opts2.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let negatedExtglob = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = { value: "", depth: 0, isGlob: false };
        const eos = /* @__PURE__ */ __name(() => index >= length, "eos");
        const peek = /* @__PURE__ */ __name(() => str.charCodeAt(index + 1), "peek");
        const advance = /* @__PURE__ */ __name(() => {
          prev = code;
          return str.charCodeAt(++index);
        }, "advance");
        while (index < length) {
          code = advance();
          let next;
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true;
            }
            continue;
          }
          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                continue;
              }
              if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--;
                if (braces === 0) {
                  braceEscaped = false;
                  isBrace = token.isBrace = true;
                  finished = true;
                  break;
                }
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = { value: "", depth: 0, isGlob: false };
            if (finished === true)
              continue;
            if (prev === CHAR_DOT && index === start + 1) {
              start += 2;
              continue;
            }
            lastIndex = index + 1;
            continue;
          }
          if (opts2.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true;
              isExtglob = token.isExtglob = true;
              finished = true;
              if (code === CHAR_EXCLAMATION_MARK && index === start) {
                negatedExtglob = true;
              }
              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                  }
                }
                continue;
              }
              break;
            }
          }
          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK)
              isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true;
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (opts2.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
          }
          if (opts2.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
          if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
        if (opts2.noext === true) {
          isExtglob = false;
          isGlob = false;
        }
        let base = str;
        let prefix = "";
        let glob = "";
        if (start > 0) {
          prefix = str.slice(0, start);
          str = str.slice(start);
          lastIndex -= start;
        }
        if (base && isGlob === true && lastIndex > 0) {
          base = str.slice(0, lastIndex);
          glob = str.slice(lastIndex);
        } else if (isGlob === true) {
          base = "";
          glob = str;
        } else {
          base = str;
        }
        if (base && base !== "" && base !== "/" && base !== str) {
          if (isPathSeparator(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
          }
        }
        if (opts2.unescape === true) {
          if (glob)
            glob = utils.removeBackslashes(glob);
          if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
          }
        }
        const state = {
          prefix,
          input,
          start,
          base,
          glob,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated,
          negatedExtglob
        };
        if (opts2.tokens === true) {
          state.maxDepth = 0;
          if (!isPathSeparator(code)) {
            tokens.push(token);
          }
          state.tokens = tokens;
        }
        if (opts2.parts === true || opts2.tokens === true) {
          let prevIndex;
          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts2.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true;
                tokens[idx].value = prefix;
              } else {
                tokens[idx].value = value;
              }
              depth(tokens[idx]);
              state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") {
              parts.push(value);
            }
            prevIndex = i;
          }
          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts2.tokens) {
              tokens[tokens.length - 1].value = value;
              depth(tokens[tokens.length - 1]);
              state.maxDepth += tokens[tokens.length - 1].depth;
            }
          }
          state.slashes = slashes;
          state.parts = parts;
        }
        return state;
      }, "scan");
      module2.exports = scan;
    });
    var require_parse4 = __commonJS((exports2, module2) => {
      "use strict";
      var constants = require_constants3();
      var utils = require_utils3();
      var {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS
      } = constants;
      var expandRange = /* @__PURE__ */ __name((args, options2) => {
        if (typeof options2.expandRange === "function") {
          return options2.expandRange(...args, options2);
        }
        args.sort();
        const value = `[${args.join("-")}]`;
        try {
          new RegExp(value);
        } catch (ex) {
          return args.map((v) => utils.escapeRegex(v)).join("..");
        }
        return value;
      }, "expandRange");
      var syntaxError = /* @__PURE__ */ __name((type, char) => {
        return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
      }, "syntaxError");
      var parse2 = /* @__PURE__ */ __name((input, options2) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        input = REPLACEMENTS[input] || input;
        const opts2 = { ...options2 };
        const max2 = typeof opts2.maxLength === "number" ? Math.min(MAX_LENGTH, opts2.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max2) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
        }
        const bos = { type: "bos", value: "", output: opts2.prepend || "" };
        const tokens = [bos];
        const capture = opts2.capture ? "" : "?:";
        const win32 = utils.isWindows(options2);
        const PLATFORM_CHARS = constants.globChars(win32);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        } = PLATFORM_CHARS;
        const globstar = /* @__PURE__ */ __name((opts22) => {
          return `(${capture}(?:(?!${START_ANCHOR}${opts22.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        }, "globstar");
        const nodot = opts2.dot ? "" : NO_DOT;
        const qmarkNoDot = opts2.dot ? QMARK : QMARK_NO_DOT;
        let star = opts2.bash === true ? globstar(opts2) : STAR;
        if (opts2.capture) {
          star = `(${star})`;
        }
        if (typeof opts2.noext === "boolean") {
          opts2.noextglob = opts2.noext;
        }
        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts2.dot === true,
          consumed: "",
          output: "",
          prefix: "",
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = /* @__PURE__ */ __name(() => state.index === len - 1, "eos");
        const peek = state.peek = (n = 1) => input[state.index + n];
        const advance = state.advance = () => input[++state.index] || "";
        const remaining = /* @__PURE__ */ __name(() => input.slice(state.index + 1), "remaining");
        const consume = /* @__PURE__ */ __name((value2 = "", num = 0) => {
          state.consumed += value2;
          state.index += num;
        }, "consume");
        const append = /* @__PURE__ */ __name((token) => {
          state.output += token.output != null ? token.output : token.value;
          consume(token.value);
        }, "append");
        const negate = /* @__PURE__ */ __name(() => {
          let count = 1;
          while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
            advance();
            state.start++;
            count++;
          }
          if (count % 2 === 0) {
            return false;
          }
          state.negated = true;
          state.start++;
          return true;
        }, "negate");
        const increment = /* @__PURE__ */ __name((type) => {
          state[type]++;
          stack.push(type);
        }, "increment");
        const decrement = /* @__PURE__ */ __name((type) => {
          state[type]--;
          stack.pop();
        }, "decrement");
        const push = /* @__PURE__ */ __name((tok) => {
          if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
              state.output = state.output.slice(0, -prev.output.length);
              prev.type = "star";
              prev.value = "*";
              prev.output = star;
              state.output += prev.output;
            }
          }
          if (extglobs.length && tok.type !== "paren") {
            extglobs[extglobs.length - 1].inner += tok.value;
          }
          if (tok.value || tok.output)
            append(tok);
          if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
          }
          tok.prev = prev;
          tokens.push(tok);
          prev = tok;
        }, "push");
        const extglobOpen = /* @__PURE__ */ __name((type, value2) => {
          const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
          token.prev = prev;
          token.parens = state.parens;
          token.output = state.output;
          const output = (opts2.capture ? "(" : "") + token.open;
          increment("parens");
          push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
          push({ type: "paren", extglob: true, value: advance(), output });
          extglobs.push(token);
        }, "extglobOpen");
        const extglobClose = /* @__PURE__ */ __name((token) => {
          let output = token.close + (opts2.capture ? ")" : "");
          let rest;
          if (token.type === "negate") {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
              extglobStar = globstar(opts2);
            }
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
              output = token.close = `)$))${extglobStar}`;
            }
            if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
              output = token.close = `)${rest})${extglobStar})`;
            }
            if (token.prev.type === "bos") {
              state.negatedExtglob = true;
            }
          }
          push({ type: "paren", extglob: true, value, output });
          decrement("parens");
        }, "extglobClose");
        if (opts2.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false;
          let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
            if (first === "\\") {
              backslashes = true;
              return m;
            }
            if (first === "?") {
              if (esc) {
                return esc + first + (rest ? QMARK.repeat(rest.length) : "");
              }
              if (index === 0) {
                return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
              }
              return QMARK.repeat(chars.length);
            }
            if (first === ".") {
              return DOT_LITERAL.repeat(chars.length);
            }
            if (first === "*") {
              if (esc) {
                return esc + first + (rest ? star : "");
              }
              return star;
            }
            return esc ? m : `\\${m}`;
          });
          if (backslashes === true) {
            if (opts2.unescape === true) {
              output = output.replace(/\\/g, "");
            } else {
              output = output.replace(/\\+/g, (m) => {
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
              });
            }
          }
          if (output === input && opts2.contains === true) {
            state.output = input;
            return state;
          }
          state.output = utils.wrapOutput(output, state, options2);
          return state;
        }
        while (!eos()) {
          value = advance();
          if (value === "\0") {
            continue;
          }
          if (value === "\\") {
            const next = peek();
            if (next === "/" && opts2.bash !== true) {
              continue;
            }
            if (next === "." || next === ";") {
              continue;
            }
            if (!next) {
              value += "\\";
              push({ type: "text", value });
              continue;
            }
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
              slashes = match[0].length;
              state.index += slashes;
              if (slashes % 2 !== 0) {
                value += "\\";
              }
            }
            if (opts2.unescape === true) {
              value = advance();
            } else {
              value += advance();
            }
            if (state.brackets === 0) {
              push({ type: "text", value });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts2.posix !== false && value === ":") {
              const inner = prev.value.slice(1);
              if (inner.includes("[")) {
                prev.posix = true;
                if (inner.includes(":")) {
                  const idx = prev.value.lastIndexOf("[");
                  const pre = prev.value.slice(0, idx);
                  const rest2 = prev.value.slice(idx + 2);
                  const posix = POSIX_REGEX_SOURCE[rest2];
                  if (posix) {
                    prev.value = pre + posix;
                    state.backtrack = true;
                    advance();
                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR;
                    }
                    continue;
                  }
                }
              }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
              value = `\\${value}`;
            }
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
              value = `\\${value}`;
            }
            if (opts2.posix === true && value === "!" && prev.value === "[") {
              value = "^";
            }
            prev.value += value;
            append({ value });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts2.keepQuotes === true) {
              push({ type: "text", value });
            }
            continue;
          }
          if (value === "(") {
            increment("parens");
            push({ type: "paren", value });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts2.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "("));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
            decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts2.nobracket === true || !remaining().includes("]")) {
              if (opts2.nobracket !== true && opts2.strictBrackets === true) {
                throw new SyntaxError(syntaxError("closing", "]"));
              }
              value = `\\${value}`;
            } else {
              increment("brackets");
            }
            push({ type: "bracket", value });
            continue;
          }
          if (value === "]") {
            if (opts2.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            if (state.brackets === 0) {
              if (opts2.strictBrackets === true) {
                throw new SyntaxError(syntaxError("opening", "["));
              }
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
              value = `/${value}`;
            }
            prev.value += value;
            append({ value });
            if (opts2.literalBrackets === false || utils.hasRegexChars(prevValue)) {
              continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            if (opts2.literalBrackets === true) {
              state.output += escaped;
              prev.value = escaped;
              continue;
            }
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
          }
          if (value === "{" && opts2.nobrace !== true) {
            increment("braces");
            const open = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
          }
          if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts2.nobrace === true || !brace) {
              push({ type: "text", value, output: value });
              continue;
            }
            let output = ")";
            if (brace.dots === true) {
              const arr = tokens.slice();
              const range = [];
              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop();
                if (arr[i].type === "brace") {
                  break;
                }
                if (arr[i].type !== "dots") {
                  range.unshift(arr[i].value);
                }
              }
              output = expandRange(range, opts2);
              state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex);
              const toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{";
              value = output = "\\}";
              state.output = out;
              for (const t of toks) {
                state.output += t.output || t.value;
              }
            }
            push({ type: "brace", value, output });
            decrement("braces");
            braces.pop();
            continue;
          }
          if (value === "|") {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === ",") {
            let output = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
              brace.comma = true;
              output = "|";
            }
            push({ type: "comma", value, output });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1;
              state.consumed = "";
              state.output = "";
              tokens.pop();
              prev = bos;
              continue;
            }
            push({ type: "slash", value, output: SLASH_LITERAL });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              if (prev.value === ".")
                prev.output = DOT_LITERAL;
              const brace = braces[braces.length - 1];
              prev.type = "dots";
              prev.output += value;
              prev.value += value;
              brace.dots = true;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({ type: "text", value, output: DOT_LITERAL });
              continue;
            }
            push({ type: "dot", value, output: DOT_LITERAL });
            continue;
          }
          if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts2.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              const next = peek();
              let output = value;
              if (next === "<" && !utils.supportsLookbehinds()) {
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              }
              if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                output = `\\${value}`;
              }
              push({ type: "text", value, output });
              continue;
            }
            if (opts2.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
              push({ type: "qmark", value, output: QMARK_NO_DOT });
              continue;
            }
            push({ type: "qmark", value, output: QMARK });
            continue;
          }
          if (value === "!") {
            if (opts2.noextglob !== true && peek() === "(") {
              if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                extglobOpen("negate", value);
                continue;
              }
            }
            if (opts2.nonegate !== true && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts2.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts2.regex === false) {
              push({ type: "plus", value, output: PLUS_LITERAL });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({ type: "plus", value });
              continue;
            }
            push({ type: "plus", value: PLUS_LITERAL });
            continue;
          }
          if (value === "@") {
            if (opts2.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              push({ type: "at", extglob: true, value, output: "" });
              continue;
            }
            push({ type: "text", value });
            continue;
          }
          if (value !== "*") {
            if (value === "$" || value === "^") {
              value = `\\${value}`;
            }
            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
              value += match[0];
              state.index += match[0].length;
            }
            push({ type: "text", value });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
          }
          let rest = remaining();
          if (opts2.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts2.noglobstar === true) {
              consume(value);
              continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts2.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
              push({ type: "star", value, output: "" });
              continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({ type: "star", value, output: "" });
              continue;
            }
            while (rest.slice(0, 3) === "/**") {
              const after = input[state.index + 4];
              if (after && after !== "/") {
                break;
              }
              rest = rest.slice(3);
              consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar";
              prev.value += value;
              prev.output = globstar(opts2);
              state.output = prev.output;
              state.globstar = true;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = globstar(opts2) + (opts2.strictSlashes ? ")" : "|$)");
              prev.value += value;
              state.globstar = true;
              state.output += prior.output + prev.output;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
              const end = rest[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = `${globstar(opts2)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
              prev.value += value;
              state.output += prior.output + prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
              prev.type = "globstar";
              prev.value += value;
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts2)}${SLASH_LITERAL})`;
              state.output = prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "globstar";
            prev.output = globstar(opts2);
            prev.value += value;
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          const token = { type: "star", value, output: star };
          if (opts2.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") {
              token.output = nodot + token.output;
            }
            push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts2.regex === true) {
            token.output = value;
            push(token);
            continue;
          }
          if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
              state.output += NO_DOT_SLASH;
              prev.output += NO_DOT_SLASH;
            } else if (opts2.dot === true) {
              state.output += NO_DOTS_SLASH;
              prev.output += NO_DOTS_SLASH;
            } else {
              state.output += nodot;
              prev.output += nodot;
            }
            if (peek() !== "*") {
              state.output += ONE_CHAR;
              prev.output += ONE_CHAR;
            }
          }
          push(token);
        }
        while (state.brackets > 0) {
          if (opts2.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", "]"));
          state.output = utils.escapeLast(state.output, "[");
          decrement("brackets");
        }
        while (state.parens > 0) {
          if (opts2.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", ")"));
          state.output = utils.escapeLast(state.output, "(");
          decrement("parens");
        }
        while (state.braces > 0) {
          if (opts2.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", "}"));
          state.output = utils.escapeLast(state.output, "{");
          decrement("braces");
        }
        if (opts2.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
          push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
        }
        if (state.backtrack === true) {
          state.output = "";
          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
              state.output += token.suffix;
            }
          }
        }
        return state;
      }, "parse");
      parse2.fastpaths = (input, options2) => {
        const opts2 = { ...options2 };
        const max2 = typeof opts2.maxLength === "number" ? Math.min(MAX_LENGTH, opts2.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max2) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
        }
        input = REPLACEMENTS[input] || input;
        const win32 = utils.isWindows(options2);
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR
        } = constants.globChars(win32);
        const nodot = opts2.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts2.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts2.capture ? "" : "?:";
        const state = { negated: false, prefix: "" };
        let star = opts2.bash === true ? ".*?" : STAR;
        if (opts2.capture) {
          star = `(${star})`;
        }
        const globstar = /* @__PURE__ */ __name((opts22) => {
          if (opts22.noglobstar === true)
            return star;
          return `(${capture}(?:(?!${START_ANCHOR}${opts22.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        }, "globstar");
        const create = /* @__PURE__ */ __name((str) => {
          switch (str) {
            case "*":
              return `${nodot}${ONE_CHAR}${star}`;
            case ".*":
              return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*.*":
              return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*/*":
              return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case "**":
              return nodot + globstar(opts2);
            case "**/*":
              return `(?:${nodot}${globstar(opts2)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case "**/*.*":
              return `(?:${nodot}${globstar(opts2)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "**/.*":
              return `(?:${nodot}${globstar(opts2)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default: {
              const match = /^(.*?)\.(\w+)$/.exec(str);
              if (!match)
                return;
              const source2 = create(match[1]);
              if (!source2)
                return;
              return source2 + DOT_LITERAL + match[2];
            }
          }
        }, "create");
        const output = utils.removePrefix(input, state);
        let source = create(output);
        if (source && opts2.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`;
        }
        return source;
      };
      module2.exports = parse2;
    });
    var require_picomatch = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var scan = require_scan();
      var parse2 = require_parse4();
      var utils = require_utils3();
      var constants = require_constants3();
      var isObject2 = /* @__PURE__ */ __name((val) => val && typeof val === "object" && !Array.isArray(val), "isObject");
      var picomatch = /* @__PURE__ */ __name((glob, options2, returnState = false) => {
        if (Array.isArray(glob)) {
          const fns = glob.map((input) => picomatch(input, options2, returnState));
          const arrayMatcher = /* @__PURE__ */ __name((str) => {
            for (const isMatch of fns) {
              const state2 = isMatch(str);
              if (state2)
                return state2;
            }
            return false;
          }, "arrayMatcher");
          return arrayMatcher;
        }
        const isState = isObject2(glob) && glob.tokens && glob.input;
        if (glob === "" || typeof glob !== "string" && !isState) {
          throw new TypeError("Expected pattern to be a non-empty string");
        }
        const opts2 = options2 || {};
        const posix = utils.isWindows(options2);
        const regex = isState ? picomatch.compileRe(glob, options2) : picomatch.makeRe(glob, options2, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored = /* @__PURE__ */ __name(() => false, "isIgnored");
        if (opts2.ignore) {
          const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
          isIgnored = picomatch(opts2.ignore, ignoreOpts, returnState);
        }
        const matcher = /* @__PURE__ */ __name((input, returnObject = false) => {
          const { isMatch, match, output } = picomatch.test(input, regex, options2, { glob, posix });
          const result = { glob, state, regex, posix, input, output, match, isMatch };
          if (typeof opts2.onResult === "function") {
            opts2.onResult(result);
          }
          if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (isIgnored(input)) {
            if (typeof opts2.onIgnore === "function") {
              opts2.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (typeof opts2.onMatch === "function") {
            opts2.onMatch(result);
          }
          return returnObject ? result : true;
        }, "matcher");
        if (returnState) {
          matcher.state = state;
        }
        return matcher;
      }, "picomatch");
      picomatch.test = (input, regex, options2, { glob, posix } = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected input to be a string");
        }
        if (input === "") {
          return { isMatch: false, output: "" };
        }
        const opts2 = options2 || {};
        const format2 = opts2.format || (posix ? utils.toPosixSlashes : null);
        let match = input === glob;
        let output = match && format2 ? format2(input) : input;
        if (match === false) {
          output = format2 ? format2(input) : input;
          match = output === glob;
        }
        if (match === false || opts2.capture === true) {
          if (opts2.matchBase === true || opts2.basename === true) {
            match = picomatch.matchBase(input, regex, options2, posix);
          } else {
            match = regex.exec(output);
          }
        }
        return { isMatch: Boolean(match), match, output };
      };
      picomatch.matchBase = (input, glob, options2, posix = utils.isWindows(options2)) => {
        const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options2);
        return regex.test(path22.basename(input));
      };
      picomatch.isMatch = (str, patterns, options2) => picomatch(patterns, options2)(str);
      picomatch.parse = (pattern, options2) => {
        if (Array.isArray(pattern))
          return pattern.map((p) => picomatch.parse(p, options2));
        return parse2(pattern, { ...options2, fastpaths: false });
      };
      picomatch.scan = (input, options2) => scan(input, options2);
      picomatch.compileRe = (state, options2, returnOutput = false, returnState = false) => {
        if (returnOutput === true) {
          return state.output;
        }
        const opts2 = options2 || {};
        const prepend = opts2.contains ? "" : "^";
        const append = opts2.contains ? "" : "$";
        let source = `${prepend}(?:${state.output})${append}`;
        if (state && state.negated === true) {
          source = `^(?!${source}).*$`;
        }
        const regex = picomatch.toRegex(source, options2);
        if (returnState === true) {
          regex.state = state;
        }
        return regex;
      };
      picomatch.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
        if (!input || typeof input !== "string") {
          throw new TypeError("Expected a non-empty string");
        }
        let parsed = { negated: false, fastpaths: true };
        if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
          parsed.output = parse2.fastpaths(input, options2);
        }
        if (!parsed.output) {
          parsed = parse2(input, options2);
        }
        return picomatch.compileRe(parsed, options2, returnOutput, returnState);
      };
      picomatch.toRegex = (source, options2) => {
        try {
          const opts2 = options2 || {};
          return new RegExp(source, opts2.flags || (opts2.nocase ? "i" : ""));
        } catch (err) {
          if (options2 && options2.debug === true)
            throw err;
          return /$^/;
        }
      };
      picomatch.constants = constants;
      module2.exports = picomatch;
    });
    var require_picomatch2 = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = require_picomatch();
    });
    var require_micromatch = __commonJS((exports2, module2) => {
      "use strict";
      var util2 = __require("util");
      var braces = require_braces();
      var picomatch = require_picomatch2();
      var utils = require_utils3();
      var isEmptyString = /* @__PURE__ */ __name((val) => val === "" || val === "./", "isEmptyString");
      var micromatch = /* @__PURE__ */ __name((list, patterns, options2) => {
        patterns = [].concat(patterns);
        list = [].concat(list);
        let omit3 = new Set();
        let keep = new Set();
        let items = new Set();
        let negatives = 0;
        let onResult = /* @__PURE__ */ __name((state) => {
          items.add(state.output);
          if (options2 && options2.onResult) {
            options2.onResult(state);
          }
        }, "onResult");
        for (let i = 0; i < patterns.length; i++) {
          let isMatch = picomatch(String(patterns[i]), { ...options2, onResult }, true);
          let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
          if (negated)
            negatives++;
          for (let item of list) {
            let matched = isMatch(item, true);
            let match = negated ? !matched.isMatch : matched.isMatch;
            if (!match)
              continue;
            if (negated) {
              omit3.add(matched.output);
            } else {
              omit3.delete(matched.output);
              keep.add(matched.output);
            }
          }
        }
        let result = negatives === patterns.length ? [...items] : [...keep];
        let matches = result.filter((item) => !omit3.has(item));
        if (options2 && matches.length === 0) {
          if (options2.failglob === true) {
            throw new Error(`No matches found for "${patterns.join(", ")}"`);
          }
          if (options2.nonull === true || options2.nullglob === true) {
            return options2.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
          }
        }
        return matches;
      }, "micromatch");
      micromatch.match = micromatch;
      micromatch.matcher = (pattern, options2) => picomatch(pattern, options2);
      micromatch.isMatch = (str, patterns, options2) => picomatch(patterns, options2)(str);
      micromatch.any = micromatch.isMatch;
      micromatch.not = (list, patterns, options2 = {}) => {
        patterns = [].concat(patterns).map(String);
        let result = new Set();
        let items = [];
        let onResult = /* @__PURE__ */ __name((state) => {
          if (options2.onResult)
            options2.onResult(state);
          items.push(state.output);
        }, "onResult");
        let matches = micromatch(list, patterns, { ...options2, onResult });
        for (let item of items) {
          if (!matches.includes(item)) {
            result.add(item);
          }
        }
        return [...result];
      };
      micromatch.contains = (str, pattern, options2) => {
        if (typeof str !== "string") {
          throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
        }
        if (Array.isArray(pattern)) {
          return pattern.some((p) => micromatch.contains(str, p, options2));
        }
        if (typeof pattern === "string") {
          if (isEmptyString(str) || isEmptyString(pattern)) {
            return false;
          }
          if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
            return true;
          }
        }
        return micromatch.isMatch(str, pattern, { ...options2, contains: true });
      };
      micromatch.matchKeys = (obj, patterns, options2) => {
        if (!utils.isObject(obj)) {
          throw new TypeError("Expected the first argument to be an object");
        }
        let keys2 = micromatch(Object.keys(obj), patterns, options2);
        let res = {};
        for (let key of keys2)
          res[key] = obj[key];
        return res;
      };
      micromatch.some = (list, patterns, options2) => {
        let items = [].concat(list);
        for (let pattern of [].concat(patterns)) {
          let isMatch = picomatch(String(pattern), options2);
          if (items.some((item) => isMatch(item))) {
            return true;
          }
        }
        return false;
      };
      micromatch.every = (list, patterns, options2) => {
        let items = [].concat(list);
        for (let pattern of [].concat(patterns)) {
          let isMatch = picomatch(String(pattern), options2);
          if (!items.every((item) => isMatch(item))) {
            return false;
          }
        }
        return true;
      };
      micromatch.all = (str, patterns, options2) => {
        if (typeof str !== "string") {
          throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
        }
        return [].concat(patterns).every((p) => picomatch(p, options2)(str));
      };
      micromatch.capture = (glob, input, options2) => {
        let posix = utils.isWindows(options2);
        let regex = picomatch.makeRe(String(glob), { ...options2, capture: true });
        let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
        if (match) {
          return match.slice(1).map((v) => v === void 0 ? "" : v);
        }
      };
      micromatch.makeRe = (...args) => picomatch.makeRe(...args);
      micromatch.scan = (...args) => picomatch.scan(...args);
      micromatch.parse = (patterns, options2) => {
        let res = [];
        for (let pattern of [].concat(patterns || [])) {
          for (let str of braces(String(pattern), options2)) {
            res.push(picomatch.parse(str, options2));
          }
        }
        return res;
      };
      micromatch.braces = (pattern, options2) => {
        if (typeof pattern !== "string")
          throw new TypeError("Expected a string");
        if (options2 && options2.nobrace === true || !/\{.*\}/.test(pattern)) {
          return [pattern];
        }
        return braces(pattern, options2);
      };
      micromatch.braceExpand = (pattern, options2) => {
        if (typeof pattern !== "string")
          throw new TypeError("Expected a string");
        return micromatch.braces(pattern, { ...options2, expand: true });
      };
      module2.exports = micromatch;
    });
    var require_pattern = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
      var path22 = __require("path");
      var globParent = require_glob_parent();
      var micromatch = require_micromatch();
      var picomatch = require_picomatch2();
      var GLOBSTAR = "**";
      var ESCAPE_SYMBOL = "\\";
      var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
      var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
      var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
      var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
      var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
      function isStaticPattern(pattern, options2 = {}) {
        return !isDynamicPattern(pattern, options2);
      }
      __name(isStaticPattern, "isStaticPattern");
      exports2.isStaticPattern = isStaticPattern;
      function isDynamicPattern(pattern, options2 = {}) {
        if (pattern === "") {
          return false;
        }
        if (options2.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
          return true;
        }
        if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
          return true;
        }
        if (options2.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
          return true;
        }
        if (options2.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
          return true;
        }
        return false;
      }
      __name(isDynamicPattern, "isDynamicPattern");
      exports2.isDynamicPattern = isDynamicPattern;
      function convertToPositivePattern(pattern) {
        return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
      }
      __name(convertToPositivePattern, "convertToPositivePattern");
      exports2.convertToPositivePattern = convertToPositivePattern;
      function convertToNegativePattern(pattern) {
        return "!" + pattern;
      }
      __name(convertToNegativePattern, "convertToNegativePattern");
      exports2.convertToNegativePattern = convertToNegativePattern;
      function isNegativePattern(pattern) {
        return pattern.startsWith("!") && pattern[1] !== "(";
      }
      __name(isNegativePattern, "isNegativePattern");
      exports2.isNegativePattern = isNegativePattern;
      function isPositivePattern(pattern) {
        return !isNegativePattern(pattern);
      }
      __name(isPositivePattern, "isPositivePattern");
      exports2.isPositivePattern = isPositivePattern;
      function getNegativePatterns(patterns) {
        return patterns.filter(isNegativePattern);
      }
      __name(getNegativePatterns, "getNegativePatterns");
      exports2.getNegativePatterns = getNegativePatterns;
      function getPositivePatterns(patterns) {
        return patterns.filter(isPositivePattern);
      }
      __name(getPositivePatterns, "getPositivePatterns");
      exports2.getPositivePatterns = getPositivePatterns;
      function getBaseDirectory(pattern) {
        return globParent(pattern, { flipBackslashes: false });
      }
      __name(getBaseDirectory, "getBaseDirectory");
      exports2.getBaseDirectory = getBaseDirectory;
      function hasGlobStar(pattern) {
        return pattern.includes(GLOBSTAR);
      }
      __name(hasGlobStar, "hasGlobStar");
      exports2.hasGlobStar = hasGlobStar;
      function endsWithSlashGlobStar(pattern) {
        return pattern.endsWith("/" + GLOBSTAR);
      }
      __name(endsWithSlashGlobStar, "endsWithSlashGlobStar");
      exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
      function isAffectDepthOfReadingPattern(pattern) {
        const basename = path22.basename(pattern);
        return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
      }
      __name(isAffectDepthOfReadingPattern, "isAffectDepthOfReadingPattern");
      exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
      function expandPatternsWithBraceExpansion(patterns) {
        return patterns.reduce((collection, pattern) => {
          return collection.concat(expandBraceExpansion(pattern));
        }, []);
      }
      __name(expandPatternsWithBraceExpansion, "expandPatternsWithBraceExpansion");
      exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
      function expandBraceExpansion(pattern) {
        return micromatch.braces(pattern, {
          expand: true,
          nodupes: true
        });
      }
      __name(expandBraceExpansion, "expandBraceExpansion");
      exports2.expandBraceExpansion = expandBraceExpansion;
      function getPatternParts(pattern, options2) {
        let { parts } = picomatch.scan(pattern, Object.assign(Object.assign({}, options2), { parts: true }));
        if (parts.length === 0) {
          parts = [pattern];
        }
        if (parts[0].startsWith("/")) {
          parts[0] = parts[0].slice(1);
          parts.unshift("");
        }
        return parts;
      }
      __name(getPatternParts, "getPatternParts");
      exports2.getPatternParts = getPatternParts;
      function makeRe(pattern, options2) {
        return micromatch.makeRe(pattern, options2);
      }
      __name(makeRe, "makeRe");
      exports2.makeRe = makeRe;
      function convertPatternsToRe(patterns, options2) {
        return patterns.map((pattern) => makeRe(pattern, options2));
      }
      __name(convertPatternsToRe, "convertPatternsToRe");
      exports2.convertPatternsToRe = convertPatternsToRe;
      function matchAny(entry, patternsRe) {
        return patternsRe.some((patternRe) => patternRe.test(entry));
      }
      __name(matchAny, "matchAny");
      exports2.matchAny = matchAny;
    });
    var require_stream2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.merge = void 0;
      var merge2 = require_merge2();
      function merge(streams) {
        const mergedStream = merge2(streams);
        streams.forEach((stream3) => {
          stream3.once("error", (error2) => mergedStream.emit("error", error2));
        });
        mergedStream.once("close", () => propagateCloseEventToSources(streams));
        mergedStream.once("end", () => propagateCloseEventToSources(streams));
        return mergedStream;
      }
      __name(merge, "merge");
      exports2.merge = merge;
      function propagateCloseEventToSources(streams) {
        streams.forEach((stream3) => stream3.emit("close"));
      }
      __name(propagateCloseEventToSources, "propagateCloseEventToSources");
    });
    var require_string = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isEmpty = exports2.isString = void 0;
      function isString(input) {
        return typeof input === "string";
      }
      __name(isString, "isString");
      exports2.isString = isString;
      function isEmpty(input) {
        return input === "";
      }
      __name(isEmpty, "isEmpty");
      exports2.isEmpty = isEmpty;
    });
    var require_utils4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
      var array = require_array();
      exports2.array = array;
      var errno = require_errno();
      exports2.errno = errno;
      var fs7 = require_fs2();
      exports2.fs = fs7;
      var path22 = require_path();
      exports2.path = path22;
      var pattern = require_pattern();
      exports2.pattern = pattern;
      var stream3 = require_stream2();
      exports2.stream = stream3;
      var string = require_string();
      exports2.string = string;
    });
    var require_tasks = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
      var utils = require_utils4();
      function generate(patterns, settings) {
        const positivePatterns = getPositivePatterns(patterns);
        const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
        const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
        const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
        const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
        const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
        return staticTasks.concat(dynamicTasks);
      }
      __name(generate, "generate");
      exports2.generate = generate;
      function convertPatternsToTasks(positive, negative, dynamic) {
        const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
        if ("." in positivePatternsGroup) {
          const task = convertPatternGroupToTask(".", positive, negative, dynamic);
          return [task];
        }
        return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
      }
      __name(convertPatternsToTasks, "convertPatternsToTasks");
      exports2.convertPatternsToTasks = convertPatternsToTasks;
      function getPositivePatterns(patterns) {
        return utils.pattern.getPositivePatterns(patterns);
      }
      __name(getPositivePatterns, "getPositivePatterns");
      exports2.getPositivePatterns = getPositivePatterns;
      function getNegativePatternsAsPositive(patterns, ignore) {
        const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
        const positive = negative.map(utils.pattern.convertToPositivePattern);
        return positive;
      }
      __name(getNegativePatternsAsPositive, "getNegativePatternsAsPositive");
      exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
      function groupPatternsByBaseDirectory(patterns) {
        const group = {};
        return patterns.reduce((collection, pattern) => {
          const base = utils.pattern.getBaseDirectory(pattern);
          if (base in collection) {
            collection[base].push(pattern);
          } else {
            collection[base] = [pattern];
          }
          return collection;
        }, group);
      }
      __name(groupPatternsByBaseDirectory, "groupPatternsByBaseDirectory");
      exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
      function convertPatternGroupsToTasks(positive, negative, dynamic) {
        return Object.keys(positive).map((base) => {
          return convertPatternGroupToTask(base, positive[base], negative, dynamic);
        });
      }
      __name(convertPatternGroupsToTasks, "convertPatternGroupsToTasks");
      exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
      function convertPatternGroupToTask(base, positive, negative, dynamic) {
        return {
          dynamic,
          positive,
          negative,
          base,
          patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
        };
      }
      __name(convertPatternGroupToTask, "convertPatternGroupToTask");
      exports2.convertPatternGroupToTask = convertPatternGroupToTask;
    });
    var require_async = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.read = void 0;
      function read(path22, settings, callback) {
        settings.fs.lstat(path22, (lstatError, lstat) => {
          if (lstatError !== null) {
            return callFailureCallback(callback, lstatError);
          }
          if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            return callSuccessCallback(callback, lstat);
          }
          settings.fs.stat(path22, (statError, stat) => {
            if (statError !== null) {
              if (settings.throwErrorOnBrokenSymbolicLink) {
                return callFailureCallback(callback, statError);
              }
              return callSuccessCallback(callback, lstat);
            }
            if (settings.markSymbolicLink) {
              stat.isSymbolicLink = () => true;
            }
            callSuccessCallback(callback, stat);
          });
        });
      }
      __name(read, "read");
      exports2.read = read;
      function callFailureCallback(callback, error2) {
        callback(error2);
      }
      __name(callFailureCallback, "callFailureCallback");
      function callSuccessCallback(callback, result) {
        callback(null, result);
      }
      __name(callSuccessCallback, "callSuccessCallback");
    });
    var require_sync2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.read = void 0;
      function read(path22, settings) {
        const lstat = settings.fs.lstatSync(path22);
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          return lstat;
        }
        try {
          const stat = settings.fs.statSync(path22);
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          return stat;
        } catch (error2) {
          if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
          }
          throw error2;
        }
      }
      __name(read, "read");
      exports2.read = read;
    });
    var require_fs3 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      var fs7 = __require("fs");
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs7.lstat,
        stat: fs7.stat,
        lstatSync: fs7.lstatSync,
        statSync: fs7.statSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      __name(createFileSystemAdapter, "createFileSystemAdapter");
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    });
    var require_settings = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var fs7 = require_fs3();
      var Settings = /* @__PURE__ */ __name(class {
        constructor(_options = {}) {
          this._options = _options;
          this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
          this.fs = fs7.createFileSystemAdapter(this._options.fs);
          this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
          this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        }
        _getValue(option, value) {
          return option !== null && option !== void 0 ? option : value;
        }
      }, "Settings");
      exports2.default = Settings;
    });
    var require_out = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.statSync = exports2.stat = exports2.Settings = void 0;
      var async = require_async();
      var sync = require_sync2();
      var settings_1 = require_settings();
      exports2.Settings = settings_1.default;
      function stat(path22, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === "function") {
          return async.read(path22, getSettings(), optionsOrSettingsOrCallback);
        }
        async.read(path22, getSettings(optionsOrSettingsOrCallback), callback);
      }
      __name(stat, "stat");
      exports2.stat = stat;
      function statSync2(path22, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings);
        return sync.read(path22, settings);
      }
      __name(statSync2, "statSync");
      exports2.statSync = statSync2;
      function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
          return settingsOrOptions;
        }
        return new settings_1.default(settingsOrOptions);
      }
      __name(getSettings, "getSettings");
    });
    var require_queue_microtask = __commonJS((exports2, module2) => {
      var promise;
      module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0));
    });
    var require_run_parallel = __commonJS((exports2, module2) => {
      module2.exports = runParallel;
      var queueMicrotask2 = require_queue_microtask();
      function runParallel(tasks, cb) {
        let results, pending, keys2;
        let isSync = true;
        if (Array.isArray(tasks)) {
          results = [];
          pending = tasks.length;
        } else {
          keys2 = Object.keys(tasks);
          results = {};
          pending = keys2.length;
        }
        function done(err) {
          function end() {
            if (cb)
              cb(err, results);
            cb = null;
          }
          __name(end, "end");
          if (isSync)
            queueMicrotask2(end);
          else
            end();
        }
        __name(done, "done");
        function each(i, err, result) {
          results[i] = result;
          if (--pending === 0 || err) {
            done(err);
          }
        }
        __name(each, "each");
        if (!pending) {
          done(null);
        } else if (keys2) {
          keys2.forEach(function(key) {
            tasks[key](function(err, result) {
              each(key, err, result);
            });
          });
        } else {
          tasks.forEach(function(task, i) {
            task(function(err, result) {
              each(i, err, result);
            });
          });
        }
        isSync = false;
      }
      __name(runParallel, "runParallel");
    });
    var require_constants4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
      var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
      var MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
      var MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
      var SUPPORTED_MAJOR_VERSION = 10;
      var SUPPORTED_MINOR_VERSION = 10;
      var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
      var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
      exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
    });
    var require_fs4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createDirentFromStats = void 0;
      var DirentFromStats = /* @__PURE__ */ __name(class {
        constructor(name, stats) {
          this.name = name;
          this.isBlockDevice = stats.isBlockDevice.bind(stats);
          this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
          this.isDirectory = stats.isDirectory.bind(stats);
          this.isFIFO = stats.isFIFO.bind(stats);
          this.isFile = stats.isFile.bind(stats);
          this.isSocket = stats.isSocket.bind(stats);
          this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
        }
      }, "DirentFromStats");
      function createDirentFromStats(name, stats) {
        return new DirentFromStats(name, stats);
      }
      __name(createDirentFromStats, "createDirentFromStats");
      exports2.createDirentFromStats = createDirentFromStats;
    });
    var require_utils5 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.fs = void 0;
      var fs7 = require_fs4();
      exports2.fs = fs7;
    });
    var require_common4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.joinPathSegments = void 0;
      function joinPathSegments(a, b, separator) {
        if (a.endsWith(separator)) {
          return a + b;
        }
        return a + separator + b;
      }
      __name(joinPathSegments, "joinPathSegments");
      exports2.joinPathSegments = joinPathSegments;
    });
    var require_async2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
      var fsStat = require_out();
      var rpl = require_run_parallel();
      var constants_1 = require_constants4();
      var utils = require_utils5();
      var common = require_common4();
      function read(directory, settings, callback) {
        if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
          return readdirWithFileTypes(directory, settings, callback);
        }
        return readdir(directory, settings, callback);
      }
      __name(read, "read");
      exports2.read = read;
      function readdirWithFileTypes(directory, settings, callback) {
        settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
          if (readdirError !== null) {
            return callFailureCallback(callback, readdirError);
          }
          const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
          }));
          if (!settings.followSymbolicLinks) {
            return callSuccessCallback(callback, entries);
          }
          const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
          rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
              return callFailureCallback(callback, rplError);
            }
            callSuccessCallback(callback, rplEntries);
          });
        });
      }
      __name(readdirWithFileTypes, "readdirWithFileTypes");
      exports2.readdirWithFileTypes = readdirWithFileTypes;
      function makeRplTaskEntry(entry, settings) {
        return (done) => {
          if (!entry.dirent.isSymbolicLink()) {
            return done(null, entry);
          }
          settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
              if (settings.throwErrorOnBrokenSymbolicLink) {
                return done(statError);
              }
              return done(null, entry);
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            return done(null, entry);
          });
        };
      }
      __name(makeRplTaskEntry, "makeRplTaskEntry");
      function readdir(directory, settings, callback) {
        settings.fs.readdir(directory, (readdirError, names) => {
          if (readdirError !== null) {
            return callFailureCallback(callback, readdirError);
          }
          const filepaths = names.map((name) => common.joinPathSegments(directory, name, settings.pathSegmentSeparator));
          const tasks = filepaths.map((filepath) => {
            return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
          });
          rpl(tasks, (rplError, results) => {
            if (rplError !== null) {
              return callFailureCallback(callback, rplError);
            }
            const entries = [];
            names.forEach((name, index) => {
              const stats = results[index];
              const entry = {
                name,
                path: filepaths[index],
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              entries.push(entry);
            });
            callSuccessCallback(callback, entries);
          });
        });
      }
      __name(readdir, "readdir");
      exports2.readdir = readdir;
      function callFailureCallback(callback, error2) {
        callback(error2);
      }
      __name(callFailureCallback, "callFailureCallback");
      function callSuccessCallback(callback, result) {
        callback(null, result);
      }
      __name(callSuccessCallback, "callSuccessCallback");
    });
    var require_sync3 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
      var fsStat = require_out();
      var constants_1 = require_constants4();
      var utils = require_utils5();
      var common = require_common4();
      function read(directory, settings) {
        if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
          return readdirWithFileTypes(directory, settings);
        }
        return readdir(directory, settings);
      }
      __name(read, "read");
      exports2.read = read;
      function readdirWithFileTypes(directory, settings) {
        const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
        return dirents.map((dirent) => {
          const entry = {
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
          };
          if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
              const stats = settings.fs.statSync(entry.path);
              entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            } catch (error2) {
              if (settings.throwErrorOnBrokenSymbolicLink) {
                throw error2;
              }
            }
          }
          return entry;
        });
      }
      __name(readdirWithFileTypes, "readdirWithFileTypes");
      exports2.readdirWithFileTypes = readdirWithFileTypes;
      function readdir(directory, settings) {
        const names = settings.fs.readdirSync(directory);
        return names.map((name) => {
          const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
          const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats)
          };
          if (settings.stats) {
            entry.stats = stats;
          }
          return entry;
        });
      }
      __name(readdir, "readdir");
      exports2.readdir = readdir;
    });
    var require_fs5 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      var fs7 = __require("fs");
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs7.lstat,
        stat: fs7.stat,
        lstatSync: fs7.lstatSync,
        statSync: fs7.statSync,
        readdir: fs7.readdir,
        readdirSync: fs7.readdirSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      __name(createFileSystemAdapter, "createFileSystemAdapter");
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    });
    var require_settings2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var path22 = __require("path");
      var fsStat = require_out();
      var fs7 = require_fs5();
      var Settings = /* @__PURE__ */ __name(class {
        constructor(_options = {}) {
          this._options = _options;
          this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
          this.fs = fs7.createFileSystemAdapter(this._options.fs);
          this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path22.sep);
          this.stats = this._getValue(this._options.stats, false);
          this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
          this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
          });
        }
        _getValue(option, value) {
          return option !== null && option !== void 0 ? option : value;
        }
      }, "Settings");
      exports2.default = Settings;
    });
    var require_out2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
      var async = require_async2();
      var sync = require_sync3();
      var settings_1 = require_settings2();
      exports2.Settings = settings_1.default;
      function scandir(path22, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === "function") {
          return async.read(path22, getSettings(), optionsOrSettingsOrCallback);
        }
        async.read(path22, getSettings(optionsOrSettingsOrCallback), callback);
      }
      __name(scandir, "scandir");
      exports2.scandir = scandir;
      function scandirSync(path22, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings);
        return sync.read(path22, settings);
      }
      __name(scandirSync, "scandirSync");
      exports2.scandirSync = scandirSync;
      function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
          return settingsOrOptions;
        }
        return new settings_1.default(settingsOrOptions);
      }
      __name(getSettings, "getSettings");
    });
    var require_reusify = __commonJS((exports2, module2) => {
      "use strict";
      function reusify(Constructor) {
        var head = new Constructor();
        var tail = head;
        function get() {
          var current = head;
          if (current.next) {
            head = current.next;
          } else {
            head = new Constructor();
            tail = head;
          }
          current.next = null;
          return current;
        }
        __name(get, "get");
        function release(obj) {
          tail.next = obj;
          tail = obj;
        }
        __name(release, "release");
        return {
          get,
          release
        };
      }
      __name(reusify, "reusify");
      module2.exports = reusify;
    });
    var require_queue = __commonJS((exports2, module2) => {
      "use strict";
      var reusify = require_reusify();
      function fastqueue(context, worker, concurrency) {
        if (typeof context === "function") {
          concurrency = worker;
          worker = context;
          context = null;
        }
        if (concurrency < 1) {
          throw new Error("fastqueue concurrency must be greater than 1");
        }
        var cache = reusify(Task);
        var queueHead = null;
        var queueTail = null;
        var _running = 0;
        var errorHandler = null;
        var self2 = {
          push,
          drain: noop,
          saturated: noop,
          pause,
          paused: false,
          concurrency,
          running,
          resume,
          idle,
          length,
          getQueue,
          unshift,
          empty: noop,
          kill,
          killAndDrain,
          error: error2
        };
        return self2;
        function running() {
          return _running;
        }
        __name(running, "running");
        function pause() {
          self2.paused = true;
        }
        __name(pause, "pause");
        function length() {
          var current = queueHead;
          var counter = 0;
          while (current) {
            current = current.next;
            counter++;
          }
          return counter;
        }
        __name(length, "length");
        function getQueue() {
          var current = queueHead;
          var tasks = [];
          while (current) {
            tasks.push(current.value);
            current = current.next;
          }
          return tasks;
        }
        __name(getQueue, "getQueue");
        function resume() {
          if (!self2.paused)
            return;
          self2.paused = false;
          for (var i = 0; i < self2.concurrency; i++) {
            _running++;
            release();
          }
        }
        __name(resume, "resume");
        function idle() {
          return _running === 0 && self2.length() === 0;
        }
        __name(idle, "idle");
        function push(value, done) {
          var current = cache.get();
          current.context = context;
          current.release = release;
          current.value = value;
          current.callback = done || noop;
          current.errorHandler = errorHandler;
          if (_running === self2.concurrency || self2.paused) {
            if (queueTail) {
              queueTail.next = current;
              queueTail = current;
            } else {
              queueHead = current;
              queueTail = current;
              self2.saturated();
            }
          } else {
            _running++;
            worker.call(context, current.value, current.worked);
          }
        }
        __name(push, "push");
        function unshift(value, done) {
          var current = cache.get();
          current.context = context;
          current.release = release;
          current.value = value;
          current.callback = done || noop;
          if (_running === self2.concurrency || self2.paused) {
            if (queueHead) {
              current.next = queueHead;
              queueHead = current;
            } else {
              queueHead = current;
              queueTail = current;
              self2.saturated();
            }
          } else {
            _running++;
            worker.call(context, current.value, current.worked);
          }
        }
        __name(unshift, "unshift");
        function release(holder) {
          if (holder) {
            cache.release(holder);
          }
          var next = queueHead;
          if (next) {
            if (!self2.paused) {
              if (queueTail === queueHead) {
                queueTail = null;
              }
              queueHead = next.next;
              next.next = null;
              worker.call(context, next.value, next.worked);
              if (queueTail === null) {
                self2.empty();
              }
            } else {
              _running--;
            }
          } else if (--_running === 0) {
            self2.drain();
          }
        }
        __name(release, "release");
        function kill() {
          queueHead = null;
          queueTail = null;
          self2.drain = noop;
        }
        __name(kill, "kill");
        function killAndDrain() {
          queueHead = null;
          queueTail = null;
          self2.drain();
          self2.drain = noop;
        }
        __name(killAndDrain, "killAndDrain");
        function error2(handler) {
          errorHandler = handler;
        }
        __name(error2, "error");
      }
      __name(fastqueue, "fastqueue");
      function noop() {
      }
      __name(noop, "noop");
      function Task() {
        this.value = null;
        this.callback = noop;
        this.next = null;
        this.release = noop;
        this.context = null;
        this.errorHandler = null;
        var self2 = this;
        this.worked = /* @__PURE__ */ __name(function worked(err, result) {
          var callback = self2.callback;
          var errorHandler = self2.errorHandler;
          var val = self2.value;
          self2.value = null;
          self2.callback = noop;
          if (self2.errorHandler) {
            errorHandler(err, val);
          }
          callback.call(self2.context, err, result);
          self2.release(self2);
        }, "worked");
      }
      __name(Task, "Task");
      function queueAsPromised(context, worker, concurrency) {
        if (typeof context === "function") {
          concurrency = worker;
          worker = context;
          context = null;
        }
        function asyncWrapper(arg2, cb) {
          worker.call(this, arg2).then(function(res) {
            cb(null, res);
          }, cb);
        }
        __name(asyncWrapper, "asyncWrapper");
        var queue = fastqueue(context, asyncWrapper, concurrency);
        var pushCb = queue.push;
        var unshiftCb = queue.unshift;
        queue.push = push;
        queue.unshift = unshift;
        return queue;
        function push(value) {
          return new Promise(function(resolve2, reject2) {
            pushCb(value, function(err, result) {
              if (err) {
                reject2(err);
                return;
              }
              resolve2(result);
            });
          });
        }
        __name(push, "push");
        function unshift(value) {
          return new Promise(function(resolve2, reject2) {
            unshiftCb(value, function(err, result) {
              if (err) {
                reject2(err);
                return;
              }
              resolve2(result);
            });
          });
        }
        __name(unshift, "unshift");
      }
      __name(queueAsPromised, "queueAsPromised");
      module2.exports = fastqueue;
      module2.exports.promise = queueAsPromised;
    });
    var require_common5 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
      function isFatalError(settings, error2) {
        if (settings.errorFilter === null) {
          return true;
        }
        return !settings.errorFilter(error2);
      }
      __name(isFatalError, "isFatalError");
      exports2.isFatalError = isFatalError;
      function isAppliedFilter(filter, value) {
        return filter === null || filter(value);
      }
      __name(isAppliedFilter, "isAppliedFilter");
      exports2.isAppliedFilter = isAppliedFilter;
      function replacePathSegmentSeparator(filepath, separator) {
        return filepath.split(/[/\\]/).join(separator);
      }
      __name(replacePathSegmentSeparator, "replacePathSegmentSeparator");
      exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
      function joinPathSegments(a, b, separator) {
        if (a === "") {
          return b;
        }
        if (a.endsWith(separator)) {
          return a + b;
        }
        return a + separator + b;
      }
      __name(joinPathSegments, "joinPathSegments");
      exports2.joinPathSegments = joinPathSegments;
    });
    var require_reader = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var common = require_common5();
      var Reader = /* @__PURE__ */ __name(class {
        constructor(_root, _settings) {
          this._root = _root;
          this._settings = _settings;
          this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
        }
      }, "Reader");
      exports2.default = Reader;
    });
    var require_async3 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var events_1 = __require("events");
      var fsScandir = require_out2();
      var fastq = require_queue();
      var common = require_common5();
      var reader_1 = require_reader();
      var AsyncReader = /* @__PURE__ */ __name(class extends reader_1.default {
        constructor(_root, _settings) {
          super(_root, _settings);
          this._settings = _settings;
          this._scandir = fsScandir.scandir;
          this._emitter = new events_1.EventEmitter();
          this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
          this._isFatalError = false;
          this._isDestroyed = false;
          this._queue.drain = () => {
            if (!this._isFatalError) {
              this._emitter.emit("end");
            }
          };
        }
        read() {
          this._isFatalError = false;
          this._isDestroyed = false;
          setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
          });
          return this._emitter;
        }
        get isDestroyed() {
          return this._isDestroyed;
        }
        destroy() {
          if (this._isDestroyed) {
            throw new Error("The reader is already destroyed");
          }
          this._isDestroyed = true;
          this._queue.killAndDrain();
        }
        onEntry(callback) {
          this._emitter.on("entry", callback);
        }
        onError(callback) {
          this._emitter.once("error", callback);
        }
        onEnd(callback) {
          this._emitter.once("end", callback);
        }
        _pushToQueue(directory, base) {
          const queueItem = { directory, base };
          this._queue.push(queueItem, (error2) => {
            if (error2 !== null) {
              this._handleError(error2);
            }
          });
        }
        _worker(item, done) {
          this._scandir(item.directory, this._settings.fsScandirSettings, (error2, entries) => {
            if (error2 !== null) {
              return done(error2, void 0);
            }
            for (const entry of entries) {
              this._handleEntry(entry, item.base);
            }
            done(null, void 0);
          });
        }
        _handleError(error2) {
          if (this._isDestroyed || !common.isFatalError(this._settings, error2)) {
            return;
          }
          this._isFatalError = true;
          this._isDestroyed = true;
          this._emitter.emit("error", error2);
        }
        _handleEntry(entry, base) {
          if (this._isDestroyed || this._isFatalError) {
            return;
          }
          const fullpath = entry.path;
          if (base !== void 0) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
          }
          if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
          }
          if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
          }
        }
        _emitEntry(entry) {
          this._emitter.emit("entry", entry);
        }
      }, "AsyncReader");
      exports2.default = AsyncReader;
    });
    var require_async4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var async_1 = require_async3();
      var AsyncProvider = /* @__PURE__ */ __name(class {
        constructor(_root, _settings) {
          this._root = _root;
          this._settings = _settings;
          this._reader = new async_1.default(this._root, this._settings);
          this._storage = new Set();
        }
        read(callback) {
          this._reader.onError((error2) => {
            callFailureCallback(callback, error2);
          });
          this._reader.onEntry((entry) => {
            this._storage.add(entry);
          });
          this._reader.onEnd(() => {
            callSuccessCallback(callback, [...this._storage]);
          });
          this._reader.read();
        }
      }, "AsyncProvider");
      exports2.default = AsyncProvider;
      function callFailureCallback(callback, error2) {
        callback(error2);
      }
      __name(callFailureCallback, "callFailureCallback");
      function callSuccessCallback(callback, entries) {
        callback(null, entries);
      }
      __name(callSuccessCallback, "callSuccessCallback");
    });
    var require_stream3 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var stream_1 = __require("stream");
      var async_1 = require_async3();
      var StreamProvider = /* @__PURE__ */ __name(class {
        constructor(_root, _settings) {
          this._root = _root;
          this._settings = _settings;
          this._reader = new async_1.default(this._root, this._settings);
          this._stream = new stream_1.Readable({
            objectMode: true,
            read: () => {
            },
            destroy: () => {
              if (!this._reader.isDestroyed) {
                this._reader.destroy();
              }
            }
          });
        }
        read() {
          this._reader.onError((error2) => {
            this._stream.emit("error", error2);
          });
          this._reader.onEntry((entry) => {
            this._stream.push(entry);
          });
          this._reader.onEnd(() => {
            this._stream.push(null);
          });
          this._reader.read();
          return this._stream;
        }
      }, "StreamProvider");
      exports2.default = StreamProvider;
    });
    var require_sync4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var fsScandir = require_out2();
      var common = require_common5();
      var reader_1 = require_reader();
      var SyncReader = /* @__PURE__ */ __name(class extends reader_1.default {
        constructor() {
          super(...arguments);
          this._scandir = fsScandir.scandirSync;
          this._storage = new Set();
          this._queue = new Set();
        }
        read() {
          this._pushToQueue(this._root, this._settings.basePath);
          this._handleQueue();
          return [...this._storage];
        }
        _pushToQueue(directory, base) {
          this._queue.add({ directory, base });
        }
        _handleQueue() {
          for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
          }
        }
        _handleDirectory(directory, base) {
          try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
              this._handleEntry(entry, base);
            }
          } catch (error2) {
            this._handleError(error2);
          }
        }
        _handleError(error2) {
          if (!common.isFatalError(this._settings, error2)) {
            return;
          }
          throw error2;
        }
        _handleEntry(entry, base) {
          const fullpath = entry.path;
          if (base !== void 0) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
          }
          if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
          }
          if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
          }
        }
        _pushToStorage(entry) {
          this._storage.add(entry);
        }
      }, "SyncReader");
      exports2.default = SyncReader;
    });
    var require_sync5 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var sync_1 = require_sync4();
      var SyncProvider = /* @__PURE__ */ __name(class {
        constructor(_root, _settings) {
          this._root = _root;
          this._settings = _settings;
          this._reader = new sync_1.default(this._root, this._settings);
        }
        read() {
          return this._reader.read();
        }
      }, "SyncProvider");
      exports2.default = SyncProvider;
    });
    var require_settings3 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var path22 = __require("path");
      var fsScandir = require_out2();
      var Settings = /* @__PURE__ */ __name(class {
        constructor(_options = {}) {
          this._options = _options;
          this.basePath = this._getValue(this._options.basePath, void 0);
          this.concurrency = this._getValue(this._options.concurrency, Infinity);
          this.deepFilter = this._getValue(this._options.deepFilter, null);
          this.entryFilter = this._getValue(this._options.entryFilter, null);
          this.errorFilter = this._getValue(this._options.errorFilter, null);
          this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path22.sep);
          this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
          });
        }
        _getValue(option, value) {
          return option !== null && option !== void 0 ? option : value;
        }
      }, "Settings");
      exports2.default = Settings;
    });
    var require_out3 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
      var async_1 = require_async4();
      var stream_1 = require_stream3();
      var sync_1 = require_sync5();
      var settings_1 = require_settings3();
      exports2.Settings = settings_1.default;
      function walk(directory, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === "function") {
          return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        }
        new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
      }
      __name(walk, "walk");
      exports2.walk = walk;
      function walkSync(directory, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings);
        const provider = new sync_1.default(directory, settings);
        return provider.read();
      }
      __name(walkSync, "walkSync");
      exports2.walkSync = walkSync;
      function walkStream(directory, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings);
        const provider = new stream_1.default(directory, settings);
        return provider.read();
      }
      __name(walkStream, "walkStream");
      exports2.walkStream = walkStream;
      function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
          return settingsOrOptions;
        }
        return new settings_1.default(settingsOrOptions);
      }
      __name(getSettings, "getSettings");
    });
    var require_reader2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var path22 = __require("path");
      var fsStat = require_out();
      var utils = require_utils4();
      var Reader = /* @__PURE__ */ __name(class {
        constructor(_settings) {
          this._settings = _settings;
          this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
          });
        }
        _getFullEntryPath(filepath) {
          return path22.resolve(this._settings.cwd, filepath);
        }
        _makeEntry(stats, pattern) {
          const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats)
          };
          if (this._settings.stats) {
            entry.stats = stats;
          }
          return entry;
        }
        _isFatalError(error2) {
          return !utils.errno.isEnoentCodeError(error2) && !this._settings.suppressErrors;
        }
      }, "Reader");
      exports2.default = Reader;
    });
    var require_stream4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var stream_1 = __require("stream");
      var fsStat = require_out();
      var fsWalk = require_out3();
      var reader_1 = require_reader2();
      var ReaderStream = /* @__PURE__ */ __name(class extends reader_1.default {
        constructor() {
          super(...arguments);
          this._walkStream = fsWalk.walkStream;
          this._stat = fsStat.stat;
        }
        dynamic(root, options2) {
          return this._walkStream(root, options2);
        }
        static(patterns, options2) {
          const filepaths = patterns.map(this._getFullEntryPath, this);
          const stream3 = new stream_1.PassThrough({ objectMode: true });
          stream3._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options2).then((entry) => {
              if (entry !== null && options2.entryFilter(entry)) {
                stream3.push(entry);
              }
              if (index === filepaths.length - 1) {
                stream3.end();
              }
              done();
            }).catch(done);
          };
          for (let i = 0; i < filepaths.length; i++) {
            stream3.write(i);
          }
          return stream3;
        }
        _getEntry(filepath, pattern, options2) {
          return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error2) => {
            if (options2.errorFilter(error2)) {
              return null;
            }
            throw error2;
          });
        }
        _getStat(filepath) {
          return new Promise((resolve2, reject2) => {
            this._stat(filepath, this._fsStatSettings, (error2, stats) => {
              return error2 === null ? resolve2(stats) : reject2(error2);
            });
          });
        }
      }, "ReaderStream");
      exports2.default = ReaderStream;
    });
    var require_matcher = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var utils = require_utils4();
      var Matcher = /* @__PURE__ */ __name(class {
        constructor(_patterns, _settings, _micromatchOptions) {
          this._patterns = _patterns;
          this._settings = _settings;
          this._micromatchOptions = _micromatchOptions;
          this._storage = [];
          this._fillStorage();
        }
        _fillStorage() {
          const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
          for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
              complete: sections.length <= 1,
              pattern,
              segments,
              sections
            });
          }
        }
        _getPatternSegments(pattern) {
          const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
          return parts.map((part) => {
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
              return {
                dynamic: false,
                pattern: part
              };
            }
            return {
              dynamic: true,
              pattern: part,
              patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
            };
          });
        }
        _splitSegmentsIntoSections(segments) {
          return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
        }
      }, "Matcher");
      exports2.default = Matcher;
    });
    var require_partial = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var matcher_1 = require_matcher();
      var PartialMatcher = /* @__PURE__ */ __name(class extends matcher_1.default {
        match(filepath) {
          const parts = filepath.split("/");
          const levels = parts.length;
          const patterns = this._storage.filter((info2) => !info2.complete || info2.segments.length > levels);
          for (const pattern of patterns) {
            const section = pattern.sections[0];
            if (!pattern.complete && levels > section.length) {
              return true;
            }
            const match = parts.every((part, index) => {
              const segment = pattern.segments[index];
              if (segment.dynamic && segment.patternRe.test(part)) {
                return true;
              }
              if (!segment.dynamic && segment.pattern === part) {
                return true;
              }
              return false;
            });
            if (match) {
              return true;
            }
          }
          return false;
        }
      }, "PartialMatcher");
      exports2.default = PartialMatcher;
    });
    var require_deep = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var utils = require_utils4();
      var partial_1 = require_partial();
      var DeepFilter = /* @__PURE__ */ __name(class {
        constructor(_settings, _micromatchOptions) {
          this._settings = _settings;
          this._micromatchOptions = _micromatchOptions;
        }
        getFilter(basePath, positive, negative) {
          const matcher = this._getMatcher(positive);
          const negativeRe = this._getNegativePatternsRe(negative);
          return (entry) => this._filter(basePath, entry, matcher, negativeRe);
        }
        _getMatcher(patterns) {
          return new partial_1.default(patterns, this._settings, this._micromatchOptions);
        }
        _getNegativePatternsRe(patterns) {
          const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
          return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
        }
        _filter(basePath, entry, matcher, negativeRe) {
          if (this._isSkippedByDeep(basePath, entry.path)) {
            return false;
          }
          if (this._isSkippedSymbolicLink(entry)) {
            return false;
          }
          const filepath = utils.path.removeLeadingDotSegment(entry.path);
          if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
          }
          return this._isSkippedByNegativePatterns(filepath, negativeRe);
        }
        _isSkippedByDeep(basePath, entryPath) {
          if (this._settings.deep === Infinity) {
            return false;
          }
          return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
        }
        _getEntryLevel(basePath, entryPath) {
          const entryPathDepth = entryPath.split("/").length;
          if (basePath === "") {
            return entryPathDepth;
          }
          const basePathDepth = basePath.split("/").length;
          return entryPathDepth - basePathDepth;
        }
        _isSkippedSymbolicLink(entry) {
          return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
        }
        _isSkippedByPositivePatterns(entryPath, matcher) {
          return !this._settings.baseNameMatch && !matcher.match(entryPath);
        }
        _isSkippedByNegativePatterns(entryPath, patternsRe) {
          return !utils.pattern.matchAny(entryPath, patternsRe);
        }
      }, "DeepFilter");
      exports2.default = DeepFilter;
    });
    var require_entry = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var utils = require_utils4();
      var EntryFilter = /* @__PURE__ */ __name(class {
        constructor(_settings, _micromatchOptions) {
          this._settings = _settings;
          this._micromatchOptions = _micromatchOptions;
          this.index = new Map();
        }
        getFilter(positive, negative) {
          const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
          const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
          return (entry) => this._filter(entry, positiveRe, negativeRe);
        }
        _filter(entry, positiveRe, negativeRe) {
          if (this._settings.unique && this._isDuplicateEntry(entry)) {
            return false;
          }
          if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
          }
          if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
            return false;
          }
          const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
          const isMatched2 = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
          if (this._settings.unique && isMatched2) {
            this._createIndexRecord(entry);
          }
          return isMatched2;
        }
        _isDuplicateEntry(entry) {
          return this.index.has(entry.path);
        }
        _createIndexRecord(entry) {
          this.index.set(entry.path, void 0);
        }
        _onlyFileFilter(entry) {
          return this._settings.onlyFiles && !entry.dirent.isFile();
        }
        _onlyDirectoryFilter(entry) {
          return this._settings.onlyDirectories && !entry.dirent.isDirectory();
        }
        _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
          if (!this._settings.absolute) {
            return false;
          }
          const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
          return utils.pattern.matchAny(fullpath, patternsRe);
        }
        _isMatchToPatterns(entryPath, patternsRe) {
          const filepath = utils.path.removeLeadingDotSegment(entryPath);
          return utils.pattern.matchAny(filepath, patternsRe);
        }
      }, "EntryFilter");
      exports2.default = EntryFilter;
    });
    var require_error2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var utils = require_utils4();
      var ErrorFilter = /* @__PURE__ */ __name(class {
        constructor(_settings) {
          this._settings = _settings;
        }
        getFilter() {
          return (error2) => this._isNonFatalError(error2);
        }
        _isNonFatalError(error2) {
          return utils.errno.isEnoentCodeError(error2) || this._settings.suppressErrors;
        }
      }, "ErrorFilter");
      exports2.default = ErrorFilter;
    });
    var require_entry2 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var utils = require_utils4();
      var EntryTransformer = /* @__PURE__ */ __name(class {
        constructor(_settings) {
          this._settings = _settings;
        }
        getTransformer() {
          return (entry) => this._transform(entry);
        }
        _transform(entry) {
          let filepath = entry.path;
          if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils.path.unixify(filepath);
          }
          if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += "/";
          }
          if (!this._settings.objectMode) {
            return filepath;
          }
          return Object.assign(Object.assign({}, entry), { path: filepath });
        }
      }, "EntryTransformer");
      exports2.default = EntryTransformer;
    });
    var require_provider = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var path22 = __require("path");
      var deep_1 = require_deep();
      var entry_1 = require_entry();
      var error_1 = require_error2();
      var entry_2 = require_entry2();
      var Provider = /* @__PURE__ */ __name(class {
        constructor(_settings) {
          this._settings = _settings;
          this.errorFilter = new error_1.default(this._settings);
          this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
          this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
          this.entryTransformer = new entry_2.default(this._settings);
        }
        _getRootDirectory(task) {
          return path22.resolve(this._settings.cwd, task.base);
        }
        _getReaderOptions(task) {
          const basePath = task.base === "." ? "" : task.base;
          return {
            basePath,
            pathSegmentSeparator: "/",
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
          };
        }
        _getMicromatchOptions() {
          return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
          };
        }
      }, "Provider");
      exports2.default = Provider;
    });
    var require_async5 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var stream_1 = require_stream4();
      var provider_1 = require_provider();
      var ProviderAsync = /* @__PURE__ */ __name(class extends provider_1.default {
        constructor() {
          super(...arguments);
          this._reader = new stream_1.default(this._settings);
        }
        read(task) {
          const root = this._getRootDirectory(task);
          const options2 = this._getReaderOptions(task);
          const entries = [];
          return new Promise((resolve2, reject2) => {
            const stream3 = this.api(root, task, options2);
            stream3.once("error", reject2);
            stream3.on("data", (entry) => entries.push(options2.transform(entry)));
            stream3.once("end", () => resolve2(entries));
          });
        }
        api(root, task, options2) {
          if (task.dynamic) {
            return this._reader.dynamic(root, options2);
          }
          return this._reader.static(task.patterns, options2);
        }
      }, "ProviderAsync");
      exports2.default = ProviderAsync;
    });
    var require_stream5 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var stream_1 = __require("stream");
      var stream_2 = require_stream4();
      var provider_1 = require_provider();
      var ProviderStream = /* @__PURE__ */ __name(class extends provider_1.default {
        constructor() {
          super(...arguments);
          this._reader = new stream_2.default(this._settings);
        }
        read(task) {
          const root = this._getRootDirectory(task);
          const options2 = this._getReaderOptions(task);
          const source = this.api(root, task, options2);
          const destination = new stream_1.Readable({ objectMode: true, read: () => {
          } });
          source.once("error", (error2) => destination.emit("error", error2)).on("data", (entry) => destination.emit("data", options2.transform(entry))).once("end", () => destination.emit("end"));
          destination.once("close", () => source.destroy());
          return destination;
        }
        api(root, task, options2) {
          if (task.dynamic) {
            return this._reader.dynamic(root, options2);
          }
          return this._reader.static(task.patterns, options2);
        }
      }, "ProviderStream");
      exports2.default = ProviderStream;
    });
    var require_sync6 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var fsStat = require_out();
      var fsWalk = require_out3();
      var reader_1 = require_reader2();
      var ReaderSync = /* @__PURE__ */ __name(class extends reader_1.default {
        constructor() {
          super(...arguments);
          this._walkSync = fsWalk.walkSync;
          this._statSync = fsStat.statSync;
        }
        dynamic(root, options2) {
          return this._walkSync(root, options2);
        }
        static(patterns, options2) {
          const entries = [];
          for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options2);
            if (entry === null || !options2.entryFilter(entry)) {
              continue;
            }
            entries.push(entry);
          }
          return entries;
        }
        _getEntry(filepath, pattern, options2) {
          try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
          } catch (error2) {
            if (options2.errorFilter(error2)) {
              return null;
            }
            throw error2;
          }
        }
        _getStat(filepath) {
          return this._statSync(filepath, this._fsStatSettings);
        }
      }, "ReaderSync");
      exports2.default = ReaderSync;
    });
    var require_sync7 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var sync_1 = require_sync6();
      var provider_1 = require_provider();
      var ProviderSync = /* @__PURE__ */ __name(class extends provider_1.default {
        constructor() {
          super(...arguments);
          this._reader = new sync_1.default(this._settings);
        }
        read(task) {
          const root = this._getRootDirectory(task);
          const options2 = this._getReaderOptions(task);
          const entries = this.api(root, task, options2);
          return entries.map(options2.transform);
        }
        api(root, task, options2) {
          if (task.dynamic) {
            return this._reader.dynamic(root, options2);
          }
          return this._reader.static(task.patterns, options2);
        }
      }, "ProviderSync");
      exports2.default = ProviderSync;
    });
    var require_settings4 = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
      var fs7 = __require("fs");
      var os2 = __require("os");
      var CPU_COUNT = Math.max(os2.cpus().length, 1);
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
        lstat: fs7.lstat,
        lstatSync: fs7.lstatSync,
        stat: fs7.stat,
        statSync: fs7.statSync,
        readdir: fs7.readdir,
        readdirSync: fs7.readdirSync
      };
      var Settings = /* @__PURE__ */ __name(class {
        constructor(_options = {}) {
          this._options = _options;
          this.absolute = this._getValue(this._options.absolute, false);
          this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
          this.braceExpansion = this._getValue(this._options.braceExpansion, true);
          this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
          this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
          this.cwd = this._getValue(this._options.cwd, process.cwd());
          this.deep = this._getValue(this._options.deep, Infinity);
          this.dot = this._getValue(this._options.dot, false);
          this.extglob = this._getValue(this._options.extglob, true);
          this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
          this.fs = this._getFileSystemMethods(this._options.fs);
          this.globstar = this._getValue(this._options.globstar, true);
          this.ignore = this._getValue(this._options.ignore, []);
          this.markDirectories = this._getValue(this._options.markDirectories, false);
          this.objectMode = this._getValue(this._options.objectMode, false);
          this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
          this.onlyFiles = this._getValue(this._options.onlyFiles, true);
          this.stats = this._getValue(this._options.stats, false);
          this.suppressErrors = this._getValue(this._options.suppressErrors, false);
          this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
          this.unique = this._getValue(this._options.unique, true);
          if (this.onlyDirectories) {
            this.onlyFiles = false;
          }
          if (this.stats) {
            this.objectMode = true;
          }
        }
        _getValue(option, value) {
          return option === void 0 ? value : option;
        }
        _getFileSystemMethods(methods = {}) {
          return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
        }
      }, "Settings");
      exports2.default = Settings;
    });
    var require_out4 = __commonJS((exports2, module2) => {
      "use strict";
      var taskManager = require_tasks();
      var async_1 = require_async5();
      var stream_1 = require_stream5();
      var sync_1 = require_sync7();
      var settings_1 = require_settings4();
      var utils = require_utils4();
      async function FastGlob(source, options2) {
        assertPatternsInput(source);
        const works = getWorks(source, async_1.default, options2);
        const result = await Promise.all(works);
        return utils.array.flatten(result);
      }
      __name(FastGlob, "FastGlob");
      (function(FastGlob2) {
        function sync(source, options2) {
          assertPatternsInput(source);
          const works = getWorks(source, sync_1.default, options2);
          return utils.array.flatten(works);
        }
        __name(sync, "sync");
        FastGlob2.sync = sync;
        function stream3(source, options2) {
          assertPatternsInput(source);
          const works = getWorks(source, stream_1.default, options2);
          return utils.stream.merge(works);
        }
        __name(stream3, "stream");
        FastGlob2.stream = stream3;
        function generateTasks(source, options2) {
          assertPatternsInput(source);
          const patterns = [].concat(source);
          const settings = new settings_1.default(options2);
          return taskManager.generate(patterns, settings);
        }
        __name(generateTasks, "generateTasks");
        FastGlob2.generateTasks = generateTasks;
        function isDynamicPattern(source, options2) {
          assertPatternsInput(source);
          const settings = new settings_1.default(options2);
          return utils.pattern.isDynamicPattern(source, settings);
        }
        __name(isDynamicPattern, "isDynamicPattern");
        FastGlob2.isDynamicPattern = isDynamicPattern;
        function escapePath(source) {
          assertPatternsInput(source);
          return utils.path.escape(source);
        }
        __name(escapePath, "escapePath");
        FastGlob2.escapePath = escapePath;
      })(FastGlob || (FastGlob = {}));
      function getWorks(source, _Provider, options2) {
        const patterns = [].concat(source);
        const settings = new settings_1.default(options2);
        const tasks = taskManager.generate(patterns, settings);
        const provider = new _Provider(settings);
        return tasks.map(provider.read, provider);
      }
      __name(getWorks, "getWorks");
      function assertPatternsInput(input) {
        const source = [].concat(input);
        const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
        if (!isValidSource) {
          throw new TypeError("Patterns must be a string (non empty) or an array of strings");
        }
      }
      __name(assertPatternsInput, "assertPatternsInput");
      module2.exports = FastGlob;
    });
    var require_path_type = __commonJS((exports2) => {
      "use strict";
      var { promisify: promisify3 } = __require("util");
      var fs7 = __require("fs");
      async function isType(fsStatType, statsMethodName, filePath) {
        if (typeof filePath !== "string") {
          throw new TypeError(`Expected a string, got ${typeof filePath}`);
        }
        try {
          const stats = await promisify3(fs7[fsStatType])(filePath);
          return stats[statsMethodName]();
        } catch (error2) {
          if (error2.code === "ENOENT") {
            return false;
          }
          throw error2;
        }
      }
      __name(isType, "isType");
      function isTypeSync(fsStatType, statsMethodName, filePath) {
        if (typeof filePath !== "string") {
          throw new TypeError(`Expected a string, got ${typeof filePath}`);
        }
        try {
          return fs7[fsStatType](filePath)[statsMethodName]();
        } catch (error2) {
          if (error2.code === "ENOENT") {
            return false;
          }
          throw error2;
        }
      }
      __name(isTypeSync, "isTypeSync");
      exports2.isFile = isType.bind(null, "stat", "isFile");
      exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
      exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
      exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
      exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
      exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
    });
    var require_dir_glob = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      var pathType = require_path_type();
      var getExtensions = /* @__PURE__ */ __name((extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0], "getExtensions");
      var getPath = /* @__PURE__ */ __name((filepath, cwd) => {
        const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
        return path22.isAbsolute(pth) ? pth : path22.join(cwd, pth);
      }, "getPath");
      var addExtensions = /* @__PURE__ */ __name((file2, extensions) => {
        if (path22.extname(file2)) {
          return `**/${file2}`;
        }
        return `**/${file2}.${getExtensions(extensions)}`;
      }, "addExtensions");
      var getGlob = /* @__PURE__ */ __name((directory, options2) => {
        if (options2.files && !Array.isArray(options2.files)) {
          throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options2.files}\``);
        }
        if (options2.extensions && !Array.isArray(options2.extensions)) {
          throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options2.extensions}\``);
        }
        if (options2.files && options2.extensions) {
          return options2.files.map((x) => path22.posix.join(directory, addExtensions(x, options2.extensions)));
        }
        if (options2.files) {
          return options2.files.map((x) => path22.posix.join(directory, `**/${x}`));
        }
        if (options2.extensions) {
          return [path22.posix.join(directory, `**/*.${getExtensions(options2.extensions)}`)];
        }
        return [path22.posix.join(directory, "**")];
      }, "getGlob");
      module2.exports = async (input, options2) => {
        options2 = {
          cwd: process.cwd(),
          ...options2
        };
        if (typeof options2.cwd !== "string") {
          throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options2.cwd}\``);
        }
        const globs = await Promise.all([].concat(input).map(async (x) => {
          const isDirectory = await pathType.isDirectory(getPath(x, options2.cwd));
          return isDirectory ? getGlob(x, options2) : x;
        }));
        return [].concat.apply([], globs);
      };
      module2.exports.sync = (input, options2) => {
        options2 = {
          cwd: process.cwd(),
          ...options2
        };
        if (typeof options2.cwd !== "string") {
          throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options2.cwd}\``);
        }
        const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options2.cwd)) ? getGlob(x, options2) : x);
        return [].concat.apply([], globs);
      };
    });
    var require_ignore = __commonJS((exports2, module2) => {
      function makeArray(subject) {
        return Array.isArray(subject) ? subject : [subject];
      }
      __name(makeArray, "makeArray");
      var EMPTY = "";
      var SPACE = " ";
      var ESCAPE = "\\";
      var REGEX_TEST_BLANK_LINE = /^\s+$/;
      var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
      var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
      var REGEX_SPLITALL_CRLF = /\r?\n/g;
      var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
      var SLASH = "/";
      var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
      var define2 = /* @__PURE__ */ __name((object, key, value) => Object.defineProperty(object, key, { value }), "define");
      var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
      var sanitizeRange = /* @__PURE__ */ __name((range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY), "sanitizeRange");
      var cleanRangeBackSlash = /* @__PURE__ */ __name((slashes) => {
        const { length } = slashes;
        return slashes.slice(0, length - length % 2);
      }, "cleanRangeBackSlash");
      var REPLACERS = [
        [
          /\\?\s+$/,
          (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
        ],
        [
          /\\\s/g,
          () => SPACE
        ],
        [
          /[\\$.|*+(){^]/g,
          (match) => `\\${match}`
        ],
        [
          /(?!\\)\?/g,
          () => "[^/]"
        ],
        [
          /^\//,
          () => "^"
        ],
        [
          /\//g,
          () => "\\/"
        ],
        [
          /^\^*\\\*\\\*\\\//,
          () => "^(?:.*\\/)?"
        ],
        [
          /^(?=[^^])/,
          /* @__PURE__ */ __name(function startingReplacer() {
            return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
          }, "startingReplacer")
        ],
        [
          /\\\/\\\*\\\*(?=\\\/|$)/g,
          (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
        ],
        [
          /(^|[^\\]+)\\\*(?=.+)/g,
          (_, p1) => `${p1}[^\\/]*`
        ],
        [
          /\\\\\\(?=[$.|*+(){^])/g,
          () => ESCAPE
        ],
        [
          /\\\\/g,
          () => ESCAPE
        ],
        [
          /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
          (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
        ],
        [
          /(?:[^*])$/,
          (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
        ],
        [
          /(\^|\\\/)?\\\*$/,
          (_, p1) => {
            const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
            return `${prefix}(?=$|\\/$)`;
          }
        ]
      ];
      var regexCache = Object.create(null);
      var makeRegex = /* @__PURE__ */ __name((pattern, negative, ignorecase) => {
        const r = regexCache[pattern];
        if (r) {
          return r;
        }
        const source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
        return regexCache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
      }, "makeRegex");
      var isString = /* @__PURE__ */ __name((subject) => typeof subject === "string", "isString");
      var checkPattern = /* @__PURE__ */ __name((pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0, "checkPattern");
      var splitPattern = /* @__PURE__ */ __name((pattern) => pattern.split(REGEX_SPLITALL_CRLF), "splitPattern");
      var IgnoreRule = /* @__PURE__ */ __name(class {
        constructor(origin, pattern, negative, regex) {
          this.origin = origin;
          this.pattern = pattern;
          this.negative = negative;
          this.regex = regex;
        }
      }, "IgnoreRule");
      var createRule = /* @__PURE__ */ __name((pattern, ignorecase) => {
        const origin = pattern;
        let negative = false;
        if (pattern.indexOf("!") === 0) {
          negative = true;
          pattern = pattern.substr(1);
        }
        pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
        const regex = makeRegex(pattern, negative, ignorecase);
        return new IgnoreRule(origin, pattern, negative, regex);
      }, "createRule");
      var throwError = /* @__PURE__ */ __name((message, Ctor) => {
        throw new Ctor(message);
      }, "throwError");
      var checkPath = /* @__PURE__ */ __name((path22, originalPath, doThrow) => {
        if (!isString(path22)) {
          return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
        }
        if (!path22) {
          return doThrow(`path must not be empty`, TypeError);
        }
        if (checkPath.isNotRelative(path22)) {
          const r = "`path.relative()`d";
          return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
        }
        return true;
      }, "checkPath");
      var isNotRelative = /* @__PURE__ */ __name((path22) => REGEX_TEST_INVALID_PATH.test(path22), "isNotRelative");
      checkPath.isNotRelative = isNotRelative;
      checkPath.convert = (p) => p;
      var Ignore = /* @__PURE__ */ __name(class {
        constructor({
          ignorecase = true
        } = {}) {
          this._rules = [];
          this._ignorecase = ignorecase;
          define2(this, KEY_IGNORE, true);
          this._initCache();
        }
        _initCache() {
          this._ignoreCache = Object.create(null);
          this._testCache = Object.create(null);
        }
        _addPattern(pattern) {
          if (pattern && pattern[KEY_IGNORE]) {
            this._rules = this._rules.concat(pattern._rules);
            this._added = true;
            return;
          }
          if (checkPattern(pattern)) {
            const rule = createRule(pattern, this._ignorecase);
            this._added = true;
            this._rules.push(rule);
          }
        }
        add(pattern) {
          this._added = false;
          makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
          if (this._added) {
            this._initCache();
          }
          return this;
        }
        addPattern(pattern) {
          return this.add(pattern);
        }
        _testOne(path22, checkUnignored) {
          let ignored = false;
          let unignored = false;
          this._rules.forEach((rule) => {
            const { negative } = rule;
            if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
              return;
            }
            const matched = rule.regex.test(path22);
            if (matched) {
              ignored = !negative;
              unignored = negative;
            }
          });
          return {
            ignored,
            unignored
          };
        }
        _test(originalPath, cache, checkUnignored, slices) {
          const path22 = originalPath && checkPath.convert(originalPath);
          checkPath(path22, originalPath, throwError);
          return this._t(path22, cache, checkUnignored, slices);
        }
        _t(path22, cache, checkUnignored, slices) {
          if (path22 in cache) {
            return cache[path22];
          }
          if (!slices) {
            slices = path22.split(SLASH);
          }
          slices.pop();
          if (!slices.length) {
            return cache[path22] = this._testOne(path22, checkUnignored);
          }
          const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
          return cache[path22] = parent.ignored ? parent : this._testOne(path22, checkUnignored);
        }
        ignores(path22) {
          return this._test(path22, this._ignoreCache, false).ignored;
        }
        createFilter() {
          return (path22) => !this.ignores(path22);
        }
        filter(paths) {
          return makeArray(paths).filter(this.createFilter());
        }
        test(path22) {
          return this._test(path22, this._testCache, true);
        }
      }, "Ignore");
      var factory = /* @__PURE__ */ __name((options2) => new Ignore(options2), "factory");
      var returnFalse = /* @__PURE__ */ __name(() => false, "returnFalse");
      var isPathValid = /* @__PURE__ */ __name((path22) => checkPath(path22 && checkPath.convert(path22), path22, returnFalse), "isPathValid");
      factory.isPathValid = isPathValid;
      factory.default = factory;
      module2.exports = factory;
      if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
        const makePosix = /* @__PURE__ */ __name((str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/"), "makePosix");
        checkPath.convert = makePosix;
        const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
        checkPath.isNotRelative = (path22) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path22) || isNotRelative(path22);
      }
    });
    var require_slash = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = (path22) => {
        const isExtendedLengthPath = /^\\\\\?\\/.test(path22);
        const hasNonAscii = /[^\u0000-\u0080]+/.test(path22);
        if (isExtendedLengthPath || hasNonAscii) {
          return path22;
        }
        return path22.replace(/\\/g, "/");
      };
    });
    var require_gitignore = __commonJS((exports2, module2) => {
      "use strict";
      var { promisify: promisify3 } = __require("util");
      var fs7 = __require("fs");
      var path22 = __require("path");
      var fastGlob = require_out4();
      var gitIgnore = require_ignore();
      var slash = require_slash();
      var DEFAULT_IGNORE = [
        "**/node_modules/**",
        "**/flow-typed/**",
        "**/coverage/**",
        "**/.git"
      ];
      var readFileP = promisify3(fs7.readFile);
      var mapGitIgnorePatternTo = /* @__PURE__ */ __name((base) => (ignore) => {
        if (ignore.startsWith("!")) {
          return "!" + path22.posix.join(base, ignore.slice(1));
        }
        return path22.posix.join(base, ignore);
      }, "mapGitIgnorePatternTo");
      var parseGitIgnore = /* @__PURE__ */ __name((content, options2) => {
        const base = slash(path22.relative(options2.cwd, path22.dirname(options2.fileName)));
        return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
      }, "parseGitIgnore");
      var reduceIgnore = /* @__PURE__ */ __name((files) => {
        const ignores = gitIgnore();
        for (const file2 of files) {
          ignores.add(parseGitIgnore(file2.content, {
            cwd: file2.cwd,
            fileName: file2.filePath
          }));
        }
        return ignores;
      }, "reduceIgnore");
      var ensureAbsolutePathForCwd = /* @__PURE__ */ __name((cwd, p) => {
        cwd = slash(cwd);
        if (path22.isAbsolute(p)) {
          if (p.startsWith(cwd)) {
            return p;
          }
          throw new Error(`Path ${p} is not in cwd ${cwd}`);
        }
        return path22.join(cwd, p);
      }, "ensureAbsolutePathForCwd");
      var getIsIgnoredPredecate = /* @__PURE__ */ __name((ignores, cwd) => {
        return (p) => ignores.ignores(slash(path22.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
      }, "getIsIgnoredPredecate");
      var getFile = /* @__PURE__ */ __name(async (file2, cwd) => {
        const filePath = path22.join(cwd, file2);
        const content = await readFileP(filePath, "utf8");
        return {
          cwd,
          filePath,
          content
        };
      }, "getFile");
      var getFileSync = /* @__PURE__ */ __name((file2, cwd) => {
        const filePath = path22.join(cwd, file2);
        const content = fs7.readFileSync(filePath, "utf8");
        return {
          cwd,
          filePath,
          content
        };
      }, "getFileSync");
      var normalizeOptions = /* @__PURE__ */ __name(({
        ignore = [],
        cwd = slash(process.cwd())
      } = {}) => {
        return { ignore, cwd };
      }, "normalizeOptions");
      module2.exports = async (options2) => {
        options2 = normalizeOptions(options2);
        const paths = await fastGlob("**/.gitignore", {
          ignore: DEFAULT_IGNORE.concat(options2.ignore),
          cwd: options2.cwd
        });
        const files = await Promise.all(paths.map((file2) => getFile(file2, options2.cwd)));
        const ignores = reduceIgnore(files);
        return getIsIgnoredPredecate(ignores, options2.cwd);
      };
      module2.exports.sync = (options2) => {
        options2 = normalizeOptions(options2);
        const paths = fastGlob.sync("**/.gitignore", {
          ignore: DEFAULT_IGNORE.concat(options2.ignore),
          cwd: options2.cwd
        });
        const files = paths.map((file2) => getFileSync(file2, options2.cwd));
        const ignores = reduceIgnore(files);
        return getIsIgnoredPredecate(ignores, options2.cwd);
      };
    });
    var require_stream_utils = __commonJS((exports2, module2) => {
      "use strict";
      var { Transform } = __require("stream");
      var ObjectTransform = /* @__PURE__ */ __name(class extends Transform {
        constructor() {
          super({
            objectMode: true
          });
        }
      }, "ObjectTransform");
      var FilterStream = /* @__PURE__ */ __name(class extends ObjectTransform {
        constructor(filter) {
          super();
          this._filter = filter;
        }
        _transform(data, encoding, callback) {
          if (this._filter(data)) {
            this.push(data);
          }
          callback();
        }
      }, "FilterStream");
      var UniqueStream = /* @__PURE__ */ __name(class extends ObjectTransform {
        constructor() {
          super();
          this._pushed = new Set();
        }
        _transform(data, encoding, callback) {
          if (!this._pushed.has(data)) {
            this.push(data);
            this._pushed.add(data);
          }
          callback();
        }
      }, "UniqueStream");
      module2.exports = {
        FilterStream,
        UniqueStream
      };
    });
    var require_globby = __commonJS((exports2, module2) => {
      "use strict";
      var fs7 = __require("fs");
      var arrayUnion = require_array_union();
      var merge2 = require_merge2();
      var fastGlob = require_out4();
      var dirGlob = require_dir_glob();
      var gitignore = require_gitignore();
      var { FilterStream, UniqueStream } = require_stream_utils();
      var DEFAULT_FILTER = /* @__PURE__ */ __name(() => false, "DEFAULT_FILTER");
      var isNegative = /* @__PURE__ */ __name((pattern) => pattern[0] === "!", "isNegative");
      var assertPatternsInput = /* @__PURE__ */ __name((patterns) => {
        if (!patterns.every((pattern) => typeof pattern === "string")) {
          throw new TypeError("Patterns must be a string or an array of strings");
        }
      }, "assertPatternsInput");
      var checkCwdOption = /* @__PURE__ */ __name((options2 = {}) => {
        if (!options2.cwd) {
          return;
        }
        let stat;
        try {
          stat = fs7.statSync(options2.cwd);
        } catch {
          return;
        }
        if (!stat.isDirectory()) {
          throw new Error("The `cwd` option must be a path to a directory");
        }
      }, "checkCwdOption");
      var getPathString = /* @__PURE__ */ __name((p) => p.stats instanceof fs7.Stats ? p.path : p, "getPathString");
      var generateGlobTasks = /* @__PURE__ */ __name((patterns, taskOptions) => {
        patterns = arrayUnion([].concat(patterns));
        assertPatternsInput(patterns);
        checkCwdOption(taskOptions);
        const globTasks = [];
        taskOptions = {
          ignore: [],
          expandDirectories: true,
          ...taskOptions
        };
        for (const [index, pattern] of patterns.entries()) {
          if (isNegative(pattern)) {
            continue;
          }
          const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));
          const options2 = {
            ...taskOptions,
            ignore: taskOptions.ignore.concat(ignore)
          };
          globTasks.push({ pattern, options: options2 });
        }
        return globTasks;
      }, "generateGlobTasks");
      var globDirs = /* @__PURE__ */ __name((task, fn) => {
        let options2 = {};
        if (task.options.cwd) {
          options2.cwd = task.options.cwd;
        }
        if (Array.isArray(task.options.expandDirectories)) {
          options2 = {
            ...options2,
            files: task.options.expandDirectories
          };
        } else if (typeof task.options.expandDirectories === "object") {
          options2 = {
            ...options2,
            ...task.options.expandDirectories
          };
        }
        return fn(task.pattern, options2);
      }, "globDirs");
      var getPattern = /* @__PURE__ */ __name((task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern], "getPattern");
      var getFilterSync = /* @__PURE__ */ __name((options2) => {
        return options2 && options2.gitignore ? gitignore.sync({ cwd: options2.cwd, ignore: options2.ignore }) : DEFAULT_FILTER;
      }, "getFilterSync");
      var globToTask = /* @__PURE__ */ __name((task) => (glob) => {
        const { options: options2 } = task;
        if (options2.ignore && Array.isArray(options2.ignore) && options2.expandDirectories) {
          options2.ignore = dirGlob.sync(options2.ignore);
        }
        return {
          pattern: glob,
          options: options2
        };
      }, "globToTask");
      module2.exports = async (patterns, options2) => {
        const globTasks = generateGlobTasks(patterns, options2);
        const getFilter = /* @__PURE__ */ __name(async () => {
          return options2 && options2.gitignore ? gitignore({ cwd: options2.cwd, ignore: options2.ignore }) : DEFAULT_FILTER;
        }, "getFilter");
        const getTasks = /* @__PURE__ */ __name(async () => {
          const tasks2 = await Promise.all(globTasks.map(async (task) => {
            const globs = await getPattern(task, dirGlob);
            return Promise.all(globs.map(globToTask(task)));
          }));
          return arrayUnion(...tasks2);
        }, "getTasks");
        const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
        const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
        return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
      };
      module2.exports.sync = (patterns, options2) => {
        const globTasks = generateGlobTasks(patterns, options2);
        const tasks = [];
        for (const task of globTasks) {
          const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
          tasks.push(...newTask);
        }
        const filter = getFilterSync(options2);
        let matches = [];
        for (const task of tasks) {
          matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
        }
        return matches.filter((path_) => !filter(path_));
      };
      module2.exports.stream = (patterns, options2) => {
        const globTasks = generateGlobTasks(patterns, options2);
        const tasks = [];
        for (const task of globTasks) {
          const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
          tasks.push(...newTask);
        }
        const filter = getFilterSync(options2);
        const filterStream = new FilterStream((p) => !filter(p));
        const uniqueStream = new UniqueStream();
        return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
      };
      module2.exports.generateGlobTasks = generateGlobTasks;
      module2.exports.hasMagic = (patterns, options2) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options2));
      module2.exports.gitignore = gitignore;
    });
    var require_polyfills = __commonJS((exports2, module2) => {
      var constants = __require("constants");
      var origCwd = process.cwd;
      var cwd = null;
      var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
      process.cwd = function() {
        if (!cwd)
          cwd = origCwd.call(process);
        return cwd;
      };
      try {
        process.cwd();
      } catch (er) {
      }
      if (typeof process.chdir === "function") {
        chdir = process.chdir;
        process.chdir = function(d) {
          cwd = null;
          chdir.call(process, d);
        };
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(process.chdir, chdir);
      }
      var chdir;
      module2.exports = patch;
      function patch(fs7) {
        if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
          patchLchmod(fs7);
        }
        if (!fs7.lutimes) {
          patchLutimes(fs7);
        }
        fs7.chown = chownFix(fs7.chown);
        fs7.fchown = chownFix(fs7.fchown);
        fs7.lchown = chownFix(fs7.lchown);
        fs7.chmod = chmodFix(fs7.chmod);
        fs7.fchmod = chmodFix(fs7.fchmod);
        fs7.lchmod = chmodFix(fs7.lchmod);
        fs7.chownSync = chownFixSync(fs7.chownSync);
        fs7.fchownSync = chownFixSync(fs7.fchownSync);
        fs7.lchownSync = chownFixSync(fs7.lchownSync);
        fs7.chmodSync = chmodFixSync(fs7.chmodSync);
        fs7.fchmodSync = chmodFixSync(fs7.fchmodSync);
        fs7.lchmodSync = chmodFixSync(fs7.lchmodSync);
        fs7.stat = statFix(fs7.stat);
        fs7.fstat = statFix(fs7.fstat);
        fs7.lstat = statFix(fs7.lstat);
        fs7.statSync = statFixSync(fs7.statSync);
        fs7.fstatSync = statFixSync(fs7.fstatSync);
        fs7.lstatSync = statFixSync(fs7.lstatSync);
        if (!fs7.lchmod) {
          fs7.lchmod = function(path22, mode, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs7.lchmodSync = function() {
          };
        }
        if (!fs7.lchown) {
          fs7.lchown = function(path22, uid, gid, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs7.lchownSync = function() {
          };
        }
        if (platform2 === "win32") {
          fs7.rename = function(fs$rename) {
            return function(from, to, cb) {
              var start = Date.now();
              var backoff = 0;
              fs$rename(from, to, /* @__PURE__ */ __name(function CB(er) {
                if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                  setTimeout(function() {
                    fs7.stat(to, function(stater, st) {
                      if (stater && stater.code === "ENOENT")
                        fs$rename(from, to, CB);
                      else
                        cb(er);
                    });
                  }, backoff);
                  if (backoff < 100)
                    backoff += 10;
                  return;
                }
                if (cb)
                  cb(er);
              }, "CB"));
            };
          }(fs7.rename);
        }
        fs7.read = function(fs$read) {
          function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === "function") {
              var eagCounter = 0;
              callback = /* @__PURE__ */ __name(function(er, _, __) {
                if (er && er.code === "EAGAIN" && eagCounter < 10) {
                  eagCounter++;
                  return fs$read.call(fs7, fd, buffer, offset, length, position, callback);
                }
                callback_.apply(this, arguments);
              }, "callback");
            }
            return fs$read.call(fs7, fd, buffer, offset, length, position, callback);
          }
          __name(read, "read");
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(read, fs$read);
          return read;
        }(fs7.read);
        fs7.readSync = function(fs$readSync) {
          return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while (true) {
              try {
                return fs$readSync.call(fs7, fd, buffer, offset, length, position);
              } catch (er) {
                if (er.code === "EAGAIN" && eagCounter < 10) {
                  eagCounter++;
                  continue;
                }
                throw er;
              }
            }
          };
        }(fs7.readSync);
        function patchLchmod(fs22) {
          fs22.lchmod = function(path22, mode, callback) {
            fs22.open(path22, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs22.fchmod(fd, mode, function(err2) {
                fs22.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            });
          };
          fs22.lchmodSync = function(path22, mode) {
            var fd = fs22.openSync(path22, constants.O_WRONLY | constants.O_SYMLINK, mode);
            var threw = true;
            var ret;
            try {
              ret = fs22.fchmodSync(fd, mode);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs22.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs22.closeSync(fd);
              }
            }
            return ret;
          };
        }
        __name(patchLchmod, "patchLchmod");
        function patchLutimes(fs22) {
          if (constants.hasOwnProperty("O_SYMLINK")) {
            fs22.lutimes = function(path22, at, mt, cb) {
              fs22.open(path22, constants.O_SYMLINK, function(er, fd) {
                if (er) {
                  if (cb)
                    cb(er);
                  return;
                }
                fs22.futimes(fd, at, mt, function(er2) {
                  fs22.close(fd, function(er22) {
                    if (cb)
                      cb(er2 || er22);
                  });
                });
              });
            };
            fs22.lutimesSync = function(path22, at, mt) {
              var fd = fs22.openSync(path22, constants.O_SYMLINK);
              var ret;
              var threw = true;
              try {
                ret = fs22.futimesSync(fd, at, mt);
                threw = false;
              } finally {
                if (threw) {
                  try {
                    fs22.closeSync(fd);
                  } catch (er) {
                  }
                } else {
                  fs22.closeSync(fd);
                }
              }
              return ret;
            };
          } else {
            fs22.lutimes = function(_a2, _b2, _c, cb) {
              if (cb)
                process.nextTick(cb);
            };
            fs22.lutimesSync = function() {
            };
          }
        }
        __name(patchLutimes, "patchLutimes");
        function chmodFix(orig) {
          if (!orig)
            return orig;
          return function(target, mode, cb) {
            return orig.call(fs7, target, mode, function(er) {
              if (chownErOk(er))
                er = null;
              if (cb)
                cb.apply(this, arguments);
            });
          };
        }
        __name(chmodFix, "chmodFix");
        function chmodFixSync(orig) {
          if (!orig)
            return orig;
          return function(target, mode) {
            try {
              return orig.call(fs7, target, mode);
            } catch (er) {
              if (!chownErOk(er))
                throw er;
            }
          };
        }
        __name(chmodFixSync, "chmodFixSync");
        function chownFix(orig) {
          if (!orig)
            return orig;
          return function(target, uid, gid, cb) {
            return orig.call(fs7, target, uid, gid, function(er) {
              if (chownErOk(er))
                er = null;
              if (cb)
                cb.apply(this, arguments);
            });
          };
        }
        __name(chownFix, "chownFix");
        function chownFixSync(orig) {
          if (!orig)
            return orig;
          return function(target, uid, gid) {
            try {
              return orig.call(fs7, target, uid, gid);
            } catch (er) {
              if (!chownErOk(er))
                throw er;
            }
          };
        }
        __name(chownFixSync, "chownFixSync");
        function statFix(orig) {
          if (!orig)
            return orig;
          return function(target, options2, cb) {
            if (typeof options2 === "function") {
              cb = options2;
              options2 = null;
            }
            function callback(er, stats) {
              if (stats) {
                if (stats.uid < 0)
                  stats.uid += 4294967296;
                if (stats.gid < 0)
                  stats.gid += 4294967296;
              }
              if (cb)
                cb.apply(this, arguments);
            }
            __name(callback, "callback");
            return options2 ? orig.call(fs7, target, options2, callback) : orig.call(fs7, target, callback);
          };
        }
        __name(statFix, "statFix");
        function statFixSync(orig) {
          if (!orig)
            return orig;
          return function(target, options2) {
            var stats = options2 ? orig.call(fs7, target, options2) : orig.call(fs7, target);
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
            return stats;
          };
        }
        __name(statFixSync, "statFixSync");
        function chownErOk(er) {
          if (!er)
            return true;
          if (er.code === "ENOSYS")
            return true;
          var nonroot = !process.getuid || process.getuid() !== 0;
          if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM")
              return true;
          }
          return false;
        }
        __name(chownErOk, "chownErOk");
      }
      __name(patch, "patch");
    });
    var require_legacy_streams = __commonJS((exports2, module2) => {
      var Stream = __require("stream").Stream;
      module2.exports = legacy;
      function legacy(fs7) {
        return {
          ReadStream,
          WriteStream
        };
        function ReadStream(path22, options2) {
          if (!(this instanceof ReadStream))
            return new ReadStream(path22, options2);
          Stream.call(this);
          var self2 = this;
          this.path = path22;
          this.fd = null;
          this.readable = true;
          this.paused = false;
          this.flags = "r";
          this.mode = 438;
          this.bufferSize = 64 * 1024;
          options2 = options2 || {};
          var keys2 = Object.keys(options2);
          for (var index = 0, length = keys2.length; index < length; index++) {
            var key = keys2[index];
            this[key] = options2[key];
          }
          if (this.encoding)
            this.setEncoding(this.encoding);
          if (this.start !== void 0) {
            if (typeof this.start !== "number") {
              throw TypeError("start must be a Number");
            }
            if (this.end === void 0) {
              this.end = Infinity;
            } else if (typeof this.end !== "number") {
              throw TypeError("end must be a Number");
            }
            if (this.start > this.end) {
              throw new Error("start must be <= end");
            }
            this.pos = this.start;
          }
          if (this.fd !== null) {
            process.nextTick(function() {
              self2._read();
            });
            return;
          }
          fs7.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
              self2.emit("error", err);
              self2.readable = false;
              return;
            }
            self2.fd = fd;
            self2.emit("open", fd);
            self2._read();
          });
        }
        __name(ReadStream, "ReadStream");
        function WriteStream(path22, options2) {
          if (!(this instanceof WriteStream))
            return new WriteStream(path22, options2);
          Stream.call(this);
          this.path = path22;
          this.fd = null;
          this.writable = true;
          this.flags = "w";
          this.encoding = "binary";
          this.mode = 438;
          this.bytesWritten = 0;
          options2 = options2 || {};
          var keys2 = Object.keys(options2);
          for (var index = 0, length = keys2.length; index < length; index++) {
            var key = keys2[index];
            this[key] = options2[key];
          }
          if (this.start !== void 0) {
            if (typeof this.start !== "number") {
              throw TypeError("start must be a Number");
            }
            if (this.start < 0) {
              throw new Error("start must be >= zero");
            }
            this.pos = this.start;
          }
          this.busy = false;
          this._queue = [];
          if (this.fd === null) {
            this._open = fs7.open;
            this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
            this.flush();
          }
        }
        __name(WriteStream, "WriteStream");
      }
      __name(legacy, "legacy");
    });
    var require_clone = __commonJS((exports2, module2) => {
      "use strict";
      module2.exports = clone2;
      var getPrototypeOf = Object.getPrototypeOf || function(obj) {
        return obj.__proto__;
      };
      function clone2(obj) {
        if (obj === null || typeof obj !== "object")
          return obj;
        if (obj instanceof Object)
          var copy = { __proto__: getPrototypeOf(obj) };
        else
          var copy = Object.create(null);
        Object.getOwnPropertyNames(obj).forEach(function(key) {
          Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
        });
        return copy;
      }
      __name(clone2, "clone");
    });
    var require_graceful_fs = __commonJS((exports2, module2) => {
      var fs7 = __require("fs");
      var polyfills = require_polyfills();
      var legacy = require_legacy_streams();
      var clone2 = require_clone();
      var util2 = __require("util");
      var gracefulQueue;
      var previousSymbol;
      if (typeof Symbol === "function" && typeof Symbol.for === "function") {
        gracefulQueue = Symbol.for("graceful-fs.queue");
        previousSymbol = Symbol.for("graceful-fs.previous");
      } else {
        gracefulQueue = "___graceful-fs.queue";
        previousSymbol = "___graceful-fs.previous";
      }
      function noop() {
      }
      __name(noop, "noop");
      function publishQueue(context, queue2) {
        Object.defineProperty(context, gracefulQueue, {
          get: function() {
            return queue2;
          }
        });
      }
      __name(publishQueue, "publishQueue");
      var debug32 = noop;
      if (util2.debuglog)
        debug32 = util2.debuglog("gfs4");
      else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
        debug32 = /* @__PURE__ */ __name(function() {
          var m = util2.format.apply(util2, arguments);
          m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
          console.error(m);
        }, "debug3");
      if (!fs7[gracefulQueue]) {
        queue = global[gracefulQueue] || [];
        publishQueue(fs7, queue);
        fs7.close = function(fs$close) {
          function close(fd, cb) {
            return fs$close.call(fs7, fd, function(err) {
              if (!err) {
                retry();
              }
              if (typeof cb === "function")
                cb.apply(this, arguments);
            });
          }
          __name(close, "close");
          Object.defineProperty(close, previousSymbol, {
            value: fs$close
          });
          return close;
        }(fs7.close);
        fs7.closeSync = function(fs$closeSync) {
          function closeSync(fd) {
            fs$closeSync.apply(fs7, arguments);
            retry();
          }
          __name(closeSync, "closeSync");
          Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
          });
          return closeSync;
        }(fs7.closeSync);
        if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
          process.on("exit", function() {
            debug32(fs7[gracefulQueue]);
            __require("assert").equal(fs7[gracefulQueue].length, 0);
          });
        }
      }
      var queue;
      if (!global[gracefulQueue]) {
        publishQueue(global, fs7[gracefulQueue]);
      }
      module2.exports = patch(clone2(fs7));
      if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs7.__patched) {
        module2.exports = patch(fs7);
        fs7.__patched = true;
      }
      function patch(fs22) {
        polyfills(fs22);
        fs22.gracefulify = patch;
        fs22.createReadStream = createReadStream;
        fs22.createWriteStream = createWriteStream;
        var fs$readFile = fs22.readFile;
        fs22.readFile = readFile2;
        function readFile2(path22, options2, cb) {
          if (typeof options2 === "function")
            cb = options2, options2 = null;
          return go$readFile(path22, options2, cb);
          function go$readFile(path32, options22, cb2) {
            return fs$readFile(path32, options22, function(err) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$readFile, [path32, options22, cb2]]);
              else {
                if (typeof cb2 === "function")
                  cb2.apply(this, arguments);
                retry();
              }
            });
          }
          __name(go$readFile, "go$readFile");
        }
        __name(readFile2, "readFile2");
        var fs$writeFile = fs22.writeFile;
        fs22.writeFile = writeFile2;
        function writeFile2(path22, data, options2, cb) {
          if (typeof options2 === "function")
            cb = options2, options2 = null;
          return go$writeFile(path22, data, options2, cb);
          function go$writeFile(path32, data2, options22, cb2) {
            return fs$writeFile(path32, data2, options22, function(err) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$writeFile, [path32, data2, options22, cb2]]);
              else {
                if (typeof cb2 === "function")
                  cb2.apply(this, arguments);
                retry();
              }
            });
          }
          __name(go$writeFile, "go$writeFile");
        }
        __name(writeFile2, "writeFile2");
        var fs$appendFile = fs22.appendFile;
        if (fs$appendFile)
          fs22.appendFile = appendFile;
        function appendFile(path22, data, options2, cb) {
          if (typeof options2 === "function")
            cb = options2, options2 = null;
          return go$appendFile(path22, data, options2, cb);
          function go$appendFile(path32, data2, options22, cb2) {
            return fs$appendFile(path32, data2, options22, function(err) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$appendFile, [path32, data2, options22, cb2]]);
              else {
                if (typeof cb2 === "function")
                  cb2.apply(this, arguments);
                retry();
              }
            });
          }
          __name(go$appendFile, "go$appendFile");
        }
        __name(appendFile, "appendFile");
        var fs$copyFile = fs22.copyFile;
        if (fs$copyFile)
          fs22.copyFile = copyFile2;
        function copyFile2(src, dest, flags, cb) {
          if (typeof flags === "function") {
            cb = flags;
            flags = 0;
          }
          return fs$copyFile(src, dest, flags, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([fs$copyFile, [src, dest, flags, cb]]);
            else {
              if (typeof cb === "function")
                cb.apply(this, arguments);
              retry();
            }
          });
        }
        __name(copyFile2, "copyFile2");
        var fs$readdir = fs22.readdir;
        fs22.readdir = readdir;
        function readdir(path22, options2, cb) {
          var args = [path22];
          if (typeof options2 !== "function") {
            args.push(options2);
          } else {
            cb = options2;
          }
          args.push(go$readdir$cb);
          return go$readdir(args);
          function go$readdir$cb(err, files) {
            if (files && files.sort)
              files.sort();
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readdir, [args]]);
            else {
              if (typeof cb === "function")
                cb.apply(this, arguments);
              retry();
            }
          }
          __name(go$readdir$cb, "go$readdir$cb");
        }
        __name(readdir, "readdir");
        function go$readdir(args) {
          return fs$readdir.apply(fs22, args);
        }
        __name(go$readdir, "go$readdir");
        if (process.version.substr(0, 4) === "v0.8") {
          var legStreams = legacy(fs22);
          ReadStream = legStreams.ReadStream;
          WriteStream = legStreams.WriteStream;
        }
        var fs$ReadStream = fs22.ReadStream;
        if (fs$ReadStream) {
          ReadStream.prototype = Object.create(fs$ReadStream.prototype);
          ReadStream.prototype.open = ReadStream$open;
        }
        var fs$WriteStream = fs22.WriteStream;
        if (fs$WriteStream) {
          WriteStream.prototype = Object.create(fs$WriteStream.prototype);
          WriteStream.prototype.open = WriteStream$open;
        }
        Object.defineProperty(fs22, "ReadStream", {
          get: function() {
            return ReadStream;
          },
          set: function(val) {
            ReadStream = val;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(fs22, "WriteStream", {
          get: function() {
            return WriteStream;
          },
          set: function(val) {
            WriteStream = val;
          },
          enumerable: true,
          configurable: true
        });
        var FileReadStream = ReadStream;
        Object.defineProperty(fs22, "FileReadStream", {
          get: function() {
            return FileReadStream;
          },
          set: function(val) {
            FileReadStream = val;
          },
          enumerable: true,
          configurable: true
        });
        var FileWriteStream = WriteStream;
        Object.defineProperty(fs22, "FileWriteStream", {
          get: function() {
            return FileWriteStream;
          },
          set: function(val) {
            FileWriteStream = val;
          },
          enumerable: true,
          configurable: true
        });
        function ReadStream(path22, options2) {
          if (this instanceof ReadStream)
            return fs$ReadStream.apply(this, arguments), this;
          else
            return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
        }
        __name(ReadStream, "ReadStream");
        function ReadStream$open() {
          var that = this;
          open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
              if (that.autoClose)
                that.destroy();
              that.emit("error", err);
            } else {
              that.fd = fd;
              that.emit("open", fd);
              that.read();
            }
          });
        }
        __name(ReadStream$open, "ReadStream$open");
        function WriteStream(path22, options2) {
          if (this instanceof WriteStream)
            return fs$WriteStream.apply(this, arguments), this;
          else
            return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
        }
        __name(WriteStream, "WriteStream");
        function WriteStream$open() {
          var that = this;
          open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
              that.destroy();
              that.emit("error", err);
            } else {
              that.fd = fd;
              that.emit("open", fd);
            }
          });
        }
        __name(WriteStream$open, "WriteStream$open");
        function createReadStream(path22, options2) {
          return new fs22.ReadStream(path22, options2);
        }
        __name(createReadStream, "createReadStream");
        function createWriteStream(path22, options2) {
          return new fs22.WriteStream(path22, options2);
        }
        __name(createWriteStream, "createWriteStream");
        var fs$open = fs22.open;
        fs22.open = open;
        function open(path22, flags, mode, cb) {
          if (typeof mode === "function")
            cb = mode, mode = null;
          return go$open(path22, flags, mode, cb);
          function go$open(path32, flags2, mode2, cb2) {
            return fs$open(path32, flags2, mode2, function(err, fd) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$open, [path32, flags2, mode2, cb2]]);
              else {
                if (typeof cb2 === "function")
                  cb2.apply(this, arguments);
                retry();
              }
            });
          }
          __name(go$open, "go$open");
        }
        __name(open, "open");
        return fs22;
      }
      __name(patch, "patch");
      function enqueue(elem) {
        debug32("ENQUEUE", elem[0].name, elem[1]);
        fs7[gracefulQueue].push(elem);
      }
      __name(enqueue, "enqueue");
      function retry() {
        var elem = fs7[gracefulQueue].shift();
        if (elem) {
          debug32("RETRY", elem[0].name, elem[1]);
          elem[0].apply(null, elem[1]);
        }
      }
      __name(retry, "retry");
    });
    var require_is_path_cwd = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      module2.exports = (path_) => {
        let cwd = process.cwd();
        path_ = path22.resolve(path_);
        if (process.platform === "win32") {
          cwd = cwd.toLowerCase();
          path_ = path_.toLowerCase();
        }
        return path_ === cwd;
      };
    });
    var require_is_path_inside = __commonJS((exports2, module2) => {
      "use strict";
      var path22 = __require("path");
      module2.exports = (childPath, parentPath) => {
        const relation = path22.relative(parentPath, childPath);
        return Boolean(relation && relation !== ".." && !relation.startsWith(`..${path22.sep}`) && relation !== path22.resolve(childPath));
      };
    });
    var require_del = __commonJS((exports2, module2) => {
      "use strict";
      var { promisify: promisify3 } = __require("util");
      var path22 = __require("path");
      var globby = require_globby();
      var isGlob = require_is_glob();
      var slash = require_slash();
      var gracefulFs = require_graceful_fs();
      var isPathCwd = require_is_path_cwd();
      var isPathInside = require_is_path_inside();
      var rimraf = require_rimraf();
      var pMap = require_p_map();
      var rimrafP = promisify3(rimraf);
      var rimrafOptions = {
        glob: false,
        unlink: gracefulFs.unlink,
        unlinkSync: gracefulFs.unlinkSync,
        chmod: gracefulFs.chmod,
        chmodSync: gracefulFs.chmodSync,
        stat: gracefulFs.stat,
        statSync: gracefulFs.statSync,
        lstat: gracefulFs.lstat,
        lstatSync: gracefulFs.lstatSync,
        rmdir: gracefulFs.rmdir,
        rmdirSync: gracefulFs.rmdirSync,
        readdir: gracefulFs.readdir,
        readdirSync: gracefulFs.readdirSync
      };
      function safeCheck(file2, cwd) {
        if (isPathCwd(file2)) {
          throw new Error("Cannot delete the current working directory. Can be overridden with the `force` option.");
        }
        if (!isPathInside(file2, cwd)) {
          throw new Error("Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.");
        }
      }
      __name(safeCheck, "safeCheck");
      function normalizePatterns(patterns) {
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        patterns = patterns.map((pattern) => {
          if (process.platform === "win32" && isGlob(pattern) === false) {
            return slash(pattern);
          }
          return pattern;
        });
        return patterns;
      }
      __name(normalizePatterns, "normalizePatterns");
      module2.exports = async (patterns, { force, dryRun, cwd = process.cwd(), ...options2 } = {}) => {
        options2 = {
          expandDirectories: false,
          onlyFiles: false,
          followSymbolicLinks: false,
          cwd,
          ...options2
        };
        patterns = normalizePatterns(patterns);
        const files = (await globby(patterns, options2)).sort((a, b) => b.localeCompare(a));
        const mapper = /* @__PURE__ */ __name(async (file2) => {
          file2 = path22.resolve(cwd, file2);
          if (!force) {
            safeCheck(file2, cwd);
          }
          if (!dryRun) {
            await rimrafP(file2, rimrafOptions);
          }
          return file2;
        }, "mapper");
        const removedFiles = await pMap(files, mapper, options2);
        removedFiles.sort((a, b) => a.localeCompare(b));
        return removedFiles;
      };
      module2.exports.sync = (patterns, { force, dryRun, cwd = process.cwd(), ...options2 } = {}) => {
        options2 = {
          expandDirectories: false,
          onlyFiles: false,
          followSymbolicLinks: false,
          cwd,
          ...options2
        };
        patterns = normalizePatterns(patterns);
        const files = globby.sync(patterns, options2).sort((a, b) => b.localeCompare(a));
        const removedFiles = files.map((file2) => {
          file2 = path22.resolve(cwd, file2);
          if (!force) {
            safeCheck(file2, cwd);
          }
          if (!dryRun) {
            rimraf.sync(file2, rimrafOptions);
          }
          return file2;
        });
        removedFiles.sort((a, b) => a.localeCompare(b));
        return removedFiles;
      };
    });
    var require_tempy = __commonJS((exports2, module2) => {
      "use strict";
      var fs7 = __require("fs");
      var path22 = __require("path");
      var uniqueString = require_unique_string();
      var tempDir = require_temp_dir();
      var isStream = require_is_stream();
      var del = require_del();
      var stream3 = __require("stream");
      var { promisify: promisify3 } = __require("util");
      var pipeline2 = promisify3(stream3.pipeline);
      var { writeFile: writeFile2 } = fs7.promises;
      var getPath = /* @__PURE__ */ __name((prefix = "") => path22.join(tempDir, prefix + uniqueString()), "getPath");
      var writeStream = /* @__PURE__ */ __name(async (filePath, data) => pipeline2(data, fs7.createWriteStream(filePath)), "writeStream");
      var createTask = /* @__PURE__ */ __name((tempyFunction, { extraArguments = 0 } = {}) => async (...arguments_) => {
        const [callback, options2] = arguments_.slice(extraArguments);
        const result = await tempyFunction(...arguments_.slice(0, extraArguments), options2);
        const returnValue = await callback(result);
        await del(result, { force: true });
        return returnValue;
      }, "createTask");
      module2.exports.file = (options2) => {
        options2 = {
          ...options2
        };
        if (options2.name) {
          if (options2.extension !== void 0 && options2.extension !== null) {
            throw new Error("The `name` and `extension` options are mutually exclusive");
          }
          return path22.join(module2.exports.directory(), options2.name);
        }
        return getPath() + (options2.extension === void 0 || options2.extension === null ? "" : "." + options2.extension.replace(/^\./, ""));
      };
      module2.exports.file.task = createTask(module2.exports.file);
      module2.exports.directory = ({ prefix = "" } = {}) => {
        const directory = getPath(prefix);
        fs7.mkdirSync(directory);
        return directory;
      };
      module2.exports.directory.task = createTask(module2.exports.directory);
      module2.exports.write = async (data, options2) => {
        const filename = module2.exports.file(options2);
        const write = isStream(data) ? writeStream : writeFile2;
        await write(filename, data);
        return filename;
      };
      module2.exports.write.task = createTask(module2.exports.write, { extraArguments: 1 });
      module2.exports.writeSync = (data, options2) => {
        const filename = module2.exports.file(options2);
        fs7.writeFileSync(filename, data);
        return filename;
      };
      Object.defineProperty(module2.exports, "root", {
        get() {
          return tempDir;
        }
      });
    });
    var require_hasha = __commonJS((exports2, module2) => {
      "use strict";
      var fs7 = __require("fs");
      var path22 = __require("path");
      var crypto3 = __require("crypto");
      var isStream = require_is_stream();
      var { Worker } = (() => {
        try {
          return __require("worker_threads");
        } catch (_) {
          return {};
        }
      })();
      var worker;
      var taskIdCounter = 0;
      var tasks = new Map();
      var recreateWorkerError = /* @__PURE__ */ __name((sourceError) => {
        const error2 = new Error(sourceError.message);
        for (const [key, value] of Object.entries(sourceError)) {
          if (key !== "message") {
            error2[key] = value;
          }
        }
        return error2;
      }, "recreateWorkerError");
      var createWorker = /* @__PURE__ */ __name(() => {
        worker = new Worker(path22.join(__dirname, "thread.js"));
        worker.on("message", (message) => {
          const task = tasks.get(message.id);
          tasks.delete(message.id);
          if (tasks.size === 0) {
            worker.unref();
          }
          if (message.error === void 0) {
            task.resolve(message.value);
          } else {
            task.reject(recreateWorkerError(message.error));
          }
        });
        worker.on("error", (error2) => {
          throw error2;
        });
      }, "createWorker");
      var taskWorker = /* @__PURE__ */ __name((method, args, transferList) => new Promise((resolve2, reject2) => {
        const id = taskIdCounter++;
        tasks.set(id, { resolve: resolve2, reject: reject2 });
        if (worker === void 0) {
          createWorker();
        }
        worker.ref();
        worker.postMessage({ id, method, args }, transferList);
      }), "taskWorker");
      var hasha = /* @__PURE__ */ __name((input, options2 = {}) => {
        let outputEncoding = options2.encoding || "hex";
        if (outputEncoding === "buffer") {
          outputEncoding = void 0;
        }
        const hash = crypto3.createHash(options2.algorithm || "sha512");
        const update = /* @__PURE__ */ __name((buffer) => {
          const inputEncoding = typeof buffer === "string" ? "utf8" : void 0;
          hash.update(buffer, inputEncoding);
        }, "update");
        if (Array.isArray(input)) {
          input.forEach(update);
        } else {
          update(input);
        }
        return hash.digest(outputEncoding);
      }, "hasha");
      hasha.stream = (options2 = {}) => {
        let outputEncoding = options2.encoding || "hex";
        if (outputEncoding === "buffer") {
          outputEncoding = void 0;
        }
        const stream3 = crypto3.createHash(options2.algorithm || "sha512");
        stream3.setEncoding(outputEncoding);
        return stream3;
      };
      hasha.fromStream = async (stream3, options2 = {}) => {
        if (!isStream(stream3)) {
          throw new TypeError("Expected a stream");
        }
        return new Promise((resolve2, reject2) => {
          stream3.on("error", reject2).pipe(hasha.stream(options2)).on("error", reject2).on("finish", function() {
            resolve2(this.read());
          });
        });
      };
      if (Worker === void 0) {
        hasha.fromFile = async (filePath, options2) => hasha.fromStream(fs7.createReadStream(filePath), options2);
        hasha.async = async (input, options2) => hasha(input, options2);
      } else {
        hasha.fromFile = async (filePath, { algorithm = "sha512", encoding = "hex" } = {}) => {
          const hash = await taskWorker("hashFile", [algorithm, filePath]);
          if (encoding === "buffer") {
            return Buffer.from(hash);
          }
          return Buffer.from(hash).toString(encoding);
        };
        hasha.async = async (input, { algorithm = "sha512", encoding = "hex" } = {}) => {
          if (encoding === "buffer") {
            encoding = void 0;
          }
          const hash = await taskWorker("hash", [algorithm, input]);
          if (encoding === void 0) {
            return Buffer.from(hash);
          }
          return Buffer.from(hash).toString(encoding);
        };
      }
      hasha.fromFileSync = (filePath, options2) => hasha(fs7.readFileSync(filePath), options2);
      module2.exports = hasha;
    });
    var require_downloadZip = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.downloadZip = void 0;
      var zlib_1 = __importDefault2(__require("zlib"));
      var p_retry_1 = __importDefault2(require_p_retry());
      var node_fetch_1 = __importDefault2(require_lib2());
      var fs_12 = __importDefault2(__require("fs"));
      var getProxyAgent_1 = require_getProxyAgent();
      var tempy_1 = __importDefault2(require_tempy());
      var path_12 = __importDefault2(__require("path"));
      var debug_12 = __importDefault2(require_dist());
      var hasha_1 = __importDefault2(require_hasha());
      var util_12 = __require("util");
      var rimraf_1 = __importDefault2(require_rimraf());
      var debug32 = (0, debug_12.default)("prisma:downloadZip");
      var del = (0, util_12.promisify)(rimraf_1.default);
      async function fetchSha256(url2) {
        const [zippedSha256, sha256] = [
          (await (0, node_fetch_1.default)(`${url2}.sha256`, {
            agent: (0, getProxyAgent_1.getProxyAgent)(url2)
          }).then((res) => res.text())).split(/\s+/)[0],
          (await (0, node_fetch_1.default)(`${url2.slice(0, url2.length - 3)}.sha256`, {
            agent: (0, getProxyAgent_1.getProxyAgent)(url2.slice(0, url2.length - 3))
          }).then((res) => res.text())).split(/\s+/)[0]
        ];
        return { sha256, zippedSha256 };
      }
      __name(fetchSha256, "fetchSha256");
      async function downloadZip(url2, target, progressCb) {
        const tmpDir = tempy_1.default.directory();
        const partial = path_12.default.join(tmpDir, "partial");
        const { sha256, zippedSha256 } = await fetchSha256(url2);
        const result = await (0, p_retry_1.default)(async () => {
          try {
            const resp = await (0, node_fetch_1.default)(url2, {
              compress: false,
              agent: (0, getProxyAgent_1.getProxyAgent)(url2)
            });
            if (resp.status !== 200) {
              throw new Error(resp.statusText + " " + url2);
            }
            const lastModified = resp.headers.get("last-modified");
            const size = parseFloat(resp.headers.get("content-length"));
            const ws = fs_12.default.createWriteStream(partial);
            return await new Promise(async (resolve2, reject2) => {
              let bytesRead = 0;
              resp.body.on("error", reject2).on("data", (chunk) => {
                bytesRead += chunk.length;
                if (size && progressCb) {
                  progressCb(bytesRead / size);
                }
              });
              const gunzip = zlib_1.default.createGunzip();
              gunzip.on("error", reject2);
              const zipStream = resp.body.pipe(gunzip);
              const zippedHashPromise = hasha_1.default.fromStream(resp.body, {
                algorithm: "sha256"
              });
              const hashPromise = hasha_1.default.fromStream(zipStream, {
                algorithm: "sha256"
              });
              zipStream.pipe(ws);
              ws.on("error", reject2).on("close", () => {
                resolve2({ lastModified, sha256, zippedSha256 });
              });
              const hash = await hashPromise;
              const zippedHash = await zippedHashPromise;
              if (zippedHash !== zippedSha256) {
                throw new Error(`sha256 of ${url2} (zipped) should be ${zippedSha256} but is ${zippedHash}`);
              }
              if (hash !== sha256) {
                throw new Error(`sha256 of ${url2} (uzipped) should be ${sha256} but is ${hash}`);
              }
            });
          } finally {
          }
        }, {
          retries: 2,
          onFailedAttempt: (err) => debug32(err)
        });
        fs_12.default.copyFileSync(partial, target);
        try {
          await del(partial);
          await del(tmpDir);
        } catch (e) {
          debug32(e);
        }
        return result;
      }
      __name(downloadZip, "downloadZip");
      exports2.downloadZip = downloadZip;
    });
    var require_flatMap = __commonJS((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.flatMap = void 0;
      function flatten2(array) {
        return Array.prototype.concat.apply([], array);
      }
      __name(flatten2, "flatten");
      function flatMap2(array, callbackFn, thisArg) {
        return flatten2(array.map(callbackFn, thisArg));
      }
      __name(flatMap2, "flatMap");
      exports2.flatMap = flatMap2;
    });
    var require_getHash = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getHash = void 0;
      var crypto_1 = __importDefault2(__require("crypto"));
      var fs_12 = __importDefault2(__require("fs"));
      function getHash(filePath) {
        const hash = crypto_1.default.createHash("sha256");
        const input = fs_12.default.createReadStream(filePath);
        return new Promise((resolve2) => {
          input.on("readable", () => {
            const data = input.read();
            if (data) {
              hash.update(data);
            } else {
              resolve2(hash.digest("hex"));
            }
          });
        });
      }
      __name(getHash, "getHash");
      exports2.getHash = getHash;
    });
    var require_getLatestTag = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.urlExists = exports2.getAllUrls = exports2.getLatestTag = void 0;
      var get_platform_12 = require_dist2();
      var chalk_12 = __importDefault2(require_source());
      var execa_12 = __importDefault2(require_execa());
      var node_fetch_1 = __importDefault2(require_lib2());
      var p_map_1 = __importDefault2(require_p_map());
      var getProxyAgent_1 = require_getProxyAgent();
      var util_12 = require_util2();
      async function getLatestTag() {
        let branch = await getBranch();
        if (branch !== "master" && !isPatchBranch(branch) && !branch.startsWith("integration/")) {
          branch = "master";
        }
        branch = branch.replace(/^integration\//, "");
        let commits = await getCommits(branch);
        if ((!commits || !Array.isArray(commits)) && branch !== "master" && !isPatchBranch(branch)) {
          console.log(`Overwriting branch "${branch}" with "master" as it's not a branch we have binaries for`);
          branch = "master";
          commits = await getCommits(branch);
        }
        if (!Array.isArray(commits)) {
          console.error(commits);
          throw new Error(`Could not fetch commits from github: ${JSON.stringify(commits, null, 2)}`);
        }
        return getFirstFinishedCommit(branch, commits);
      }
      __name(getLatestTag, "getLatestTag");
      exports2.getLatestTag = getLatestTag;
      function getAllUrls(branch, commit) {
        const urls = [];
        const excludedPlatforms = [
          "freebsd",
          "arm",
          "linux-nixos",
          "linux-arm-openssl-1.1.x",
          "linux-arm-openssl-1.0.x",
          "openbsd",
          "netbsd",
          "freebsd11",
          "freebsd12"
        ];
        const relevantPlatforms = get_platform_12.platforms.filter((p) => !excludedPlatforms.includes(p));
        for (const platform2 of relevantPlatforms) {
          for (const engine of [
            "query-engine",
            "introspection-engine",
            "migration-engine",
            "prisma-fmt"
          ]) {
            for (const extension of [
              ".gz",
              ".gz.sha256",
              ".gz.sig",
              ".sig",
              ".sha256"
            ]) {
              const downloadUrl = (0, util_12.getDownloadUrl)(branch, commit, platform2, engine, extension);
              urls.push(downloadUrl);
            }
          }
        }
        return urls;
      }
      __name(getAllUrls, "getAllUrls");
      exports2.getAllUrls = getAllUrls;
      async function getFirstFinishedCommit(branch, commits) {
        for (const commit of commits) {
          const urls = getAllUrls(branch, commit);
          const exist = await (0, p_map_1.default)(urls, urlExists, { concurrency: 10 });
          const hasMissing = exist.some((e) => !e);
          if (!hasMissing) {
            return commit;
          } else {
            const missing = urls.filter((_, i) => !exist[i]);
            if (missing.length !== urls.length) {
              console.log(`${chalk_12.default.blueBright("info")} The engine commit ${commit} is not yet done. We're skipping it as we're in dev. Missing urls: ${missing.length}`);
            }
          }
        }
      }
      __name(getFirstFinishedCommit, "getFirstFinishedCommit");
      async function urlExists(url2) {
        try {
          const res = await (0, node_fetch_1.default)(url2, {
            method: "HEAD",
            agent: (0, getProxyAgent_1.getProxyAgent)(url2)
          });
          const headers = fromEntries(res.headers.entries());
          if (res.status > 200) {
          }
          if (parseInt(headers["content-length"]) > 0) {
            return res.status < 300;
          }
        } catch (e) {
        }
        return false;
      }
      __name(urlExists, "urlExists");
      exports2.urlExists = urlExists;
      function fromEntries(entries) {
        const result = {};
        for (const [key, value] of entries) {
          result[key] = value;
        }
        return result;
      }
      __name(fromEntries, "fromEntries");
      async function getBranch() {
        if (process.env.NODE_ENV !== "test") {
          if (process.env.PATCH_BRANCH) {
            return process.env.PATCH_BRANCH;
          }
          if (process.env.BUILDKITE_BRANCH) {
            return process.env.BUILDKITE_BRANCH;
          }
          if (process.env.GITHUB_CONTEXT) {
            const context = JSON.parse(process.env.GITHUB_CONTEXT);
            return context.head_ref;
          }
        }
        try {
          const result = await execa_12.default.command("git rev-parse --abbrev-ref HEAD", {
            shell: true,
            stdio: "pipe"
          });
          return result.stdout;
        } catch (e) {
          console.error(e);
        }
        return;
      }
      __name(getBranch, "getBranch");
      function isPatchBranch(version) {
        return /^2\.(\d+)\.x/.test(version);
      }
      __name(isPatchBranch, "isPatchBranch");
      async function getCommits(branch) {
        const url2 = `https://github-cache.prisma.workers.dev/repos/prisma/prisma-engines/commits?sha=${branch}`;
        const result = await (0, node_fetch_1.default)(url2, {
          agent: (0, getProxyAgent_1.getProxyAgent)(url2),
          headers: {
            Authorization: process.env.GITHUB_TOKEN ? `token ${process.env.GITHUB_TOKEN}` : void 0
          }
        }).then((res) => res.json());
        if (!Array.isArray(result)) {
          return result;
        }
        const commits = result.map((r) => r.sha);
        return commits;
      }
      __name(getCommits, "getCommits");
    });
    var require_node_progress = __commonJS((exports2, module2) => {
      exports2 = module2.exports = ProgressBar;
      function ProgressBar(fmt, options2) {
        this.stream = options2.stream || process.stderr;
        if (typeof options2 == "number") {
          var total = options2;
          options2 = {};
          options2.total = total;
        } else {
          options2 = options2 || {};
          if (typeof fmt != "string")
            throw new Error("format required");
          if (typeof options2.total != "number")
            throw new Error("total required");
        }
        this.fmt = fmt;
        this.curr = options2.curr || 0;
        this.total = options2.total;
        this.width = options2.width || this.total;
        this.clear = options2.clear;
        this.chars = {
          complete: options2.complete || "=",
          incomplete: options2.incomplete || "-",
          head: options2.head || (options2.complete || "=")
        };
        this.renderThrottle = options2.renderThrottle !== 0 ? options2.renderThrottle || 16 : 0;
        this.lastRender = -Infinity;
        this.callback = options2.callback || function() {
        };
        this.tokens = {};
        this.lastDraw = "";
      }
      __name(ProgressBar, "ProgressBar");
      ProgressBar.prototype.tick = function(len, tokens) {
        if (len !== 0)
          len = len || 1;
        if (typeof len == "object")
          tokens = len, len = 1;
        if (tokens)
          this.tokens = tokens;
        if (this.curr == 0)
          this.start = new Date();
        this.curr += len;
        this.render();
        if (this.curr >= this.total) {
          this.render(void 0, true);
          this.complete = true;
          this.terminate();
          this.callback(this);
          return;
        }
      };
      ProgressBar.prototype.render = function(tokens, force) {
        force = force !== void 0 ? force : false;
        if (tokens)
          this.tokens = tokens;
        if (!this.stream.isTTY)
          return;
        var now = Date.now();
        var delta = now - this.lastRender;
        if (!force && delta < this.renderThrottle) {
          return;
        } else {
          this.lastRender = now;
        }
        var ratio = this.curr / this.total;
        ratio = Math.min(Math.max(ratio, 0), 1);
        var percent = Math.floor(ratio * 100);
        var incomplete, complete, completeLength;
        var elapsed = new Date() - this.start;
        var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
        var rate = this.curr / (elapsed / 1e3);
        var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
        var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
        if (availableSpace && process.platform === "win32") {
          availableSpace = availableSpace - 1;
        }
        var width = Math.min(this.width, availableSpace);
        completeLength = Math.round(width * ratio);
        complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
        incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
        if (completeLength > 0)
          complete = complete.slice(0, -1) + this.chars.head;
        str = str.replace(":bar", complete + incomplete);
        if (this.tokens)
          for (var key in this.tokens)
            str = str.replace(":" + key, this.tokens[key]);
        if (this.lastDraw !== str) {
          this.stream.cursorTo(0);
          this.stream.write(str);
          this.stream.clearLine(1);
          this.lastDraw = str;
        }
      };
      ProgressBar.prototype.update = function(ratio, tokens) {
        var goal = Math.floor(ratio * this.total);
        var delta = goal - this.curr;
        this.tick(delta, tokens);
      };
      ProgressBar.prototype.interrupt = function(message) {
        this.stream.clearLine();
        this.stream.cursorTo(0);
        this.stream.write(message);
        this.stream.write("\n");
        this.stream.write(this.lastDraw);
      };
      ProgressBar.prototype.terminate = function() {
        if (this.clear) {
          if (this.stream.clearLine) {
            this.stream.clearLine();
            this.stream.cursorTo(0);
          }
        } else {
          this.stream.write("\n");
        }
      };
    });
    var require_progress = __commonJS((exports2, module2) => {
      module2.exports = require_node_progress();
    });
    var require_log = __commonJS((exports2) => {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getBar = void 0;
      var progress_1 = __importDefault2(require_progress());
      function getBar(text) {
        return new progress_1.default(`> ${text} [:bar] :percent`, {
          stream: process.stdout,
          width: 20,
          complete: "=",
          incomplete: " ",
          total: 100,
          head: "",
          clear: true
        });
      }
      __name(getBar, "getBar");
      exports2.getBar = getBar;
    });
    var require_download = __commonJS((exports, module) => {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.plusX = exports.maybeCopyToTmp = exports.getBinaryEnvVarPath = exports.getBinaryName = exports.checkVersionCommand = exports.getVersion = exports.download = exports.BinaryType = void 0;
      var debug_1 = __importDefault(require_dist());
      var get_platform_1 = require_dist2();
      var chalk_1 = __importDefault(require_source());
      var execa_1 = __importDefault(require_execa());
      var fs_1 = __importDefault(__require("fs"));
      var make_dir_1 = __importDefault(require_make_dir());
      var p_filter_1 = __importDefault(require_p_filter());
      var path_1 = __importDefault(__require("path"));
      var temp_dir_1 = __importDefault(require_temp_dir());
      var util_1 = __require("util");
      var chmod_1 = __importDefault(require_chmod());
      var cleanupCache_1 = require_cleanupCache();
      var downloadZip_1 = require_downloadZip();
      var flatMap_1 = require_flatMap();
      var getHash_1 = require_getHash();
      var getLatestTag_1 = require_getLatestTag();
      var log_1 = require_log();
      var util_2 = require_util2();
      var debug = (0, debug_1.default)("prisma:download");
      var writeFile = (0, util_1.promisify)(fs_1.default.writeFile);
      var exists = (0, util_1.promisify)(fs_1.default.exists);
      var readFile = (0, util_1.promisify)(fs_1.default.readFile);
      var copyFile = (0, util_1.promisify)(fs_1.default.copyFile);
      var utimes = (0, util_1.promisify)(fs_1.default.utimes);
      var channel = "master";
      var BinaryType;
      (function(BinaryType3) {
        BinaryType3["queryEngine"] = "query-engine";
        BinaryType3["libqueryEngine"] = "libquery-engine";
        BinaryType3["migrationEngine"] = "migration-engine";
        BinaryType3["introspectionEngine"] = "introspection-engine";
        BinaryType3["prismaFmt"] = "prisma-fmt";
      })(BinaryType = exports.BinaryType || (exports.BinaryType = {}));
      var BINARY_TO_ENV_VAR = {
        [BinaryType.migrationEngine]: "PRISMA_MIGRATION_ENGINE_BINARY",
        [BinaryType.queryEngine]: "PRISMA_QUERY_ENGINE_BINARY",
        [BinaryType.libqueryEngine]: "PRISMA_QUERY_ENGINE_LIBRARY",
        [BinaryType.introspectionEngine]: "PRISMA_INTROSPECTION_ENGINE_BINARY",
        [BinaryType.prismaFmt]: "PRISMA_FMT_BINARY"
      };
      async function download(options) {
        var _a, _b;
        const platform = await (0, get_platform_1.getPlatform)();
        const os = await (0, get_platform_1.getos)();
        if (os.distro && ["nixos"].includes(os.distro)) {
          console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${os.distro}.`);
        } else if (["freebsd11", "freebsd12", "openbsd", "netbsd"].includes(platform)) {
          console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${platform}. Read more about building your own binaries at https://pris.ly/d/build-binaries`);
        } else if (BinaryType.libqueryEngine in options.binaries) {
          await (0, get_platform_1.isNodeAPISupported)();
        }
        if (!options.binaries || Object.values(options.binaries).length === 0) {
          return {};
        }
        const opts = {
          ...options,
          binaryTargets: (_a = options.binaryTargets) !== null && _a !== void 0 ? _a : [platform],
          version: (_b = options.version) !== null && _b !== void 0 ? _b : "latest",
          binaries: mapKeys(options.binaries, (key) => engineTypeToBinaryType(key, platform))
        };
        const binaryJobs = (0, flatMap_1.flatMap)(Object.entries(opts.binaries), ([binaryName, targetFolder]) => opts.binaryTargets.map((binaryTarget) => {
          const fileName = binaryName === BinaryType.libqueryEngine ? (0, get_platform_1.getNodeAPIName)(binaryTarget, "fs") : getBinaryName(binaryName, binaryTarget);
          const targetFilePath = path_1.default.join(targetFolder, fileName);
          return {
            binaryName,
            targetFolder,
            binaryTarget,
            fileName,
            targetFilePath,
            envVarPath: getBinaryEnvVarPath(binaryName)
          };
        }));
        if (process.env.BINARY_DOWNLOAD_VERSION) {
          opts.version = process.env.BINARY_DOWNLOAD_VERSION;
        }
        if (opts.version === "latest") {
          opts.version = await (0, getLatestTag_1.getLatestTag)();
        }
        if (opts.printVersion) {
          console.log(`version: ${opts.version}`);
        }
        const binariesToDownload = await (0, p_filter_1.default)(binaryJobs, async (job) => {
          const needsToBeDownloaded = await binaryNeedsToBeDownloaded(job, platform, opts.version, opts.failSilent);
          const isSupported = get_platform_1.platforms.includes(job.binaryTarget);
          const shouldDownload = isSupported && !job.envVarPath && (opts.ignoreCache || needsToBeDownloaded);
          if (needsToBeDownloaded && !isSupported) {
            throw new Error(`Unknown binaryTarget ${job.binaryTarget} and no custom binaries were provided`);
          }
          return shouldDownload;
        });
        if (binariesToDownload.length > 0) {
          const cleanupPromise = (0, cleanupCache_1.cleanupCache)();
          let finishBar;
          let setProgress;
          if (opts.showProgress) {
            const collectiveBar = getCollectiveBar(opts);
            finishBar = collectiveBar.finishBar;
            setProgress = collectiveBar.setProgress;
          }
          await Promise.all(binariesToDownload.map((job) => downloadBinary({
            ...job,
            version: opts.version,
            failSilent: opts.failSilent,
            progressCb: setProgress ? setProgress(job.targetFilePath) : void 0
          })));
          await cleanupPromise;
          if (finishBar) {
            finishBar();
          }
        }
        const binaryPaths = binaryJobsToBinaryPaths(binaryJobs);
        const dir = eval("__dirname");
        if (dir.startsWith("/snapshot/")) {
          for (const engineType in binaryPaths) {
            const binaryTargets = binaryPaths[engineType];
            for (const binaryTarget in binaryTargets) {
              const binaryPath = binaryTargets[binaryTarget];
              binaryTargets[binaryTarget] = await maybeCopyToTmp(binaryPath);
            }
          }
        }
        return binaryPaths;
      }
      __name(download, "download");
      exports.download = download;
      function getCollectiveBar(options2) {
        var _a2, _b2;
        const hasNodeAPI = "libquery-engine" in options2.binaries;
        const bar = (0, log_1.getBar)(`Downloading Prisma engines${hasNodeAPI ? " for Node-API" : ""} for ${(_a2 = options2.binaryTargets) === null || _a2 === void 0 ? void 0 : _a2.map((p) => chalk_1.default.bold(p)).join(" and ")}`);
        const progressMap = {};
        const numDownloads = Object.values(options2.binaries).length * Object.values((_b2 = options2 === null || options2 === void 0 ? void 0 : options2.binaryTargets) !== null && _b2 !== void 0 ? _b2 : []).length;
        const setProgress = /* @__PURE__ */ __name((sourcePath) => (progress) => {
          progressMap[sourcePath] = progress;
          const progressValues = Object.values(progressMap);
          const totalProgress = progressValues.reduce((acc, curr) => {
            return acc + curr;
          }, 0) / numDownloads;
          if (options2.progressCb) {
            options2.progressCb(totalProgress);
          }
          if (bar) {
            bar.update(totalProgress);
          }
        }, "setProgress");
        return {
          setProgress,
          finishBar: () => {
            bar.update(1);
            bar.terminate();
          }
        };
      }
      __name(getCollectiveBar, "getCollectiveBar");
      function binaryJobsToBinaryPaths(jobs) {
        return jobs.reduce((acc, job) => {
          if (!acc[job.binaryName]) {
            acc[job.binaryName] = {};
          }
          acc[job.binaryName][job.binaryTarget] = job.envVarPath || job.targetFilePath;
          return acc;
        }, {});
      }
      __name(binaryJobsToBinaryPaths, "binaryJobsToBinaryPaths");
      async function binaryNeedsToBeDownloaded(job, nativePlatform, version, failSilent) {
        if (job.envVarPath && fs_1.default.existsSync(job.envVarPath)) {
          return false;
        }
        const targetExists = await exists(job.targetFilePath);
        const cachedFile = await getCachedBinaryPath({
          ...job,
          version,
          failSilent
        });
        if (cachedFile) {
          const sha256FilePath = cachedFile + ".sha256";
          if (await exists(sha256FilePath)) {
            const sha256File = await readFile(sha256FilePath, "utf-8");
            const sha256Cache = await (0, getHash_1.getHash)(cachedFile);
            if (sha256File === sha256Cache) {
              if (!targetExists) {
                debug(`copying ${cachedFile} to ${job.targetFilePath}`);
                await utimes(cachedFile, new Date(), new Date());
                await copyFile(cachedFile, job.targetFilePath);
              }
              const targetSha256 = await (0, getHash_1.getHash)(job.targetFilePath);
              if (sha256File !== targetSha256) {
                debug(`overwriting ${job.targetFilePath} with ${cachedFile} as hashes do not match`);
                await copyFile(cachedFile, job.targetFilePath);
              }
              return false;
            } else {
              return true;
            }
          } else {
            return true;
          }
        }
        if (!targetExists) {
          debug(`file ${job.targetFilePath} does not exist and must be downloaded`);
          return true;
        }
        if (job.binaryTarget === nativePlatform && job.binaryName !== BinaryType.libqueryEngine) {
          const works = await checkVersionCommand(job.targetFilePath);
          return !works;
        }
        return false;
      }
      __name(binaryNeedsToBeDownloaded, "binaryNeedsToBeDownloaded");
      async function getVersion(enginePath2) {
        const result = await (0, execa_1.default)(enginePath2, ["--version"]);
        return result.stdout;
      }
      __name(getVersion, "getVersion");
      exports.getVersion = getVersion;
      async function checkVersionCommand(enginePath2) {
        try {
          const version = await getVersion(enginePath2);
          return version.length > 0;
        } catch (e) {
          return false;
        }
      }
      __name(checkVersionCommand, "checkVersionCommand");
      exports.checkVersionCommand = checkVersionCommand;
      function getBinaryName(binaryName, platform2) {
        if (binaryName === BinaryType.libqueryEngine) {
          return `${(0, get_platform_1.getNodeAPIName)(platform2, "url")}`;
        }
        const extension = platform2 === "windows" ? ".exe" : "";
        return `${binaryName}-${platform2}${extension}`;
      }
      __name(getBinaryName, "getBinaryName");
      exports.getBinaryName = getBinaryName;
      async function getCachedBinaryPath({ version, binaryTarget, binaryName }) {
        const cacheDir = await (0, util_2.getCacheDir)(channel, version, binaryTarget);
        if (!cacheDir) {
          return null;
        }
        const cachedTargetPath = path_1.default.join(cacheDir, binaryName);
        if (!fs_1.default.existsSync(cachedTargetPath)) {
          return null;
        }
        if (version !== "latest") {
          return cachedTargetPath;
        }
        if (await exists(cachedTargetPath)) {
          return cachedTargetPath;
        }
        return null;
      }
      __name(getCachedBinaryPath, "getCachedBinaryPath");
      function getBinaryEnvVarPath(binaryName) {
        const envVar = BINARY_TO_ENV_VAR[binaryName];
        if (envVar && process.env[envVar]) {
          const envVarPath = path_1.default.resolve(process.cwd(), process.env[envVar]);
          if (!fs_1.default.existsSync(envVarPath)) {
            throw new Error(`Env var ${chalk_1.default.bold(envVar)} is provided but provided path ${chalk_1.default.underline(process.env[envVar])} can't be resolved.`);
          }
          debug(`Using env var ${chalk_1.default.bold(envVar)} for binary ${chalk_1.default.bold(binaryName)}, which points to ${chalk_1.default.underline(process.env[envVar])}`);
          return envVarPath;
        }
        return null;
      }
      __name(getBinaryEnvVarPath, "getBinaryEnvVarPath");
      exports.getBinaryEnvVarPath = getBinaryEnvVarPath;
      async function downloadBinary(options2) {
        const { version, progressCb, targetFilePath, binaryTarget, binaryName } = options2;
        const downloadUrl = (0, util_2.getDownloadUrl)("all_commits", version, binaryTarget, binaryName);
        const targetDir = path_1.default.dirname(targetFilePath);
        try {
          fs_1.default.accessSync(targetDir, fs_1.default.constants.W_OK);
          await (0, make_dir_1.default)(targetDir);
        } catch (e) {
          if (options2.failSilent || e.code !== "EACCES") {
            return;
          } else {
            throw new Error(`Can't write to ${targetDir} please make sure you install "prisma" with the right permissions.`);
          }
        }
        debug(`Downloading ${downloadUrl} to ${targetFilePath}`);
        if (progressCb) {
          progressCb(0);
        }
        const { sha256, zippedSha256 } = await (0, downloadZip_1.downloadZip)(downloadUrl, targetFilePath, progressCb);
        if (progressCb) {
          progressCb(1);
        }
        if (process.platform !== "win32") {
          (0, chmod_1.default)(targetFilePath);
        }
        await saveFileToCache(options2, version, sha256, zippedSha256);
      }
      __name(downloadBinary, "downloadBinary");
      async function saveFileToCache(job, version, sha256, zippedSha256) {
        const cacheDir = await (0, util_2.getCacheDir)(channel, version, job.binaryTarget);
        if (!cacheDir) {
          return;
        }
        const cachedTargetPath = path_1.default.join(cacheDir, job.binaryName);
        const cachedSha256Path = path_1.default.join(cacheDir, job.binaryName + ".sha256");
        const cachedSha256ZippedPath = path_1.default.join(cacheDir, job.binaryName + ".gz.sha256");
        try {
          await copyFile(job.targetFilePath, cachedTargetPath);
          await writeFile(cachedSha256Path, sha256);
          await writeFile(cachedSha256ZippedPath, zippedSha256);
        } catch (e) {
          debug(e);
        }
      }
      __name(saveFileToCache, "saveFileToCache");
      function engineTypeToBinaryType(engineType, binaryTarget) {
        if (BinaryType[engineType]) {
          return BinaryType[engineType];
        }
        if (engineType === "native") {
          return binaryTarget;
        }
        return engineType;
      }
      __name(engineTypeToBinaryType, "engineTypeToBinaryType");
      function mapKeys(obj, mapper) {
        return Object.entries(obj).reduce((acc, [key, value]) => {
          acc[mapper(key)] = value;
          return acc;
        }, {});
      }
      __name(mapKeys, "mapKeys");
      async function maybeCopyToTmp(file) {
        const dir = eval("__dirname");
        if (dir.startsWith("/snapshot/")) {
          const targetDir = path_1.default.join(temp_dir_1.default, "prisma-binaries");
          await (0, make_dir_1.default)(targetDir);
          const target = path_1.default.join(targetDir, path_1.default.basename(file));
          const data = await readFile(file);
          await writeFile(target, data);
          plusX(target);
          return target;
        }
        return file;
      }
      __name(maybeCopyToTmp, "maybeCopyToTmp");
      exports.maybeCopyToTmp = maybeCopyToTmp;
      function plusX(file2) {
        const s = fs_1.default.statSync(file2);
        const newMode = s.mode | 64 | 8 | 1;
        if (s.mode === newMode) {
          return;
        }
        const base8 = newMode.toString(8).slice(-3);
        fs_1.default.chmodSync(file2, base8);
      }
      __name(plusX, "plusX");
      exports.plusX = plusX;
    });
    var require_dist6 = __commonJS((exports2) => {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getProxyAgent = exports2.urlExists = exports2.getLatestTag = exports2.getAllUrls = void 0;
      __exportStar2(require_download(), exports2);
      var getLatestTag_12 = require_getLatestTag();
      Object.defineProperty(exports2, "getAllUrls", { enumerable: true, get: function() {
        return getLatestTag_12.getAllUrls;
      } });
      Object.defineProperty(exports2, "getLatestTag", { enumerable: true, get: function() {
        return getLatestTag_12.getLatestTag;
      } });
      Object.defineProperty(exports2, "urlExists", { enumerable: true, get: function() {
        return getLatestTag_12.urlExists;
      } });
      var getProxyAgent_1 = require_getProxyAgent();
      Object.defineProperty(exports2, "getProxyAgent", { enumerable: true, get: function() {
        return getProxyAgent_1.getProxyAgent;
      } });
    });
    __markAsModule(exports);
    __export(exports, {
      DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE: () => DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE,
      enginesVersion: () => import_engines_version2.enginesVersion,
      ensureBinariesExist: () => ensureBinariesExist,
      getCliQueryEngineBinaryType: () => getCliQueryEngineBinaryType,
      getEnginesPath: () => getEnginesPath
    });
    var import_debug = __toModule(require_dist());
    var import_engines_version = __toModule(require_engines_version());
    var import_fetch_engine = __toModule(require_dist6());
    var import_path = __toModule(__require("path"));
    var import_engines_version2 = __toModule(require_engines_version());
    var debug2 = import_debug.default("prisma:engines");
    function getEnginesPath() {
      return import_path.default.join(__dirname, "../");
    }
    __name(getEnginesPath, "getEnginesPath");
    var DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE = import_fetch_engine.BinaryType.libqueryEngine;
    function getCliQueryEngineBinaryType() {
      const envCliQueryEngineType = process.env.PRISMA_CLI_QUERY_ENGINE_TYPE;
      if (envCliQueryEngineType) {
        if (envCliQueryEngineType === "binary") {
          return import_fetch_engine.BinaryType.queryEngine;
        }
        if (envCliQueryEngineType === "library") {
          return import_fetch_engine.BinaryType.libqueryEngine;
        }
      }
      return DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE;
    }
    __name(getCliQueryEngineBinaryType, "getCliQueryEngineBinaryType");
    async function ensureBinariesExist() {
      const binaryDir = import_path.default.join(__dirname, "../");
      let binaryTargets = void 0;
      if (process.env.PRISMA_CLI_BINARY_TARGETS) {
        binaryTargets = process.env.PRISMA_CLI_BINARY_TARGETS.split(",");
      }
      const cliQueryEngineBinaryType = getCliQueryEngineBinaryType();
      const binaries = {
        [cliQueryEngineBinaryType]: binaryDir,
        [import_fetch_engine.BinaryType.migrationEngine]: binaryDir,
        [import_fetch_engine.BinaryType.introspectionEngine]: binaryDir,
        [import_fetch_engine.BinaryType.prismaFmt]: binaryDir
      };
      debug2(`binaries to download ${Object.keys(binaries).join(", ")}`);
      await import_fetch_engine.download({
        binaries,
        showProgress: true,
        version: import_engines_version.enginesVersion,
        failSilent: false,
        binaryTargets
      });
    }
    __name(ensureBinariesExist, "ensureBinariesExist");
    import_path.default.join(__dirname, "../query-engine-darwin");
    import_path.default.join(__dirname, "../introspection-engine-darwin");
    import_path.default.join(__dirname, "../prisma-fmt-darwin");
    import_path.default.join(__dirname, "../query-engine-darwin-arm64");
    import_path.default.join(__dirname, "../introspection-engine-darwin-arm64");
    import_path.default.join(__dirname, "../prisma-fmt-darwin-arm64");
    import_path.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
    import_path.default.join(__dirname, "../introspection-engine-debian-openssl-1.0.x");
    import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-1.0.x");
    import_path.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
    import_path.default.join(__dirname, "../introspection-engine-debian-openssl-1.1.x");
    import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-1.1.x");
    import_path.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
    import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-1.0.x");
    import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.0.x");
    import_path.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
    import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-1.1.x");
    import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.1.x");
    import_path.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
    import_path.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
    import_path.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
    import_path.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
    import_path.default.join(__dirname, "../query_engine-windows.dll.node");
  }
});

// ../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/getNodeAPIName.js
var require_getNodeAPIName2 = __commonJS2({
  "../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/getNodeAPIName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNodeAPIName = void 0;
    var NODE_API_QUERY_ENGINE_URL_BASE = "libquery_engine";
    function getNodeAPIName3(platform2, type) {
      const isUrl = type === "url";
      if (platform2.includes("windows")) {
        return isUrl ? `query_engine.dll.node` : `query_engine-${platform2}.dll.node`;
      } else if (platform2.includes("linux") || platform2.includes("debian") || platform2.includes("rhel")) {
        return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform2}.so.node`;
      } else if (platform2.includes("darwin")) {
        return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform2}.dylib.node`;
      } else {
        throw new Error(`Node API is currently not supported on your platform: ${platform2}`);
      }
    }
    __name(getNodeAPIName3, "getNodeAPIName");
    exports2.getNodeAPIName = getNodeAPIName3;
  }
});

// ../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/getPlatform.js
var require_getPlatform2 = __commonJS2({
  "../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/getPlatform.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPlatform = exports2.getOpenSSLVersion = exports2.parseOpenSSLVersion = exports2.resolveDistro = exports2.parseDistro = exports2.getos = void 0;
    var child_process_1 = __require("child_process");
    var fs_12 = __importDefault2(__require("fs"));
    var os_1 = __importDefault2(__require("os"));
    var util_12 = __require("util");
    var readFile2 = (0, util_12.promisify)(fs_12.default.readFile);
    var exists4 = (0, util_12.promisify)(fs_12.default.exists);
    async function getos() {
      const platform2 = os_1.default.platform();
      const arch = process.arch;
      if (platform2 === "freebsd") {
        const version = await gracefulExec(`freebsd-version`);
        if (version && version.trim().length > 0) {
          const regex = /^(\d+)\.?/;
          const match = regex.exec(version);
          if (match) {
            return {
              platform: "freebsd",
              distro: `freebsd${match[1]}`,
              arch
            };
          }
        }
      }
      if (platform2 !== "linux") {
        return {
          platform: platform2,
          arch
        };
      }
      return {
        platform: "linux",
        libssl: await getOpenSSLVersion(),
        distro: await resolveDistro(),
        arch
      };
    }
    __name(getos, "getos");
    exports2.getos = getos;
    function parseDistro(input) {
      const idRegex = /^ID="?([^"\n]*)"?$/im;
      const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
      const idMatch = idRegex.exec(input);
      const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
      const idLikeMatch = idLikeRegex.exec(input);
      const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
      if (id === "raspbian") {
        return "arm";
      }
      if (id === "nixos") {
        return "nixos";
      }
      if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
        return "rhel";
      }
      if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
        return "debian";
      }
      return;
    }
    __name(parseDistro, "parseDistro");
    exports2.parseDistro = parseDistro;
    async function resolveDistro() {
      const osReleaseFile = "/etc/os-release";
      const alpineReleaseFile = "/etc/alpine-release";
      if (await exists4(alpineReleaseFile)) {
        return "musl";
      } else if (await exists4(osReleaseFile)) {
        return parseDistro(await readFile2(osReleaseFile, "utf-8"));
      } else {
        return;
      }
    }
    __name(resolveDistro, "resolveDistro");
    exports2.resolveDistro = resolveDistro;
    function parseOpenSSLVersion(input) {
      const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
      if (match) {
        return match[1] + ".x";
      }
      return;
    }
    __name(parseOpenSSLVersion, "parseOpenSSLVersion");
    exports2.parseOpenSSLVersion = parseOpenSSLVersion;
    async function getOpenSSLVersion() {
      const [version, ls] = await Promise.all([
        gracefulExec(`openssl version -v`),
        gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
      ]);
      if (version) {
        const v = parseOpenSSLVersion(version);
        if (v) {
          return v;
        }
      }
      if (ls) {
        const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
        if (match) {
          return match[1] + ".x";
        }
      }
      return void 0;
    }
    __name(getOpenSSLVersion, "getOpenSSLVersion");
    exports2.getOpenSSLVersion = getOpenSSLVersion;
    async function gracefulExec(cmd) {
      return new Promise((resolve2) => {
        try {
          (0, child_process_1.exec)(cmd, (err, stdout) => {
            resolve2(String(stdout));
          });
        } catch (e) {
          resolve2(void 0);
          return void 0;
        }
      });
    }
    __name(gracefulExec, "gracefulExec");
    async function getPlatform4() {
      const { platform: platform2, libssl, distro, arch } = await getos();
      if (platform2 === "darwin" && arch === "arm64") {
        return "darwin-arm64";
      }
      if (platform2 === "darwin") {
        return "darwin";
      }
      if (platform2 === "win32") {
        return "windows";
      }
      if (platform2 === "freebsd") {
        return distro;
      }
      if (platform2 === "openbsd") {
        return "openbsd";
      }
      if (platform2 === "netbsd") {
        return "netbsd";
      }
      if (platform2 === "linux" && arch === "arm64") {
        return `linux-arm64-openssl-${libssl}`;
      }
      if (platform2 === "linux" && arch === "arm") {
        return `linux-arm-openssl-${libssl}`;
      }
      if (platform2 === "linux" && distro === "nixos") {
        return "linux-nixos";
      }
      if (platform2 === "linux" && distro === "musl") {
        return "linux-musl";
      }
      if (platform2 === "linux" && distro && libssl) {
        return distro + "-openssl-" + libssl;
      }
      if (libssl) {
        return "debian-openssl-" + libssl;
      }
      if (distro) {
        return distro + "-openssl-1.1.x";
      }
      return "debian-openssl-1.1.x";
    }
    __name(getPlatform4, "getPlatform");
    exports2.getPlatform = getPlatform4;
  }
});

// ../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/isNodeAPISupported.js
var require_isNodeAPISupported2 = __commonJS2({
  "../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/isNodeAPISupported.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNodeAPISupported = void 0;
    var fs_12 = __importDefault2(__require("fs"));
    var _1 = require_dist9();
    async function isNodeAPISupported2() {
      const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
      const customLibraryExists = customLibraryPath && fs_12.default.existsSync(customLibraryPath);
      const os2 = await (0, _1.getos)();
      if (!customLibraryExists && (os2.arch === "x32" || os2.arch === "ia32")) {
        throw new Error(`The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set \`engineType = "binary"\` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)`);
      }
    }
    __name(isNodeAPISupported2, "isNodeAPISupported");
    exports2.isNodeAPISupported = isNodeAPISupported2;
  }
});

// ../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/platforms.js
var require_platforms2 = __commonJS2({
  "../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/platforms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.platforms = void 0;
    exports2.platforms = [
      "darwin",
      "darwin-arm64",
      "debian-openssl-1.0.x",
      "debian-openssl-1.1.x",
      "rhel-openssl-1.0.x",
      "rhel-openssl-1.1.x",
      "linux-arm64-openssl-1.1.x",
      "linux-arm64-openssl-1.0.x",
      "linux-arm-openssl-1.1.x",
      "linux-arm-openssl-1.0.x",
      "linux-musl",
      "linux-nixos",
      "windows",
      "freebsd11",
      "freebsd12",
      "openbsd",
      "netbsd",
      "arm"
    ];
  }
});

// ../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/index.js
var require_dist9 = __commonJS2({
  "../../node_modules/.pnpm/@prisma+get-platform@3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727/node_modules/@prisma/get-platform/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.platforms = exports2.isNodeAPISupported = exports2.getPlatform = exports2.getos = exports2.getNodeAPIName = void 0;
    var getNodeAPIName_1 = require_getNodeAPIName2();
    Object.defineProperty(exports2, "getNodeAPIName", { enumerable: true, get: function() {
      return getNodeAPIName_1.getNodeAPIName;
    } });
    var getPlatform_1 = require_getPlatform2();
    Object.defineProperty(exports2, "getos", { enumerable: true, get: function() {
      return getPlatform_1.getos;
    } });
    Object.defineProperty(exports2, "getPlatform", { enumerable: true, get: function() {
      return getPlatform_1.getPlatform;
    } });
    var isNodeAPISupported_1 = require_isNodeAPISupported2();
    Object.defineProperty(exports2, "isNodeAPISupported", { enumerable: true, get: function() {
      return isNodeAPISupported_1.isNodeAPISupported;
    } });
    var platforms_1 = require_platforms2();
    Object.defineProperty(exports2, "platforms", { enumerable: true, get: function() {
      return platforms_1.platforms;
    } });
  }
});

// ../../node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS2({
  "../../node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js"(exports2, module2) {
    "use strict";
    var ansiEscapes = module2.exports;
    module2.exports.default = ansiEscapes;
    var ESC = "[";
    var OSC = "]";
    var BEL = "\x07";
    var SEP = ";";
    var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
    ansiEscapes.cursorTo = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      if (typeof y !== "number") {
        return ESC + (x + 1) + "G";
      }
      return ESC + (y + 1) + ";" + (x + 1) + "H";
    };
    ansiEscapes.cursorMove = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      let ret = "";
      if (x < 0) {
        ret += ESC + -x + "D";
      } else if (x > 0) {
        ret += ESC + x + "C";
      }
      if (y < 0) {
        ret += ESC + -y + "A";
      } else if (y > 0) {
        ret += ESC + y + "B";
      }
      return ret;
    };
    ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
    ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
    ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
    ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
    ansiEscapes.cursorLeft = ESC + "G";
    ansiEscapes.cursorSavePosition = isTerminalApp ? "7" : ESC + "s";
    ansiEscapes.cursorRestorePosition = isTerminalApp ? "8" : ESC + "u";
    ansiEscapes.cursorGetPosition = ESC + "6n";
    ansiEscapes.cursorNextLine = ESC + "E";
    ansiEscapes.cursorPrevLine = ESC + "F";
    ansiEscapes.cursorHide = ESC + "?25l";
    ansiEscapes.cursorShow = ESC + "?25h";
    ansiEscapes.eraseLines = (count) => {
      let clear = "";
      for (let i = 0; i < count; i++) {
        clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
      }
      if (count) {
        clear += ansiEscapes.cursorLeft;
      }
      return clear;
    };
    ansiEscapes.eraseEndLine = ESC + "K";
    ansiEscapes.eraseStartLine = ESC + "1K";
    ansiEscapes.eraseLine = ESC + "2K";
    ansiEscapes.eraseDown = ESC + "J";
    ansiEscapes.eraseUp = ESC + "1J";
    ansiEscapes.eraseScreen = ESC + "2J";
    ansiEscapes.scrollUp = ESC + "S";
    ansiEscapes.scrollDown = ESC + "T";
    ansiEscapes.clearScreen = "c";
    ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
    ansiEscapes.beep = BEL;
    ansiEscapes.link = (text, url2) => {
      return [
        OSC,
        "8",
        SEP,
        SEP,
        url2,
        BEL,
        text,
        OSC,
        "8",
        SEP,
        SEP,
        BEL
      ].join("");
    };
    ansiEscapes.image = (buffer, options2 = {}) => {
      let ret = `${OSC}1337;File=inline=1`;
      if (options2.width) {
        ret += `;width=${options2.width}`;
      }
      if (options2.height) {
        ret += `;height=${options2.height}`;
      }
      if (options2.preserveAspectRatio === false) {
        ret += ";preserveAspectRatio=0";
      }
      return ret + ":" + buffer.toString("base64") + BEL;
    };
    ansiEscapes.iTerm = {
      setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
      annotation: (message, options2 = {}) => {
        let ret = `${OSC}1337;`;
        const hasX = typeof options2.x !== "undefined";
        const hasY = typeof options2.y !== "undefined";
        if ((hasX || hasY) && !(hasX && hasY && typeof options2.length !== "undefined")) {
          throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
        }
        message = message.replace(/\|/g, "");
        ret += options2.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
        if (options2.length > 0) {
          ret += (hasX ? [message, options2.length, options2.x, options2.y] : [options2.length, message]).join("|");
        } else {
          ret += message;
        }
        return ret + BEL;
      }
    };
  }
});

// ../../node_modules/.pnpm/supports-hyperlinks@2.2.0/node_modules/supports-hyperlinks/index.js
var require_supports_hyperlinks = __commonJS2({
  "../../node_modules/.pnpm/supports-hyperlinks@2.2.0/node_modules/supports-hyperlinks/index.js"(exports2, module2) {
    "use strict";
    var supportsColor = require_supports_color2();
    var hasFlag = require_has_flag2();
    function parseVersion(versionString) {
      if (/^\d{3,4}$/.test(versionString)) {
        const m = /(\d{1,2})(\d{2})/.exec(versionString);
        return {
          major: 0,
          minor: parseInt(m[1], 10),
          patch: parseInt(m[2], 10)
        };
      }
      const versions = (versionString || "").split(".").map((n) => parseInt(n, 10));
      return {
        major: versions[0],
        minor: versions[1],
        patch: versions[2]
      };
    }
    __name(parseVersion, "parseVersion");
    function supportsHyperlink(stream3) {
      const { env } = process;
      if ("FORCE_HYPERLINK" in env) {
        return !(env.FORCE_HYPERLINK.length > 0 && parseInt(env.FORCE_HYPERLINK, 10) === 0);
      }
      if (hasFlag("no-hyperlink") || hasFlag("no-hyperlinks") || hasFlag("hyperlink=false") || hasFlag("hyperlink=never")) {
        return false;
      }
      if (hasFlag("hyperlink=true") || hasFlag("hyperlink=always")) {
        return true;
      }
      if (!supportsColor.supportsColor(stream3)) {
        return false;
      }
      if (stream3 && !stream3.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return false;
      }
      if ("NETLIFY" in env) {
        return true;
      }
      if ("CI" in env) {
        return false;
      }
      if ("TEAMCITY_VERSION" in env) {
        return false;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseVersion(env.TERM_PROGRAM_VERSION);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            if (version.major === 3) {
              return version.minor >= 1;
            }
            return version.major > 3;
        }
      }
      if ("VTE_VERSION" in env) {
        if (env.VTE_VERSION === "0.50.0") {
          return false;
        }
        const version = parseVersion(env.VTE_VERSION);
        return version.major > 0 || version.minor >= 50;
      }
      return false;
    }
    __name(supportsHyperlink, "supportsHyperlink");
    module2.exports = {
      supportsHyperlink,
      stdout: supportsHyperlink(process.stdout),
      stderr: supportsHyperlink(process.stderr)
    };
  }
});

// ../../node_modules/.pnpm/terminal-link@2.1.1/node_modules/terminal-link/index.js
var require_terminal_link = __commonJS2({
  "../../node_modules/.pnpm/terminal-link@2.1.1/node_modules/terminal-link/index.js"(exports2, module2) {
    "use strict";
    var ansiEscapes = require_ansi_escapes();
    var supportsHyperlinks = require_supports_hyperlinks();
    var terminalLink2 = /* @__PURE__ */ __name((text, url2, { target = "stdout", ...options2 } = {}) => {
      if (!supportsHyperlinks[target]) {
        if (options2.fallback === false) {
          return text;
        }
        return typeof options2.fallback === "function" ? options2.fallback(text, url2) : `${text} (\u200B${url2}\u200B)`;
      }
      return ansiEscapes.link(text, url2);
    }, "terminalLink");
    module2.exports = (text, url2, options2 = {}) => terminalLink2(text, url2, options2);
    module2.exports.stderr = (text, url2, options2 = {}) => terminalLink2(text, url2, { target: "stderr", ...options2 });
    module2.exports.isSupported = supportsHyperlinks.stdout;
    module2.exports.stderr.isSupported = supportsHyperlinks.stderr;
  }
});

// ../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js
var require_new_github_issue_url = __commonJS2({
  "../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (options2 = {}) => {
      let repoUrl;
      if (options2.repoUrl) {
        repoUrl = options2.repoUrl;
      } else if (options2.user && options2.repo) {
        repoUrl = `https://github.com/${options2.user}/${options2.repo}`;
      } else {
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      }
      const url2 = new URL(`${repoUrl}/issues/new`);
      const types = [
        "body",
        "title",
        "labels",
        "template",
        "milestone",
        "assignee",
        "projects"
      ];
      for (const type of types) {
        let value = options2[type];
        if (value === void 0) {
          continue;
        }
        if (type === "labels" || type === "projects") {
          if (!Array.isArray(value)) {
            throw new TypeError(`The \`${type}\` option should be an array`);
          }
          value = value.join(",");
        }
        url2.searchParams.set(type, value);
      }
      return url2.toString();
    };
    module2.exports.default = module2.exports;
  }
});

// ../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js
var require_strip_final_newline2 = __commonJS2({
  "../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => {
      const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
      const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
      if (input[input.length - 1] === LF) {
        input = input.slice(0, input.length - 1);
      }
      if (input[input.length - 1] === CR) {
        input = input.slice(0, input.length - 1);
      }
      return input;
    };
  }
});

// ../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js
var require_npm_run_path2 = __commonJS2({
  "../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js"(exports2, module2) {
    "use strict";
    var path6 = __require("path");
    var pathKey = require_path_key2();
    var npmRunPath = /* @__PURE__ */ __name((options2) => {
      options2 = {
        cwd: process.cwd(),
        path: process.env[pathKey()],
        execPath: process.execPath,
        ...options2
      };
      let previous;
      let cwdPath = path6.resolve(options2.cwd);
      const result = [];
      while (previous !== cwdPath) {
        result.push(path6.join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = path6.resolve(cwdPath, "..");
      }
      const execPathDir = path6.resolve(options2.cwd, options2.execPath, "..");
      result.push(execPathDir);
      return result.concat(options2.path).join(path6.delimiter);
    }, "npmRunPath");
    module2.exports = npmRunPath;
    module2.exports.default = npmRunPath;
    module2.exports.env = (options2) => {
      options2 = {
        env: process.env,
        ...options2
      };
      const env = { ...options2.env };
      const path7 = pathKey({ env });
      options2.path = env[path7];
      env[path7] = module2.exports(options2);
      return env;
    };
  }
});

// ../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js
var require_mimic_fn2 = __commonJS2({
  "../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = /* @__PURE__ */ __name((to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    }, "mimicFn");
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// ../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js
var require_onetime2 = __commonJS2({
  "../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn2();
    var calledFunctions = new WeakMap();
    var onetime = /* @__PURE__ */ __name((function_, options2 = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = /* @__PURE__ */ __name(function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options2.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      }, "onetime");
      mimicFn(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    }, "onetime");
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  }
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js
var require_core2 = __commonJS2({
  "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SIGNALS = void 0;
    var SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    exports2.SIGNALS = SIGNALS;
  }
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js
var require_realtime2 = __commonJS2({
  "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
    var getRealtimeSignals = /* @__PURE__ */ __name(function() {
      const length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({ length }, getRealtimeSignal);
    }, "getRealtimeSignals");
    exports2.getRealtimeSignals = getRealtimeSignals;
    var getRealtimeSignal = /* @__PURE__ */ __name(function(value, index) {
      return {
        name: `SIGRT${index + 1}`,
        number: SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    }, "getRealtimeSignal");
    var SIGRTMIN = 34;
    var SIGRTMAX = 64;
    exports2.SIGRTMAX = SIGRTMAX;
  }
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js
var require_signals3 = __commonJS2({
  "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSignals = void 0;
    var _os = __require("os");
    var _core = require_core2();
    var _realtime = require_realtime2();
    var getSignals = /* @__PURE__ */ __name(function() {
      const realtimeSignals = (0, _realtime.getRealtimeSignals)();
      const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
      return signals;
    }, "getSignals");
    exports2.getSignals = getSignals;
    var normalizeSignal = /* @__PURE__ */ __name(function({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard
    }) {
      const {
        signals: { [name]: constantSignal }
      } = _os.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return { name, number, description, supported, action, forced, standard };
    }, "normalizeSignal");
  }
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js
var require_main2 = __commonJS2({
  "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalsByNumber = exports2.signalsByName = void 0;
    var _os = __require("os");
    var _signals = require_signals3();
    var _realtime = require_realtime2();
    var getSignalsByName = /* @__PURE__ */ __name(function() {
      const signals = (0, _signals.getSignals)();
      return signals.reduce(getSignalByName, {});
    }, "getSignalsByName");
    var getSignalByName = /* @__PURE__ */ __name(function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
      return {
        ...signalByNameMemo,
        [name]: { name, number, description, supported, action, forced, standard }
      };
    }, "getSignalByName");
    var signalsByName = getSignalsByName();
    exports2.signalsByName = signalsByName;
    var getSignalsByNumber = /* @__PURE__ */ __name(function() {
      const signals = (0, _signals.getSignals)();
      const length = _realtime.SIGRTMAX + 1;
      const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
      return Object.assign({}, ...signalsA);
    }, "getSignalsByNumber");
    var getSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {
      const signal = findSignalByNumber(number, signals);
      if (signal === void 0) {
        return {};
      }
      const { name, description, supported, action, forced, standard } = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    }, "getSignalByNumber");
    var findSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {
      const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals.find((signalA) => signalA.number === number);
    }, "findSignalByNumber");
    var signalsByNumber = getSignalsByNumber();
    exports2.signalsByNumber = signalsByNumber;
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js
var require_error3 = __commonJS2({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js"(exports2, module2) {
    "use strict";
    var { signalsByName } = require_main2();
    var getErrorPrefix = /* @__PURE__ */ __name(({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    }, "getErrorPrefix");
    var makeError = /* @__PURE__ */ __name(({
      stdout,
      stderr,
      all,
      error: error2,
      signal,
      exitCode,
      command,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: { options: { timeout } }
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
      const errorCode = error2 && error2.code;
      const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
      const execaMessage = `Command ${prefix}: ${command}`;
      const isError2 = Object.prototype.toString.call(error2) === "[object Error]";
      const shortMessage = isError2 ? `${execaMessage}
${error2.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError2) {
        error2.originalMessage = error2.message;
        error2.message = message;
      } else {
        error2 = new Error(message);
      }
      error2.shortMessage = shortMessage;
      error2.command = command;
      error2.escapedCommand = escapedCommand;
      error2.exitCode = exitCode;
      error2.signal = signal;
      error2.signalDescription = signalDescription;
      error2.stdout = stdout;
      error2.stderr = stderr;
      if (all !== void 0) {
        error2.all = all;
      }
      if ("bufferedData" in error2) {
        delete error2.bufferedData;
      }
      error2.failed = true;
      error2.timedOut = Boolean(timedOut);
      error2.isCanceled = isCanceled;
      error2.killed = killed && !timedOut;
      return error2;
    }, "makeError");
    module2.exports = makeError;
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js
var require_stdio2 = __commonJS2({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js"(exports2, module2) {
    "use strict";
    var aliases = ["stdin", "stdout", "stderr"];
    var hasAlias = /* @__PURE__ */ __name((options2) => aliases.some((alias) => options2[alias] !== void 0), "hasAlias");
    var normalizeStdio = /* @__PURE__ */ __name((options2) => {
      if (!options2) {
        return;
      }
      const { stdio } = options2;
      if (stdio === void 0) {
        return aliases.map((alias) => options2[alias]);
      }
      if (hasAlias(options2)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
      }
      if (typeof stdio === "string") {
        return stdio;
      }
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const length = Math.max(stdio.length, aliases.length);
      return Array.from({ length }, (value, index) => stdio[index]);
    }, "normalizeStdio");
    module2.exports = normalizeStdio;
    module2.exports.node = (options2) => {
      const stdio = normalizeStdio(options2);
      if (stdio === "ipc") {
        return "ipc";
      }
      if (stdio === void 0 || typeof stdio === "string") {
        return [stdio, stdio, stdio, "ipc"];
      }
      if (stdio.includes("ipc")) {
        return stdio;
      }
      return [...stdio, "ipc"];
    };
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.5/node_modules/signal-exit/signals.js
var require_signals4 = __commonJS2({
  "../../node_modules/.pnpm/signal-exit@3.0.5/node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.5/node_modules/signal-exit/index.js
var require_signal_exit2 = __commonJS2({
  "../../node_modules/.pnpm/signal-exit@3.0.5/node_modules/signal-exit/index.js"(exports2, module2) {
    var process2 = global.process;
    if (typeof process2 !== "object" || !process2) {
      module2.exports = function() {
      };
    } else {
      assert = __require("assert");
      signals = require_signals4();
      isWin = /^win/i.test(process2.platform);
      EE = __require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts2) {
        if (global.process !== process2) {
          return;
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts2 && opts2.alwaysLast) {
          ev = "afterexit";
        }
        var remove = /* @__PURE__ */ __name(function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        }, "remove");
        emitter.on(ev, cb);
        return remove;
      };
      unload = /* @__PURE__ */ __name(function unload2() {
        if (!loaded || global.process !== process2) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      }, "unload");
      module2.exports.unload = unload;
      emit = /* @__PURE__ */ __name(function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      }, "emit");
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = /* @__PURE__ */ __name(function listener() {
          if (process2 !== global.process) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        }, "listener");
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = /* @__PURE__ */ __name(function load2() {
        if (loaded || process2 !== global.process) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      }, "load");
      module2.exports.load = load;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = /* @__PURE__ */ __name(function processReallyExit2(code) {
        if (process2 !== global.process) {
          return;
        }
        process2.exitCode = code || 0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      }, "processReallyExit");
      originalProcessEmit = process2.emit;
      processEmit = /* @__PURE__ */ __name(function processEmit2(ev, arg2) {
        if (ev === "exit" && process2 === global.process) {
          if (arg2 !== void 0) {
            process2.exitCode = arg2;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      }, "processEmit");
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js
var require_kill2 = __commonJS2({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js"(exports2, module2) {
    "use strict";
    var os2 = __require("os");
    var onExit = require_signal_exit2();
    var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
    var spawnedKill = /* @__PURE__ */ __name((kill, signal = "SIGTERM", options2 = {}) => {
      const killResult = kill(signal);
      setKillTimeout(kill, signal, options2, killResult);
      return killResult;
    }, "spawnedKill");
    var setKillTimeout = /* @__PURE__ */ __name((kill, signal, options2, killResult) => {
      if (!shouldForceKill(signal, options2, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout(options2);
      const t = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      if (t.unref) {
        t.unref();
      }
    }, "setKillTimeout");
    var shouldForceKill = /* @__PURE__ */ __name((signal, { forceKillAfterTimeout }, killResult) => {
      return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    }, "shouldForceKill");
    var isSigterm = /* @__PURE__ */ __name((signal) => {
      return signal === os2.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    }, "isSigterm");
    var getForceKillAfterTimeout = /* @__PURE__ */ __name(({ forceKillAfterTimeout = true }) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    }, "getForceKillAfterTimeout");
    var spawnedCancel = /* @__PURE__ */ __name((spawned, context) => {
      const killResult = spawned.kill();
      if (killResult) {
        context.isCanceled = true;
      }
    }, "spawnedCancel");
    var timeoutKill = /* @__PURE__ */ __name((spawned, signal, reject2) => {
      spawned.kill(signal);
      reject2(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
    }, "timeoutKill");
    var setupTimeout = /* @__PURE__ */ __name((spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve2, reject2) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject2);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    }, "setupTimeout");
    var validateTimeout = /* @__PURE__ */ __name(({ timeout }) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
    }, "validateTimeout");
    var setExitHandler = /* @__PURE__ */ __name(async (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    }, "setExitHandler");
    module2.exports = {
      spawnedKill,
      spawnedCancel,
      setupTimeout,
      validateTimeout,
      setExitHandler
    };
  }
});

// ../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js
var require_is_stream2 = __commonJS2({
  "../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = /* @__PURE__ */ __name((stream3) => stream3 !== null && typeof stream3 === "object" && typeof stream3.pipe === "function", "isStream");
    isStream.writable = (stream3) => isStream(stream3) && stream3.writable !== false && typeof stream3._write === "function" && typeof stream3._writableState === "object";
    isStream.readable = (stream3) => isStream(stream3) && stream3.readable !== false && typeof stream3._read === "function" && typeof stream3._readableState === "object";
    isStream.duplex = (stream3) => isStream.writable(stream3) && isStream.readable(stream3);
    isStream.transform = (stream3) => isStream.duplex(stream3) && typeof stream3._transform === "function";
    module2.exports = isStream;
  }
});

// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS2({
  "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = __require("stream");
    module2.exports = (options2) => {
      options2 = { ...options2 };
      const { array } = options2;
      let { encoding } = options2;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream3 = new PassThroughStream({ objectMode });
      if (encoding) {
        stream3.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream3.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream3.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream3.getBufferedLength = () => length;
      return stream3;
    };
  }
});

// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js
var require_get_stream2 = __commonJS2({
  "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = __require("buffer");
    var stream3 = __require("stream");
    var { promisify: promisify3 } = __require("util");
    var bufferStream = require_buffer_stream2();
    var streamPipelinePromisified = promisify3(stream3.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    __name(MaxBufferError, "MaxBufferError");
    async function getStream2(inputStream, options2) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options2 = {
        maxBuffer: Infinity,
        ...options2
      };
      const { maxBuffer } = options2;
      const stream4 = bufferStream(options2);
      await new Promise((resolve2, reject2) => {
        const rejectPromise = /* @__PURE__ */ __name((error2) => {
          if (error2 && stream4.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error2.bufferedData = stream4.getBufferedValue();
          }
          reject2(error2);
        }, "rejectPromise");
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream4);
            resolve2();
          } catch (error2) {
            rejectPromise(error2);
          }
        })();
        stream4.on("data", () => {
          if (stream4.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream4.getBufferedValue();
    }
    __name(getStream2, "getStream");
    module2.exports = getStream2;
    module2.exports.buffer = (stream4, options2) => getStream2(stream4, { ...options2, encoding: "buffer" });
    module2.exports.array = (stream4, options2) => getStream2(stream4, { ...options2, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// ../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js
var require_merge_stream2 = __commonJS2({
  "../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js"(exports2, module2) {
    "use strict";
    var { PassThrough } = __require("stream");
    module2.exports = function() {
      var sources = [];
      var output = new PassThrough({ objectMode: true });
      output.setMaxListeners(0);
      output.add = add2;
      output.isEmpty = isEmpty;
      output.on("unpipe", remove);
      Array.prototype.slice.call(arguments).forEach(add2);
      return output;
      function add2(source) {
        if (Array.isArray(source)) {
          source.forEach(add2);
          return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, { end: false });
        return this;
      }
      __name(add2, "add");
      function isEmpty() {
        return sources.length == 0;
      }
      __name(isEmpty, "isEmpty");
      function remove(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
      __name(remove, "remove");
    };
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js
var require_stream6 = __commonJS2({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js"(exports2, module2) {
    "use strict";
    var isStream = require_is_stream2();
    var getStream2 = require_get_stream2();
    var mergeStream = require_merge_stream2();
    var handleInput = /* @__PURE__ */ __name((spawned, input) => {
      if (input === void 0 || spawned.stdin === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    }, "handleInput");
    var makeAllStream = /* @__PURE__ */ __name((spawned, { all }) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = mergeStream();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    }, "makeAllStream");
    var getBufferedData = /* @__PURE__ */ __name(async (stream3, streamPromise) => {
      if (!stream3) {
        return;
      }
      stream3.destroy();
      try {
        return await streamPromise;
      } catch (error2) {
        return error2.bufferedData;
      }
    }, "getBufferedData");
    var getStreamPromise = /* @__PURE__ */ __name((stream3, { encoding, buffer, maxBuffer }) => {
      if (!stream3 || !buffer) {
        return;
      }
      if (encoding) {
        return getStream2(stream3, { encoding, maxBuffer });
      }
      return getStream2.buffer(stream3, { maxBuffer });
    }, "getStreamPromise");
    var getSpawnedResult = /* @__PURE__ */ __name(async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
      const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
      const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error2) {
        return Promise.all([
          { error: error2, signal: error2.signal, timedOut: error2.timedOut },
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    }, "getSpawnedResult");
    var validateInputSync = /* @__PURE__ */ __name(({ input }) => {
      if (isStream(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
    }, "validateInputSync");
    module2.exports = {
      handleInput,
      makeAllStream,
      getSpawnedResult,
      validateInputSync
    };
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js
var require_promise2 = __commonJS2({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js"(exports2, module2) {
    "use strict";
    var nativePromisePrototype = (async () => {
    })().constructor.prototype;
    var descriptors = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
    var mergePromise = /* @__PURE__ */ __name((spawned, promise) => {
      for (const [property, descriptor] of descriptors) {
        const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, { ...descriptor, value });
      }
      return spawned;
    }, "mergePromise");
    var getSpawnedPromise = /* @__PURE__ */ __name((spawned) => {
      return new Promise((resolve2, reject2) => {
        spawned.on("exit", (exitCode, signal) => {
          resolve2({ exitCode, signal });
        });
        spawned.on("error", (error2) => {
          reject2(error2);
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (error2) => {
            reject2(error2);
          });
        }
      });
    }, "getSpawnedPromise");
    module2.exports = {
      mergePromise,
      getSpawnedPromise
    };
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js
var require_command2 = __commonJS2({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js"(exports2, module2) {
    "use strict";
    var normalizeArgs = /* @__PURE__ */ __name((file2, args = []) => {
      if (!Array.isArray(args)) {
        return [file2];
      }
      return [file2, ...args];
    }, "normalizeArgs");
    var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    var DOUBLE_QUOTES_REGEXP = /"/g;
    var escapeArg = /* @__PURE__ */ __name((arg2) => {
      if (typeof arg2 !== "string" || NO_ESCAPE_REGEXP.test(arg2)) {
        return arg2;
      }
      return `"${arg2.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
    }, "escapeArg");
    var joinCommand = /* @__PURE__ */ __name((file2, args) => {
      return normalizeArgs(file2, args).join(" ");
    }, "joinCommand");
    var getEscapedCommand = /* @__PURE__ */ __name((file2, args) => {
      return normalizeArgs(file2, args).map((arg2) => escapeArg(arg2)).join(" ");
    }, "getEscapedCommand");
    var SPACES_REGEXP = / +/g;
    var parseCommand = /* @__PURE__ */ __name((command) => {
      const tokens = [];
      for (const token of command.trim().split(SPACES_REGEXP)) {
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
          tokens.push(token);
        }
      }
      return tokens;
    }, "parseCommand");
    module2.exports = {
      joinCommand,
      getEscapedCommand,
      parseCommand
    };
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js
var require_execa2 = __commonJS2({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js"(exports2, module2) {
    "use strict";
    var path6 = __require("path");
    var childProcess = __require("child_process");
    var crossSpawn = require_cross_spawn2();
    var stripFinalNewline = require_strip_final_newline2();
    var npmRunPath = require_npm_run_path2();
    var onetime = require_onetime2();
    var makeError = require_error3();
    var normalizeStdio = require_stdio2();
    var { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = require_kill2();
    var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream6();
    var { mergePromise, getSpawnedPromise } = require_promise2();
    var { joinCommand, parseCommand, getEscapedCommand } = require_command2();
    var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
    var getEnv = /* @__PURE__ */ __name(({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
      const env = extendEnv ? { ...process.env, ...envOption } : envOption;
      if (preferLocal) {
        return npmRunPath.env({ env, cwd: localDir, execPath });
      }
      return env;
    }, "getEnv");
    var handleArguments = /* @__PURE__ */ __name((file2, args, options2 = {}) => {
      const parsed = crossSpawn._parse(file2, args, options2);
      file2 = parsed.command;
      args = parsed.args;
      options2 = parsed.options;
      options2 = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options2.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        ...options2
      };
      options2.env = getEnv(options2);
      options2.stdio = normalizeStdio(options2);
      if (process.platform === "win32" && path6.basename(file2, ".exe") === "cmd") {
        args.unshift("/q");
      }
      return { file: file2, args, options: options2, parsed };
    }, "handleArguments");
    var handleOutput = /* @__PURE__ */ __name((options2, value, error2) => {
      if (typeof value !== "string" && !Buffer.isBuffer(value)) {
        return error2 === void 0 ? void 0 : "";
      }
      if (options2.stripFinalNewline) {
        return stripFinalNewline(value);
      }
      return value;
    }, "handleOutput");
    var execa2 = /* @__PURE__ */ __name((file2, args, options2) => {
      const parsed = handleArguments(file2, args, options2);
      const command = joinCommand(file2, args);
      const escapedCommand = getEscapedCommand(file2, args);
      validateTimeout(parsed.options);
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error2) {
        const dummySpawned = new childProcess.ChildProcess();
        const errorPromise = Promise.reject(makeError({
          error: error2,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        }));
        return mergePromise(dummySpawned, errorPromise);
      }
      const spawnedPromise = getSpawnedPromise(spawned);
      const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
      const processDone = setExitHandler(spawned, parsed.options, timedPromise);
      const context = { isCanceled: false };
      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
      spawned.cancel = spawnedCancel.bind(null, spawned, context);
      const handlePromise = /* @__PURE__ */ __name(async () => {
        const [{ error: error2, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
        const stdout = handleOutput(parsed.options, stdoutResult);
        const stderr = handleOutput(parsed.options, stderrResult);
        const all = handleOutput(parsed.options, allResult);
        if (error2 || exitCode !== 0 || signal !== null) {
          const returnedError = makeError({
            error: error2,
            exitCode,
            signal,
            stdout,
            stderr,
            all,
            command,
            escapedCommand,
            parsed,
            timedOut,
            isCanceled: context.isCanceled,
            killed: spawned.killed
          });
          if (!parsed.options.reject) {
            return returnedError;
          }
          throw returnedError;
        }
        return {
          command,
          escapedCommand,
          exitCode: 0,
          stdout,
          stderr,
          all,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      }, "handlePromise");
      const handlePromiseOnce = onetime(handlePromise);
      handleInput(spawned, parsed.options.input);
      spawned.all = makeAllStream(spawned, parsed.options);
      return mergePromise(spawned, handlePromiseOnce);
    }, "execa");
    module2.exports = execa2;
    module2.exports.sync = (file2, args, options2) => {
      const parsed = handleArguments(file2, args, options2);
      const command = joinCommand(file2, args);
      const escapedCommand = getEscapedCommand(file2, args);
      validateInputSync(parsed.options);
      let result;
      try {
        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error2) {
        throw makeError({
          error: error2,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        });
      }
      const stdout = handleOutput(parsed.options, result.stdout, result.error);
      const stderr = handleOutput(parsed.options, result.stderr, result.error);
      if (result.error || result.status !== 0 || result.signal !== null) {
        const error2 = makeError({
          stdout,
          stderr,
          error: result.error,
          signal: result.signal,
          exitCode: result.status,
          command,
          escapedCommand,
          parsed,
          timedOut: result.error && result.error.code === "ETIMEDOUT",
          isCanceled: false,
          killed: result.signal !== null
        });
        if (!parsed.options.reject) {
          return error2;
        }
        throw error2;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    module2.exports.command = (command, options2) => {
      const [file2, ...args] = parseCommand(command);
      return execa2(file2, args, options2);
    };
    module2.exports.commandSync = (command, options2) => {
      const [file2, ...args] = parseCommand(command);
      return execa2.sync(file2, args, options2);
    };
    module2.exports.node = (scriptPath, args, options2 = {}) => {
      if (args && !Array.isArray(args) && typeof args === "object") {
        options2 = args;
        args = [];
      }
      const stdio = normalizeStdio.node(options2);
      const defaultExecArgv = process.execArgv.filter((arg2) => !arg2.startsWith("--inspect"));
      const {
        nodePath = process.execPath,
        nodeOptions = defaultExecArgv
      } = options2;
      return execa2(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
      ], {
        ...options2,
        stdin: void 0,
        stdout: void 0,
        stderr: void 0,
        stdio,
        shell: false
      });
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation2 = __commonJS2({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options2) {
      if (typeof options2 === "boolean") {
        options2 = { forever: options2 };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options2 || {};
      this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    __name(RetryOperation, "RetryOperation");
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error2 = this._errors[i];
        var message = error2.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error2;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry3 = __commonJS2({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation2();
    exports2.operation = function(options2) {
      var timeouts = exports2.timeouts(options2);
      return new RetryOperation(timeouts, {
        forever: options2 && (options2.forever || options2.retries === Infinity),
        unref: options2 && options2.unref,
        maxRetryTime: options2 && options2.maxRetryTime
      });
    };
    exports2.timeouts = function(options2) {
      if (options2 instanceof Array) {
        return [].concat(options2);
      }
      var opts2 = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options2) {
        opts2[key] = options2[key];
      }
      if (opts2.minTimeout > opts2.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts2.retries; i++) {
        timeouts.push(this.createTimeout(i, opts2));
      }
      if (options2 && options2.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts2));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts2) {
      var random2 = opts2.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random2 * Math.max(opts2.minTimeout, 1) * Math.pow(opts2.factor, attempt));
      timeout = Math.min(timeout, opts2.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options2, methods) {
      if (options2 instanceof Array) {
        methods = options2;
        options2 = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
          var op = exports2.operation(options2);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }, "retryWrapper")).bind(obj, original);
        obj[method].options = options2;
      }
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry4 = __commonJS2({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry3();
  }
});

// ../../node_modules/.pnpm/p-retry@4.6.1/node_modules/p-retry/index.js
var require_p_retry2 = __commonJS2({
  "../../node_modules/.pnpm/p-retry@4.6.1/node_modules/p-retry/index.js"(exports2, module2) {
    "use strict";
    var retry = require_retry4();
    var networkErrorMsgs = [
      "Failed to fetch",
      "NetworkError when attempting to fetch resource.",
      "The Internet connection appears to be offline.",
      "Network request failed"
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    __name(AbortError, "AbortError");
    var decorateErrorWithCounts = /* @__PURE__ */ __name((error2, attemptNumber, options2) => {
      const retriesLeft = options2.retries - (attemptNumber - 1);
      error2.attemptNumber = attemptNumber;
      error2.retriesLeft = retriesLeft;
      return error2;
    }, "decorateErrorWithCounts");
    var isNetworkError = /* @__PURE__ */ __name((errorMessage) => networkErrorMsgs.includes(errorMessage), "isNetworkError");
    var pRetry2 = /* @__PURE__ */ __name((input, options2) => new Promise((resolve2, reject2) => {
      options2 = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options2
      };
      const operation = retry.operation(options2);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve2(await input(attemptNumber));
        } catch (error2) {
          if (!(error2 instanceof Error)) {
            reject2(new TypeError(`Non-error was thrown: "${error2}". You should only throw errors.`));
            return;
          }
          if (error2 instanceof AbortError) {
            operation.stop();
            reject2(error2.originalError);
          } else if (error2 instanceof TypeError && !isNetworkError(error2.message)) {
            operation.stop();
            reject2(error2);
          } else {
            decorateErrorWithCounts(error2, attemptNumber, options2);
            try {
              await options2.onFailedAttempt(error2);
            } catch (error3) {
              reject2(error3);
              return;
            }
            if (!operation.retry(error2)) {
              reject2(operation.mainError());
            }
          }
        }
      });
    }), "pRetry");
    module2.exports = pRetry2;
    module2.exports.default = pRetry2;
    module2.exports.AbortError = AbortError;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/http-parser.js
var require_http_parser = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/http-parser.js"(exports2, module2) {
    "use strict";
    var common = __require("_http_common");
    if (common.HTTPParser) {
      module2.exports = common.HTTPParser;
    } else {
      module2.exports = process.binding("http_parser").HTTPParser;
    }
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kIdleTimeout: Symbol("idle timeout"),
      kIdleTimeoutValue: Symbol("idle timeout value"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kTLSServerName: Symbol("server name"),
      kHost: Symbol("host"),
      kTLSOpts: Symbol("TLS Options"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol("destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelinig"),
      kSocketPath: Symbol("socket path"),
      kSocket: Symbol("socket"),
      kTLSSession: Symbol("tls session cache"),
      kHostHeader: Symbol("host header"),
      kAgentOpts: Symbol("agent opts"),
      kAgentCache: Symbol("agent cache")
    };
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    __name(UndiciError, "UndiciError");
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    __name(HeadersTimeoutError, "HeadersTimeoutError");
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    __name(BodyTimeoutError, "BodyTimeoutError");
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    __name(InvalidArgumentError, "InvalidArgumentError");
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    __name(InvalidReturnValueError, "InvalidReturnValueError");
    var RequestAbortedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestAbortedError);
        this.name = "RequestAbortedError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    __name(RequestAbortedError, "RequestAbortedError");
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    __name(InformationalError, "InformationalError");
    var ContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ContentLengthMismatchError);
        this.name = "ContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_CONTENT_LENGTH_MISMATCH";
      }
    };
    __name(ContentLengthMismatchError, "ContentLengthMismatchError");
    var TrailerMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, TrailerMismatchError);
        this.name = "TrailerMismatchError";
        this.message = message || "Trailers does not match trailer header";
        this.code = "UND_ERR_TRAILER_MISMATCH";
      }
    };
    __name(TrailerMismatchError, "TrailerMismatchError");
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    __name(ClientDestroyedError, "ClientDestroyedError");
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    __name(ClientClosedError, "ClientClosedError");
    var SocketError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
      }
    };
    __name(SocketError, "SocketError");
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    __name(NotSupportedError, "NotSupportedError");
    module2.exports = {
      UndiciError,
      HeadersTimeoutError,
      BodyTimeoutError,
      ContentLengthMismatchError,
      TrailerMismatchError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError
    };
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/util.js
var require_util4 = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = __require("assert");
    var { kDestroyed } = require_symbols();
    var { IncomingMessage } = __require("http");
    var util2 = __require("util");
    var net2 = __require("net");
    var { InvalidArgumentError } = require_errors();
    function nop() {
    }
    __name(nop, "nop");
    function isStream(body) {
      return !!(body && typeof body.on === "function");
    }
    __name(isStream, "isStream");
    function parseURL(url2) {
      if (typeof url2 === "string") {
        url2 = new URL(url2);
      }
      if (!url2 || typeof url2 !== "object") {
        throw new InvalidArgumentError("invalid url");
      }
      if (url2.port != null && url2.port !== "" && !Number.isFinite(parseInt(url2.port))) {
        throw new InvalidArgumentError("invalid port");
      }
      if (url2.hostname != null && typeof url2.hostname !== "string") {
        throw new InvalidArgumentError("invalid hostname");
      }
      if (!/https?/.test(url2.protocol)) {
        throw new InvalidArgumentError("invalid protocol");
      }
      if (!(url2 instanceof URL)) {
        const port = url2.port || {
          "http:": 80,
          "https:": 443
        }[url2.protocol];
        assert(port != null);
        const path6 = url2.path || `${url2.pathname || "/"}${url2.search || ""}`;
        url2 = new URL(`${url2.protocol}//${url2.hostname}:${port}${path6}`);
      }
      return url2;
    }
    __name(parseURL, "parseURL");
    function parseOrigin(url2) {
      url2 = parseURL(url2);
      if (/\/.+/.test(url2.pathname) || url2.search || url2.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url2;
    }
    __name(parseOrigin, "parseOrigin");
    function getServerName(host) {
      if (!host) {
        return null;
      }
      let servername = host;
      if (servername.startsWith("[")) {
        const idx = servername.indexOf("]");
        servername = idx === -1 ? servername : servername.substr(1, idx - 1);
      } else {
        servername = servername.split(":", 1)[0];
      }
      if (net2.isIP(servername)) {
        servername = null;
      }
      return servername;
    }
    __name(getServerName, "getServerName");
    function bodyLength(body) {
      if (body && typeof body.on === "function") {
        const state = body._readableState;
        return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      }
      assert(!body || Number.isFinite(body.byteLength));
      return body ? body.length : 0;
    }
    __name(bodyLength, "bodyLength");
    function isDestroyed(stream3) {
      return !stream3 || !!(stream3.destroyed || stream3[kDestroyed]);
    }
    __name(isDestroyed, "isDestroyed");
    function destroy(stream3, err) {
      if (!isStream(stream3) || isDestroyed(stream3)) {
        return;
      }
      if (typeof stream3.destroy === "function") {
        if (err || Object.getPrototypeOf(stream3).constructor !== IncomingMessage) {
          stream3.destroy(err);
        }
      } else if (err) {
        process.nextTick((stream4, err2) => {
          stream4.emit("error", err2);
        }, stream3, err);
      }
      if (stream3.destroyed !== true) {
        stream3[kDestroyed] = true;
      }
    }
    __name(destroy, "destroy");
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1]) * 1e3 : null;
    }
    __name(parseKeepAliveTimeout, "parseKeepAliveTimeout");
    function parseHeaders(headers, obj = {}) {
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toLowerCase();
        let val = obj[key];
        if (!val) {
          obj[key] = headers[i + 1];
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1]);
        }
      }
      return obj;
    }
    __name(parseHeaders, "parseHeaders");
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    __name(isBuffer, "isBuffer");
    function errnoException(code, syscall) {
      const name = util2.getSystemErrorName(code);
      const err = new Error(`${syscall} ${name}`);
      err.errno = err;
      err.code = code;
      err.syscall = syscall;
      return err;
    }
    __name(errnoException, "errnoException");
    module2.exports = {
      nop,
      parseOrigin,
      parseURL,
      getServerName,
      errnoException,
      isStream,
      isDestroyed,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      isBuffer,
      queueMicrotask: global.queueMicrotask ? global.queueMicrotask.bind(global) : (cb) => Promise.resolve().then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0))
    };
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/request.js
var require_request = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var util2 = require_util4();
    var assert = __require("assert");
    var kHandler = Symbol("handler");
    var REGEXP_ABSOLUTE_URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\x00a1-\xffff0-9]+-?)*[a-z\x00a1-\xffff0-9]+)(?:\.(?:[a-z\x00a1-\xffff0-9]+-?)*[a-z\x00a1-\xffff0-9]+)*(?:\.(?:[a-z\x00a1-\xffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/ius;
    var Request = class {
      constructor({
        path: path6,
        method,
        body,
        headers,
        idempotent,
        upgrade
      }, handler) {
        if (typeof path6 !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path6[0] !== "/" && !REGEXP_ABSOLUTE_URL.test(path6)) {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        this.method = method;
        if (body == null) {
          this.body = null;
        } else if (util2.isStream(body)) {
          this.body = body;
        } else if (util2.isBuffer(body)) {
          this.body = body.length ? body : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer or a Readable stream");
        }
        this.aborted = false;
        this.upgrade = upgrade || method === "CONNECT" || null;
        this.path = path6;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.host = null;
        this.contentLength = null;
        this.headers = "";
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i + 0], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          for (const [key, val] of Object.entries(headers)) {
            processHeader(this, key, val);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (typeof handler.onConnect !== "function") {
          throw new InvalidArgumentError("invalid onConnect method");
        }
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        if (this.upgrade) {
          if (typeof handler.onUpgrade !== "function") {
            throw new InvalidArgumentError("invalid onUpgrade method");
          }
        } else {
          if (typeof handler.onHeaders !== "function") {
            throw new InvalidArgumentError("invalid onHeaders method");
          }
          if (typeof handler.onData !== "function") {
            throw new InvalidArgumentError("invalid onData method");
          }
          if (typeof handler.onComplete !== "function") {
            throw new InvalidArgumentError("invalid onComplete method");
          }
        }
        this[kHandler] = handler;
      }
      onConnect(abort) {
        assert(!this.aborted);
        return this[kHandler].onConnect(abort);
      }
      onHeaders(statusCode, headers, resume) {
        assert(!this.aborted);
        return this[kHandler].onHeaders(statusCode, headers, resume);
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.upgrade);
        return this[kHandler].onData(chunk);
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(this.upgrade);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        assert(!this.aborted);
        assert(!this.upgrade);
        return this[kHandler].onComplete(trailers);
      }
      onError(err) {
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        util2.queueMicrotask(() => this[kHandler].onError(err));
      }
    };
    __name(Request, "Request");
    function processHeader(request4, key, val) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request4.host === null && key.length === 4 && key.toLowerCase() === "host") {
        request4.host = val;
        request4.headers += `${key}: ${val}\r
`;
      } else if (request4.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request4.contentLength = parseInt(val);
        if (!Number.isFinite(request4.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        throw new InvalidArgumentError("invalid connection header");
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else {
        request4.headers += `${key}: ${val}\r
`;
      }
    }
    __name(processHeader, "processHeader");
    module2.exports = Request;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/client.js
var require_client = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/client.js"(exports2, module2) {
    "use strict";
    var net2 = __require("net");
    var tls = __require("tls");
    var HTTPParser = require_http_parser();
    var EventEmitter4 = __require("events");
    var assert = __require("assert");
    var util2 = require_util4();
    var Request = require_request();
    var {
      ContentLengthMismatchError,
      TrailerMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      ClientDestroyedError,
      ClientClosedError,
      SocketError,
      InformationalError,
      BodyTimeoutError
    } = require_errors();
    var {
      kUrl,
      kReset,
      kHost,
      kClient,
      kParser,
      kConnect,
      kResuming,
      kWriting,
      kQueue,
      kNeedDrain,
      kTLSServerName,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kTLSOpts,
      kClosed,
      kDestroyed,
      kPendingIdx,
      kRunningIdx,
      kError,
      kOnDestroyed,
      kPipelining,
      kSocket,
      kSocketPath,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kTLSSession,
      kIdleTimeout,
      kIdleTimeoutValue,
      kHeadersTimeout,
      kBodyTimeout
    } = require_symbols();
    var nodeVersions = process.version.split(".");
    var nodeMajorVersion = parseInt(nodeVersions[0].slice(1));
    var nodeMinorVersion = parseInt(nodeVersions[1]);
    var insecureHTTPParser = process.execArgv.includes("--insecure-http-parser");
    function getServerName(client, host) {
      return util2.getServerName(host) || client[kTLSOpts] && client[kTLSOpts].servername || util2.getServerName(client[kUrl].host || client[kUrl].hostname) || null;
    }
    __name(getServerName, "getServerName");
    var Client2 = class extends EventEmitter4 {
      constructor(url2, {
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls: tls2
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || 16384;
        this[kUrl] = util2.parseOrigin(url2);
        this[kSocketPath] = socketPath;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kClosed] = false;
        this[kDestroyed] = false;
        this[kTLSOpts] = tls2;
        this[kTLSServerName] = getServerName(this);
        this[kHost] = null;
        this[kOnDestroyed] = [];
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kTLSSession] = null;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get url() {
        return this[kUrl];
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get connected() {
        return this[kSocket] && this[kSocket].connecting !== true && (this[kSocket].authorized !== false || this[kSocket].authorizationError) && !this[kSocket].destroyed;
      }
      get pending() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get running() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get size() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get busy() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting]) || this.size >= (this[kPipelining] || 1) || this.pending > 0;
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      dispatch(opts2, handler) {
        try {
          const request4 = new Request(opts2, handler);
          if (this[kDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          this[kQueue].push(request4);
          if (this[kResuming]) {
          } else if (util2.isStream(request4.body)) {
            this[kResuming] = 1;
            process.nextTick(resume, this);
          } else {
            resume(this, true);
          }
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
        }
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve2, reject2) => {
            this.close((err, data) => {
              return err ? reject2(err) : resolve2(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          process.nextTick(callback, new ClientDestroyedError(), null);
          return;
        }
        this[kClosed] = true;
        if (!this.size) {
          this.destroy(callback);
        } else {
          this[kOnDestroyed].push(callback);
        }
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve2, reject2) => {
            this.destroy(err, (err2, data) => {
              return err2 ? reject2(err2) : resolve2(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            process.nextTick(callback, null, null);
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        for (const request4 of this[kQueue].splice(this[kPendingIdx])) {
          request4.onError(err);
        }
        this[kClosed] = true;
        this[kDestroyed] = true;
        this[kOnDestroyed].push(callback);
        const onDestroyed = /* @__PURE__ */ __name(() => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (const callback2 of callbacks) {
            callback2(null, null);
          }
        }, "onDestroyed");
        if (!this[kSocket]) {
          process.nextTick(onDestroyed);
        } else {
          util2.destroy(this[kSocket].on("close", onDestroyed), err);
        }
        resume(this);
      }
    };
    __name(Client2, "Client");
    var Parser = class extends HTTPParser {
      constructor(client, socket) {
        if (nodeMajorVersion === 12 && nodeMinorVersion < 19) {
          super();
          this.initialize(HTTPParser.RESPONSE, {}, 0);
        } else if (nodeMajorVersion === 12 && nodeMinorVersion >= 19) {
          super();
          this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], 0);
        } else if (nodeMajorVersion > 12 && nodeMajorVersion < 16) {
          super();
          this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], insecureHTTPParser, 0);
        } else if (nodeMajorVersion >= 16) {
          super();
          this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], 0);
        } else {
          super(HTTPParser.RESPONSE);
        }
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.statusCode = null;
        this.upgrade = false;
        this.headers = null;
        this.shouldKeepAlive = false;
        this.request = null;
        this.paused = false;
        this.resuming = false;
        this.queue = [];
        this._resume = () => {
          if (!this.paused || this.resuming) {
            return;
          }
          this.paused = false;
          this.resuming = true;
          while (this.queue.length) {
            const [fn, ...args] = this.queue.shift();
            Reflect.apply(fn, this, args);
            if (this.paused) {
              this.resuming = false;
              return;
            }
          }
          this.resuming = false;
          socketResume(this.socket);
        };
        this._pause = () => {
          if (this.paused) {
            return;
          }
          this.paused = true;
          socketPause(this.socket);
        };
      }
      [HTTPParser.kOnHeaders](rawHeaders) {
        if (this.paused) {
          this.queue.push([this[HTTPParser.kOnHeaders], rawHeaders]);
          return;
        }
        if (this.headers) {
          Array.prototype.push.apply(this.headers, rawHeaders);
        } else {
          this.headers = rawHeaders;
        }
      }
      [HTTPParser.kOnExecute](ret) {
        if (this.paused) {
          this.queue.push([this[HTTPParser.kOnExecute], ret]);
          return;
        }
        const { upgrade, socket } = this;
        if (!Number.isFinite(ret)) {
          assert(ret instanceof Error);
          util2.destroy(socket, ret);
          return;
        }
        if (upgrade && !socket.destroyed) {
          const { client, headers, statusCode, request: request4 } = this;
          assert(!socket.destroyed);
          assert(socket === client[kSocket]);
          assert(!socket.isPaused());
          assert(socket._handle && socket._handle.reading);
          assert(request4.upgrade);
          this.headers = null;
          this.statusCode = null;
          this.request = null;
          socket._readableState.flowing = null;
          socket.unshift(this.getCurrentBuffer().slice(ret));
          try {
            request4.onUpgrade(statusCode, headers, socket);
            if (!socket.destroyed && !request4.aborted) {
              detachSocket(socket);
              client[kSocket] = null;
              client[kQueue][client[kRunningIdx]++] = null;
              client.emit("disconnect", new InformationalError("upgrade"));
            }
            resume(client);
          } catch (err) {
            util2.destroy(socket, err);
          }
        }
      }
      [HTTPParser.kOnHeadersComplete](versionMajor, versionMinor, rawHeaders, method, url2, statusCode, statusMessage, upgrade, shouldKeepAlive) {
        if (this.paused) {
          this.queue.push([
            this[HTTPParser.kOnHeadersComplete],
            versionMajor,
            versionMinor,
            rawHeaders,
            method,
            url2,
            statusCode,
            statusMessage,
            upgrade,
            shouldKeepAlive
          ]);
          return;
        }
        const { client, socket } = this;
        const request4 = client[kQueue][client[kRunningIdx]];
        if (socket.destroyed) {
          return;
        }
        clearTimeout(this.timeout);
        this.timeout = client[kBodyTimeout] ? setTimeout(onBodyTimeout, client[kBodyTimeout], this) : null;
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util2.destroy(socket, new SocketError("bad response"));
          return 1;
        }
        if (request4.upgrade !== true && upgrade !== Boolean(request4.upgrade)) {
          util2.destroy(socket, new SocketError("bad upgrade"));
          return 1;
        }
        if (this.headers) {
          Array.prototype.push.apply(this.headers, rawHeaders);
        } else {
          this.headers = rawHeaders;
        }
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive;
        this.request = request4;
        if (request4.upgrade) {
          this.unconsume();
          this.upgrade = true;
          return 2;
        }
        let keepAlive;
        let trailers;
        const { headers } = this;
        this.headers = null;
        for (let n = 0; n < headers.length; n += 2) {
          const key = headers[n + 0];
          const val = headers[n + 1];
          if (!keepAlive && key.length === 10 && key.toLowerCase() === "keep-alive") {
            keepAlive = val;
          } else if (!trailers && key.length === 7 && key.toLowerCase() === "trailer") {
            trailers = val;
          }
        }
        this.trailers = trailers ? trailers.toLowerCase().split(/,\s*/) : null;
        if (shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = keepAlive ? util2.parseKeepAliveTimeout(keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        try {
          if (request4.onHeaders(statusCode, headers, this._resume) === false) {
            this._pause();
          }
        } catch (err) {
          util2.destroy(socket, err);
          return 1;
        }
        return request4.method === "HEAD" || statusCode < 200 ? 1 : 0;
      }
      [HTTPParser.kOnBody](chunk, offset, length) {
        if (this.paused) {
          this.queue.push([this[HTTPParser.kOnBody], chunk, offset, length]);
          return;
        }
        const { socket, statusCode, request: request4, timeout } = this;
        if (socket.destroyed) {
          return;
        }
        if (timeout && timeout.refresh) {
          timeout.refresh();
        }
        assert(statusCode >= 200);
        try {
          if (request4.onData(chunk.slice(offset, offset + length)) === false) {
            this._pause();
          }
        } catch (err) {
          util2.destroy(socket, err);
        }
      }
      [HTTPParser.kOnMessageComplete]() {
        if (this.paused) {
          this.queue.push([this[HTTPParser.kOnMessageComplete]]);
          return;
        }
        const { client, socket, statusCode, headers, upgrade, request: request4, trailers } = this;
        if (socket.destroyed) {
          return;
        }
        assert(statusCode >= 100);
        assert(this.resuming || socket._handle && socket._handle.reading);
        if (upgrade) {
          assert(statusCode < 300 || request4.method === "CONNECT");
          return;
        }
        this.statusCode = null;
        this.headers = null;
        this.request = null;
        this.trailers = null;
        clearTimeout(this.timeout);
        this.timeout = client[kHeadersTimeout] ? setTimeout(onHeadersTimeout, client[kHeadersTimeout], this) : null;
        if (statusCode < 200) {
          return;
        }
        try {
          if (trailers) {
            if (!headers) {
              throw new TrailerMismatchError();
            }
            for (const trailer of trailers) {
              let found = false;
              for (let n = 0; n < headers.length; n += 2) {
                const key = headers[n + 0];
                if (key.length === trailer.length && key.toLowerCase() === trailer.toLowerCase()) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                throw new TrailerMismatchError();
              }
            }
          }
          try {
            request4.onComplete(headers);
          } catch (err) {
            request4.onError(err);
          }
        } catch (err) {
          util2.destroy(socket, err);
          return;
        }
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          util2.destroy(socket, new InformationalError("reset"));
        } else if (!this.shouldKeepAlive) {
          util2.destroy(socket, new InformationalError("reset"));
        } else if (socket[kReset] && !client.running) {
          util2.destroy(socket, new InformationalError("reset"));
        } else {
          resume(client);
        }
      }
      destroy() {
        clearTimeout(this.timeout);
        this.timeout = null;
        this.unconsume();
        setImmediate((self2) => self2.close(), this);
      }
    };
    __name(Parser, "Parser");
    function onBodyTimeout(self2) {
      if (!self2.paused) {
        util2.destroy(self2.socket, new BodyTimeoutError());
      }
    }
    __name(onBodyTimeout, "onBodyTimeout");
    function onHeadersTimeout(self2) {
      util2.destroy(self2.socket, new HeadersTimeoutError());
    }
    __name(onHeadersTimeout, "onHeadersTimeout");
    function onSocketConnect() {
      const { [kClient]: client } = this;
      client.emit("connect");
      resume(client);
    }
    __name(onSocketConnect, "onSocketConnect");
    function onSocketError(err) {
      const { [kClient]: client } = this;
      this[kError] = err;
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(!client.running);
        while (client.pending && client[kQueue][client[kPendingIdx]].host === client[kHost]) {
          client[kQueue][client[kPendingIdx]++].onError(err);
        }
      } else if (!client.running && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        for (const request4 of client[kQueue].splice(client[kRunningIdx])) {
          request4.onError(err);
        }
      }
    }
    __name(onSocketError, "onSocketError");
    function onSocketEnd() {
      util2.destroy(this, new SocketError("other side closed"));
    }
    __name(onSocketEnd, "onSocketEnd");
    function detachSocket(socket) {
      clearTimeout(socket[kIdleTimeout]);
      socket[kIdleTimeout] = null;
      socket[kIdleTimeoutValue] = null;
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      socket.removeListener("session", onSocketSession).removeListener("error", onSocketError).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
    }
    __name(detachSocket, "detachSocket");
    function onSocketClose() {
      const { [kClient]: client } = this;
      const err = this[kError] || new SocketError("closed");
      detachSocket(this);
      client[kSocket] = null;
      if (err.code !== "UND_ERR_INFO") {
        client[kTLSSession] = null;
      }
      if (client[kDestroyed]) {
        assert(!client.pending);
        for (const request4 of client[kQueue].splice(client[kRunningIdx])) {
          request4.onError(err);
        }
        client[kPendingIdx] = client[kRunningIdx];
      } else {
        if (client.running && err.code !== "UND_ERR_INFO") {
          client[kQueue][client[kRunningIdx]].onError(err);
          client[kQueue][client[kRunningIdx]++] = null;
        }
        client[kPendingIdx] = client[kRunningIdx];
        client.emit("disconnect", err);
      }
      resume(client);
    }
    __name(onSocketClose, "onSocketClose");
    function onSocketSession(session) {
      const { [kClient]: client } = this;
      client[kTLSSession] = session;
    }
    __name(onSocketSession, "onSocketSession");
    function connect(client) {
      assert(!client[kSocket]);
      const { protocol, port, hostname } = client[kUrl];
      let socket;
      if (protocol === "https:") {
        const tlsOpts = {
          ...client[kTLSOpts],
          servername: client[kTLSServerName],
          session: client[kTLSSession]
        };
        socket = client[kSocketPath] ? tls.connect(client[kSocketPath], tlsOpts) : tls.connect(port || 443, hostname, tlsOpts);
        socket.on("session", onSocketSession);
      } else {
        socket = client[kSocketPath] ? net2.connect(client[kSocketPath]) : net2.connect(port || 80, hostname);
      }
      client[kSocket] = socket;
      const parser = new Parser(client, socket);
      if (nodeMajorVersion >= 12) {
        assert(socket._handle);
        parser.consume(socket._handle);
      } else {
        assert(socket._handle && socket._handle._externalStream);
        parser.consume(socket._handle._externalStream);
      }
      socket[kIdleTimeout] = null;
      socket[kIdleTimeoutValue] = null;
      socket[kWriting] = false;
      socket[kReset] = false;
      socket[kError] = null;
      socket[kParser] = parser;
      socket[kClient] = client;
      socket.setNoDelay(true).on(protocol === "https:" ? "secureConnect" : "connect", onSocketConnect).on("error", onSocketError).on("end", onSocketEnd).on("close", onSocketClose);
    }
    __name(connect, "connect");
    function socketPause(socket) {
      if (socket._handle && socket._handle.reading) {
        socket._handle.reading = false;
        const err = socket._handle.readStop();
        if (err) {
          socket.destroy(util2.errnoException(err, "read"));
        }
      }
    }
    __name(socketPause, "socketPause");
    function socketResume(socket) {
      if (socket._handle && !socket._handle.reading) {
        socket._handle.reading = true;
        const err = socket._handle.readStart();
        if (err) {
          socket.destroy(util2.errnoException(err, "read"));
        }
      }
    }
    __name(socketResume, "socketResume");
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain");
    }
    __name(emitDrain, "emitDrain");
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    __name(resume, "resume");
    function _resume(client, sync) {
      while (true) {
        if (client[kDestroyed]) {
          assert(!client.pending);
          return;
        }
        if (client[kClosed] && !client.size) {
          client.destroy(util2.nop);
          continue;
        }
        if (client[kSocket]) {
          const socket2 = client[kSocket];
          const timeout = client.running ? 0 : client[kKeepAliveTimeoutValue];
          if (socket2[kIdleTimeoutValue] !== timeout) {
            clearTimeout(socket2[kIdleTimeout]);
            if (timeout) {
              socket2[kIdleTimeout] = setTimeout((socket3) => {
                util2.destroy(socket3, new InformationalError("socket idle timeout"));
              }, timeout, socket2);
            }
            socket2[kIdleTimeoutValue] = timeout;
          }
        }
        if (client.running) {
          const { aborted } = client[kQueue][client[kRunningIdx]];
          if (aborted) {
            util2.destroy(client[kSocket]);
            return;
          }
        }
        if (client.busy) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (!client.pending) {
          return;
        }
        if (client.running >= (client[kPipelining] || 1)) {
          return;
        }
        const socket = client[kSocket];
        const request4 = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kHost] !== request4.host) {
          if (client.running) {
            return;
          }
          client[kHost] = request4.host;
          const servername = getServerName(client, request4.host);
          if (client[kTLSServerName] !== servername) {
            client[kTLSServerName] = servername;
            client[kTLSSession] = null;
            if (socket) {
              util2.destroy(socket, new InformationalError("servername changed"));
              return;
            }
          }
        }
        if (!socket) {
          connect(client);
          return;
        }
        if (!client.connected) {
          return;
        }
        if (socket[kWriting] || socket[kReset]) {
          return;
        }
        if (client.running && !request4.idempotent) {
          return;
        }
        if (client.running && request4.upgrade) {
          return;
        }
        if (util2.isStream(request4.body) && util2.bodyLength(request4.body) === 0) {
          request4.body.on("data", function() {
            assert(false);
          }).on("error", function(err) {
            request4.onError(err);
          }).on("end", function() {
            util2.destroy(this);
          });
          request4.body = null;
        }
        if (client.running && util2.isStream(request4.body)) {
          return;
        }
        if (!request4.aborted && write(client, request4)) {
          const parser = client[kSocket][kParser];
          if (!parser.timeout && client[kHeadersTimeout]) {
            parser.timeout = setTimeout(onHeadersTimeout, client[kHeadersTimeout], parser);
          }
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    __name(_resume, "_resume");
    function write(client, request4) {
      const { body, method, path: path6, host, upgrade, headers } = request4;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util2.bodyLength(body);
      if (contentLength === null) {
        contentLength = request4.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (request4.contentLength !== null && request4.contentLength !== contentLength) {
        request4.onError(new ContentLengthMismatchError());
        return false;
      }
      if (request4.aborted) {
        return false;
      }
      try {
        request4.onConnect((err) => {
          if (request4.aborted) {
            return;
          }
          request4.onError(err || new RequestAbortedError());
          if (client[kResuming] === 0) {
            resume(client, true);
          }
        });
      } catch (err) {
        request4.onError(err);
      }
      if (request4.aborted) {
        return false;
      }
      const socket = client[kSocket];
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade) {
        socket[kReset] = true;
      }
      let header;
      if (typeof upgrade === "string") {
        header = `${method} ${path6} HTTP/1.1\r
connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining]) {
        header = `${method} ${path6} HTTP/1.1\r
connection: keep-alive\r
`;
      } else {
        header = `${method} ${path6} HTTP/1.1\r
connection: close\r
`;
      }
      if (!host) {
        header += client[kHostHeader];
      }
      if (headers) {
        header += headers;
      }
      if (!body) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: ${contentLength}\r
\r
\r
`, "ascii");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "ascii");
        }
      } else if (util2.isBuffer(body)) {
        assert(contentLength !== null, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
        socket.write(body);
        socket.write("\r\n", "ascii");
        socket.uncork();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else {
        socket[kWriting] = true;
        assert(util2.isStream(body));
        assert(contentLength !== 0 || !client.running, "stream body cannot be pipelined");
        let finished = false;
        let bytesWritten = 0;
        const onData = /* @__PURE__ */ __name(function(chunk) {
          try {
            assert(!finished);
            const len = Buffer.byteLength(chunk);
            if (!len) {
              return;
            }
            if (contentLength !== null && bytesWritten + len > contentLength) {
              util2.destroy(socket, new ContentLengthMismatchError());
              return;
            }
            if (bytesWritten === 0) {
              if (!expectsPayload) {
                socket[kReset] = true;
              }
              if (contentLength === null) {
                socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
              } else {
                socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
              }
            }
            if (contentLength === null) {
              socket.write(`\r
${len.toString(16)}\r
`, "ascii");
            }
            bytesWritten += len;
            if (!socket.write(chunk) && this.pause) {
              this.pause();
            }
          } catch (err) {
            util2.destroy(this, err);
          }
        }, "onData");
        const onDrain = /* @__PURE__ */ __name(function() {
          assert(!finished);
          if (body.resume) {
            body.resume();
          }
        }, "onDrain");
        const onAbort = /* @__PURE__ */ __name(function() {
          onFinished(new RequestAbortedError());
        }, "onAbort");
        const onFinished = /* @__PURE__ */ __name(function(err) {
          if (finished) {
            return;
          }
          finished = true;
          assert(socket.destroyed || socket[kWriting] && client.running <= 1);
          socket[kWriting] = false;
          if (!err && contentLength !== null && bytesWritten !== contentLength) {
            err = new ContentLengthMismatchError();
          }
          socket.removeListener("drain", onDrain).removeListener("error", onFinished);
          body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
          util2.destroy(body, err);
          if (err) {
            assert(client.running <= 1, "pipeline should only contain this request");
            util2.destroy(socket, err);
          }
          if (socket.destroyed) {
            return;
          }
          if (bytesWritten === 0) {
            if (expectsPayload) {
              socket.write(`${header}content-length: 0\r
\r
\r
`, "ascii");
            } else {
              socket.write(`${header}\r
`, "ascii");
            }
          } else if (contentLength === null) {
            socket.write("\r\n0\r\n\r\n", "ascii");
          }
          resume(client);
        }, "onFinished");
        body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
        socket.on("drain", onDrain).on("error", onFinished);
      }
      return true;
    }
    __name(write, "write");
    module2.exports = Client2;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    __name(FixedCircularBuffer, "FixedCircularBuffer");
    module2.exports = /* @__PURE__ */ __name(class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    }, "FixedQueue");
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/abort-signal.js
var require_abort_signal = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/abort-signal.js"(exports2, module2) {
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    __name(abort, "abort");
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      if ("addEventListener" in self2[kSignal]) {
        self2[kSignal].addEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].addListener("abort", self2[kListener]);
      }
    }
    __name(addSignal, "addSignal");
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    __name(removeSignal, "removeSignal");
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-request.js
var require_client_request = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-request.js"(exports2, module2) {
    "use strict";
    var { Readable } = __require("stream");
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util2 = require_util4();
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var kAbort = Symbol("abort");
    var RequestResponse = class extends Readable {
      constructor(resume, abort) {
        super({ autoDestroy: true, read: resume });
        this[kAbort] = abort;
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        callback(err);
      }
    };
    __name(RequestResponse, "RequestResponse");
    var RequestHandler2 = class extends AsyncResource2 {
      constructor(opts2, callback) {
        if (!opts2 || typeof opts2 !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body } = opts2;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util2.isStream(body)) {
            util2.destroy(body.on("error", util2.nop), err);
          }
          throw err;
        }
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        if (util2.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
      }
      onHeaders(statusCode, headers, resume) {
        const { callback, opaque, abort } = this;
        if (statusCode < 200) {
          return;
        }
        const body = new RequestResponse(resume, abort);
        this.callback = null;
        this.res = body;
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers: util2.parseHeaders(headers),
          trailers: this.trailers,
          opaque,
          body
        });
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (trailers) {
          util2.parseHeaders(trailers, this.trailers);
        }
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          process.nextTick((self2, callback2, err2, opaque2) => {
            self2.runInAsyncScope(callback2, null, err2, { opaque: opaque2 });
          }, this, callback, err, opaque);
        }
        if (res) {
          this.res = null;
          util2.destroy(res, err);
        }
        if (body) {
          this.body = null;
          util2.destroy(body, err);
        }
      }
    };
    __name(RequestHandler2, "RequestHandler");
    function request4(opts2, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject2) => {
          request4.call(this, opts2, (err, data) => {
            return err ? reject2(err) : resolve2(data);
          });
        });
      }
      try {
        this.dispatch(opts2, new RequestHandler2(opts2, callback));
      } catch (err) {
        if (typeof callback === "function") {
          process.nextTick(callback, err, { opaque: opts2 && opts2.opaque });
        } else {
          throw err;
        }
      }
    }
    __name(request4, "request");
    module2.exports = request4;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-stream.js
var require_client_stream = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-stream.js"(exports2, module2) {
    "use strict";
    var { finished } = __require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util2 = require_util4();
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource2 {
      constructor(opts2, factory, callback) {
        if (!opts2 || typeof opts2 !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body } = opts2;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util2.isStream(body)) {
            util2.destroy(body.on("error", util2.nop), err);
          }
          throw err;
        }
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.trailers = null;
        this.body = body;
        if (util2.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
      }
      onHeaders(statusCode, headers, resume) {
        const { factory, opaque } = this;
        if (statusCode < 200) {
          return;
        }
        this.factory = null;
        const res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers: util2.parseHeaders(headers),
          opaque
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        res.on("drain", resume);
        finished(res, { readable: false }, (err) => {
          const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util2.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res.write(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        this.trailers = trailers ? util2.parseHeaders(trailers) : {};
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util2.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          process.nextTick((self2, callback2, err2, opaque2) => {
            self2.runInAsyncScope(callback2, null, err2, { opaque: opaque2 });
          }, this, callback, err, opaque);
        }
        if (body) {
          this.body = null;
          util2.destroy(body, err);
        }
      }
    };
    __name(StreamHandler, "StreamHandler");
    function stream3(opts2, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject2) => {
          stream3.call(this, opts2, factory, (err, data) => {
            return err ? reject2(err) : resolve2(data);
          });
        });
      }
      try {
        this.dispatch(opts2, new StreamHandler(opts2, factory, callback));
      } catch (err) {
        if (typeof callback === "function") {
          process.nextTick(callback, err, { opaque: opts2 && opts2.opaque });
        } else {
          throw err;
        }
      }
    }
    __name(stream3, "stream");
    module2.exports = stream3;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-pipeline.js
var require_client_pipeline = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = __require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util2 = require_util4();
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var { assert } = __require("console");
    var { addSignal, removeSignal } = require_abort_signal();
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        assert(err || this._readableState.endEmitted);
        callback(err);
      }
    };
    __name(PipelineRequest, "PipelineRequest");
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    __name(PipelineResponse, "PipelineResponse");
    var PipelineHandler = class extends AsyncResource2 {
      constructor(opts2, handler) {
        if (!opts2 || typeof opts2 !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque } = opts2;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.handler = handler;
        this.abort = null;
        this.req = new PipelineRequest().on("error", util2.nop);
        this.ret = new Duplex({
          readableObjectMode: opts2.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util2.destroy(body, err);
            util2.destroy(req, err);
            util2.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort) {
        const { ret } = this;
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
      }
      onHeaders(statusCode, headers, resume) {
        const { opaque, handler } = this;
        if (statusCode < 200) {
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers: util2.parseHeaders(headers),
            opaque,
            body: this.res
          });
        } catch (err) {
          this.res.on("error", util2.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util2.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util2.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util2.destroy(ret, err);
      }
    };
    __name(PipelineHandler, "PipelineHandler");
    function pipeline2(opts2, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts2, handler);
        const {
          path: path6,
          method,
          headers,
          idempotent,
          signal
        } = opts2;
        this.dispatch({
          path: path6,
          method,
          body: pipelineHandler.req,
          headers,
          idempotent,
          signal
        }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    __name(pipeline2, "pipeline");
    module2.exports = pipeline2;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-upgrade.js
var require_client_upgrade = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var util2 = require_util4();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = __require("assert");
    var UpgradeHandler = class extends AsyncResource2 {
      constructor(opts2, callback) {
        if (!opts2 || typeof opts2 !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, opaque } = opts2;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
      }
      onUpgrade(statusCode, headers, socket) {
        const { callback, opaque } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        this.runInAsyncScope(callback, null, null, {
          headers: util2.parseHeaders(headers),
          socket,
          opaque
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          process.nextTick((self2, callback2, err2, opaque2) => {
            self2.runInAsyncScope(callback2, null, err2, { opaque: opaque2 });
          }, this, callback, err, opaque);
        }
      }
    };
    __name(UpgradeHandler, "UpgradeHandler");
    function upgrade(opts2, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject2) => {
          upgrade.call(this, opts2, (err, data) => {
            return err ? reject2(err) : resolve2(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts2, callback);
        const {
          path: path6,
          method,
          headers,
          signal,
          protocol
        } = opts2;
        this.dispatch({
          path: path6,
          method: method || "GET",
          headers,
          signal,
          upgrade: protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        process.nextTick(callback, err, { opaque: opts2 && opts2.opaque });
      }
    }
    __name(upgrade, "upgrade");
    module2.exports = upgrade;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-connect.js
var require_client_connect = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-connect.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var util2 = require_util4();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource2 {
      constructor(opts2, callback) {
        if (!opts2 || typeof opts2 !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, opaque } = opts2;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
      }
      onUpgrade(statusCode, headers, socket) {
        const { callback, opaque } = this;
        removeSignal(this);
        this.callback = null;
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers: util2.parseHeaders(headers),
          socket,
          opaque
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          process.nextTick((self2, callback2, err2, opaque2) => {
            self2.runInAsyncScope(callback2, null, err2, { opaque: opaque2 });
          }, this, callback, err, opaque);
        }
      }
    };
    __name(ConnectHandler, "ConnectHandler");
    function connect(opts2, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject2) => {
          connect.call(this, opts2, (err, data) => {
            return err ? reject2(err) : resolve2(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      try {
        const connectHandler = new ConnectHandler(opts2, callback);
        const {
          path: path6,
          headers,
          signal
        } = opts2;
        this.dispatch({
          path: path6,
          method: "CONNECT",
          headers,
          signal
        }, connectHandler);
      } catch (err) {
        process.nextTick(callback, err, { opaque: opts2 && opts2.opaque });
      }
    }
    __name(connect, "connect");
    module2.exports = connect;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/pool.js
var require_pool = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var EventEmitter4 = __require("events");
    var Client2 = require_client();
    var {
      ClientClosedError,
      InvalidArgumentError,
      ClientDestroyedError
    } = require_errors();
    var FixedQueue = require_fixed_queue();
    var util2 = require_util4();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kDestroyed = Symbol("destroyed");
    var kClosedPromise = Symbol("closed promise");
    var kClosedResolve = Symbol("closed resolve");
    var kOptions = Symbol("options");
    var kUrl = Symbol("url");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kPending = Symbol("pending");
    var kConnected = Symbol("connected");
    var kConnections = Symbol("connections");
    var Pool2 = class extends EventEmitter4 {
      constructor(origin, { connections, ...options2 } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        this[kConnections] = connections || null;
        this[kUrl] = util2.parseOrigin(origin);
        this[kOptions] = JSON.parse(JSON.stringify(options2));
        this[kQueue] = new FixedQueue();
        this[kClosedPromise] = null;
        this[kClosedResolve] = null;
        this[kDestroyed] = false;
        this[kClients] = [];
        this[kNeedDrain] = false;
        this[kPending] = 0;
        this[kConnected] = 0;
        const pool = this;
        this[kOnDrain] = /* @__PURE__ */ __name(function onDrain() {
          const queue = pool[kQueue];
          while (!this.busy) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kPending]--;
            this.dispatch(item.opts, item.handler);
          }
          if (pool[kNeedDrain] && !this.busy) {
            pool[kNeedDrain] = false;
            pool.emit("drain");
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        }, "onDrain");
        this[kOnConnect] = /* @__PURE__ */ __name(function onConnect() {
          pool[kConnected]++;
          pool.emit("connect", this);
        }, "onConnect");
        this[kOnDisconnect] = /* @__PURE__ */ __name(function onDisconnect(err) {
          pool[kConnected]--;
          pool.emit("disconnect", this, err);
        }, "onDisconnect");
      }
      get url() {
        return this[kUrl];
      }
      get connected() {
        return this[kConnected];
      }
      get busy() {
        if (this[kPending] > 0) {
          return true;
        }
        if (this[kConnections] && this[kClients].length === this[kConnections]) {
          for (const { busy } of this[kClients]) {
            if (!busy) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      get pending() {
        let ret = this[kPending];
        for (const { pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get running() {
        let ret = 0;
        for (const { running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get size() {
        let ret = this[kPending];
        for (const { size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosedPromise] != null;
      }
      dispatch(opts2, handler) {
        try {
          if (this[kDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosedPromise]) {
            throw new ClientClosedError();
          }
          let client = this[kClients].find((client2) => !client2.busy);
          if (!client) {
            if (!this[kConnections] || this[kClients].length < this[kConnections]) {
              client = new Client2(this[kUrl], this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]);
              this[kClients].push(client);
            }
          }
          if (!client) {
            this[kNeedDrain] = true;
            this[kQueue].push({ opts: opts2, handler });
            this[kPending]++;
          } else {
            client.dispatch(opts2, handler);
            if (client.busy && this.busy) {
              this[kNeedDrain] = true;
            }
          }
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
        }
      }
      close(cb) {
        try {
          if (this[kDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (!this[kClosedPromise]) {
            if (this[kQueue].isEmpty()) {
              this[kClosedPromise] = Promise.all(this[kClients].map((c) => c.close()));
            } else {
              this[kClosedPromise] = new Promise((resolve2) => {
                this[kClosedResolve] = resolve2;
              });
            }
            this[kClosedPromise] = this[kClosedPromise].then(() => {
              this[kDestroyed] = true;
            });
          }
          if (cb) {
            this[kClosedPromise].then(() => cb(null, null));
          } else {
            return this[kClosedPromise];
          }
        } catch (err) {
          if (cb) {
            cb(err);
          } else {
            return Promise.reject(err);
          }
        }
      }
      destroy(err, cb) {
        this[kDestroyed] = true;
        if (typeof err === "function") {
          cb = err;
          err = null;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        const promise = Promise.all(this[kClients].map((c) => c.destroy(err)));
        if (cb) {
          promise.then(() => cb(null, null));
        } else {
          return promise;
        }
      }
    };
    __name(Pool2, "Pool");
    Pool2.prototype.request = require_client_request();
    Pool2.prototype.stream = require_client_stream();
    Pool2.prototype.pipeline = require_client_pipeline();
    Pool2.prototype.upgrade = require_client_upgrade();
    Pool2.prototype.connect = require_client_connect();
    module2.exports = Pool2;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/agent.js
var require_agent3 = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, InvalidReturnValueError } = require_errors();
    var Pool2 = require_pool();
    var util2 = require_util4();
    var { kAgentOpts, kAgentCache } = require_symbols();
    var Agent2 = class {
      constructor(opts2) {
        this[kAgentOpts] = opts2;
        this[kAgentCache] = new Map();
      }
      get(origin) {
        if (typeof origin !== "string" || origin === "") {
          throw new InvalidArgumentError("Origin must be a non-empty string.");
        }
        const self2 = this;
        let pool = self2[kAgentCache].get(origin);
        function onDisconnect() {
          if (this.connected === 0 && this.size === 0) {
            this.off("disconnect", onDisconnect);
            self2[kAgentCache].delete(origin);
          }
        }
        __name(onDisconnect, "onDisconnect");
        if (!pool) {
          pool = new Pool2(origin, self2[kAgentOpts]);
          pool.on("disconnect", onDisconnect);
          self2[kAgentCache].set(origin, pool);
        }
        return pool;
      }
      close() {
        const closePromises = [];
        for (const pool of this[kAgentCache].values()) {
          closePromises.push(pool.close());
        }
        return Promise.all(closePromises);
      }
      destroy() {
        const destroyPromises = [];
        for (const pool of this[kAgentCache].values()) {
          destroyPromises.push(pool.destroy());
        }
        return Promise.all(destroyPromises);
      }
    };
    __name(Agent2, "Agent");
    var globalAgent = new Agent2({ connections: null });
    function setGlobalAgent2(agent) {
      if (!agent || typeof agent.get !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      globalAgent = agent;
    }
    __name(setGlobalAgent2, "setGlobalAgent");
    function dispatchFromAgent(requestType) {
      return (url2, { agent = globalAgent, method = "GET", ...opts2 } = {}, ...additionalArgs) => {
        if (opts2.path != null) {
          throw new InvalidArgumentError("unsupported opts.path");
        }
        const { origin, pathname, search } = util2.parseURL(url2);
        const path6 = `${pathname || "/"}${search || ""}`;
        const client = agent.get(origin);
        if (client && typeof client[requestType] !== "function") {
          throw new InvalidReturnValueError(`Client returned from Agent.get() does not implement method ${requestType}`);
        }
        return client[requestType]({ ...opts2, method, path: path6 }, ...additionalArgs);
      };
    }
    __name(dispatchFromAgent, "dispatchFromAgent");
    module2.exports = {
      request: dispatchFromAgent("request"),
      stream: dispatchFromAgent("stream"),
      pipeline: dispatchFromAgent("pipeline"),
      connect: dispatchFromAgent("connect"),
      upgrade: dispatchFromAgent("upgrade"),
      setGlobalAgent: setGlobalAgent2,
      Agent: Agent2
    };
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/index.js
var require_undici = __commonJS2({
  "../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client2 = require_client();
    var errors2 = require_errors();
    var Pool2 = require_pool();
    var { Agent: Agent2, request: request4, stream: stream3, pipeline: pipeline2, setGlobalAgent: setGlobalAgent2 } = require_agent3();
    Client2.prototype.request = require_client_request();
    Client2.prototype.stream = require_client_stream();
    Client2.prototype.pipeline = require_client_pipeline();
    Client2.prototype.upgrade = require_client_upgrade();
    Client2.prototype.connect = require_client_connect();
    function undici2(url2, opts2) {
      return new Pool2(url2, opts2);
    }
    __name(undici2, "undici");
    undici2.Pool = Pool2;
    undici2.Client = Client2;
    undici2.errors = errors2;
    undici2.Agent = Agent2;
    undici2.request = request4;
    undici2.stream = stream3;
    undici2.pipeline = pipeline2;
    undici2.setGlobalAgent = setGlobalAgent2;
    module2.exports = undici2;
  }
});

// ../../node_modules/.pnpm/arg@5.0.1/node_modules/arg/index.js
var require_arg = __commonJS2({
  "../../node_modules/.pnpm/arg@5.0.1/node_modules/arg/index.js"(exports2, module2) {
    var flagSymbol = Symbol("arg flag");
    var ArgError = class extends Error {
      constructor(msg, code) {
        super(msg);
        this.name = "ArgError";
        this.code = code;
        Object.setPrototypeOf(this, ArgError.prototype);
      }
    };
    __name(ArgError, "ArgError");
    function arg2(opts2, {
      argv = process.argv.slice(2),
      permissive = false,
      stopAtPositional = false
    } = {}) {
      if (!opts2) {
        throw new ArgError("argument specification object is required", "ARG_CONFIG_NO_SPEC");
      }
      const result = { _: [] };
      const aliases = {};
      const handlers = {};
      for (const key of Object.keys(opts2)) {
        if (!key) {
          throw new ArgError("argument key cannot be an empty string", "ARG_CONFIG_EMPTY_KEY");
        }
        if (key[0] !== "-") {
          throw new ArgError(`argument key must start with '-' but found: '${key}'`, "ARG_CONFIG_NONOPT_KEY");
        }
        if (key.length === 1) {
          throw new ArgError(`argument key must have a name; singular '-' keys are not allowed: ${key}`, "ARG_CONFIG_NONAME_KEY");
        }
        if (typeof opts2[key] === "string") {
          aliases[key] = opts2[key];
          continue;
        }
        let type = opts2[key];
        let isFlag = false;
        if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
          const [fn] = type;
          type = /* @__PURE__ */ __name((value, name, prev = []) => {
            prev.push(fn(value, name, prev[prev.length - 1]));
            return prev;
          }, "type");
          isFlag = fn === Boolean || fn[flagSymbol] === true;
        } else if (typeof type === "function") {
          isFlag = type === Boolean || type[flagSymbol] === true;
        } else {
          throw new ArgError(`type missing or not a function or valid array type: ${key}`, "ARG_CONFIG_VAD_TYPE");
        }
        if (key[1] !== "-" && key.length > 2) {
          throw new ArgError(`short argument keys (with a single hyphen) must have only one character: ${key}`, "ARG_CONFIG_SHORTOPT_TOOLONG");
        }
        handlers[key] = [type, isFlag];
      }
      for (let i = 0, len = argv.length; i < len; i++) {
        const wholeArg = argv[i];
        if (stopAtPositional && result._.length > 0) {
          result._ = result._.concat(argv.slice(i));
          break;
        }
        if (wholeArg === "--") {
          result._ = result._.concat(argv.slice(i + 1));
          break;
        }
        if (wholeArg.length > 1 && wholeArg[0] === "-") {
          const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
          for (let j = 0; j < separatedArguments.length; j++) {
            const arg3 = separatedArguments[j];
            const [originalArgName, argStr] = arg3[1] === "-" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];
            let argName = originalArgName;
            while (argName in aliases) {
              argName = aliases[argName];
            }
            if (!(argName in handlers)) {
              if (permissive) {
                result._.push(arg3);
                continue;
              } else {
                throw new ArgError(`unknown or unexpected option: ${originalArgName}`, "ARG_UNKNOWN_OPTION");
              }
            }
            const [type, isFlag] = handlers[argName];
            if (!isFlag && j + 1 < separatedArguments.length) {
              throw new ArgError(`option requires argument (but was followed by another short argument): ${originalArgName}`, "ARG_MISSING_REQUIRED_SHORTARG");
            }
            if (isFlag) {
              result[argName] = type(true, argName, result[argName]);
            } else if (argStr === void 0) {
              if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || typeof BigInt !== "undefined" && type === BigInt))) {
                const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
                throw new ArgError(`option requires argument: ${originalArgName}${extended}`, "ARG_MISSING_REQUIRED_LONGARG");
              }
              result[argName] = type(argv[i + 1], argName, result[argName]);
              ++i;
            } else {
              result[argName] = type(argStr, argName, result[argName]);
            }
          }
        } else {
          result._.push(wholeArg);
        }
      }
      return result;
    }
    __name(arg2, "arg");
    arg2.flag = (fn) => {
      fn[flagSymbol] = true;
      return fn;
    };
    arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);
    arg2.ArgError = ArgError;
    module2.exports = arg2;
  }
});

// ../../node_modules/.pnpm/dotenv@10.0.0/node_modules/dotenv/lib/main.js
var require_main3 = __commonJS2({
  "../../node_modules/.pnpm/dotenv@10.0.0/node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs7 = __require("fs");
    var path6 = __require("path");
    var os2 = __require("os");
    function log4(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    __name(log4, "log");
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\r\n|\n|\r/;
    function parse2(src, options2) {
      const debug10 = Boolean(options2 && options2.debug);
      const obj = {};
      src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
        const keyValueArr = line.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key = keyValueArr[1];
          let val = keyValueArr[2] || "";
          const end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key] = val;
        } else if (debug10) {
          log4(`did not match key and value when parsing line ${idx + 1}: ${line}`);
        }
      });
      return obj;
    }
    __name(parse2, "parse");
    function resolveHome(envPath) {
      return envPath[0] === "~" ? path6.join(os2.homedir(), envPath.slice(1)) : envPath;
    }
    __name(resolveHome, "resolveHome");
    function config2(options2) {
      let dotenvPath = path6.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let debug10 = false;
      if (options2) {
        if (options2.path != null) {
          dotenvPath = resolveHome(options2.path);
        }
        if (options2.encoding != null) {
          encoding = options2.encoding;
        }
        if (options2.debug != null) {
          debug10 = true;
        }
      }
      try {
        const parsed = parse2(fs7.readFileSync(dotenvPath, { encoding }), { debug: debug10 });
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else if (debug10) {
            log4(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
          }
        });
        return { parsed };
      } catch (e) {
        return { error: e };
      }
    }
    __name(config2, "config");
    module2.exports.config = config2;
    module2.exports.parse = parse2;
  }
});

// ../../node_modules/.pnpm/sql-template-tag@4.0.0/node_modules/sql-template-tag/dist/index.js
var require_dist10 = __commonJS2({
  "../../node_modules/.pnpm/sql-template-tag@4.0.0/node_modules/sql-template-tag/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sqltag = exports2.empty = exports2.raw = exports2.join = exports2.Sql = void 0;
    var util_12 = __require("util");
    var Sql2 = class {
      constructor(rawStrings, rawValues) {
        let valuesLength = rawValues.length;
        let stringsLength = rawStrings.length;
        if (stringsLength === 0) {
          throw new TypeError("Expected at least 1 string");
        }
        if (stringsLength - 1 !== valuesLength) {
          throw new TypeError(`Expected ${stringsLength} strings to have ${stringsLength - 1} values`);
        }
        for (const child of rawValues) {
          if (child instanceof Sql2) {
            valuesLength += child.values.length - 1;
            stringsLength += child.strings.length - 2;
          }
        }
        this.values = new Array(valuesLength);
        this.strings = new Array(stringsLength);
        this.strings[0] = rawStrings[0];
        let index = 1;
        let position = 0;
        while (index < rawStrings.length) {
          const child = rawValues[index - 1];
          const rawString = rawStrings[index++];
          if (child instanceof Sql2) {
            this.strings[position] += child.strings[0];
            let childIndex = 0;
            while (childIndex < child.values.length) {
              this.values[position++] = child.values[childIndex++];
              this.strings[position] = child.strings[childIndex];
            }
            this.strings[position] += rawString;
          } else {
            this.values[position++] = child;
            this.strings[position] = rawString;
          }
        }
      }
      get text() {
        return this.strings.reduce((text, part, index) => `${text}$${index}${part}`);
      }
      get sql() {
        return this.strings.join("?");
      }
      [util_12.inspect.custom]() {
        return {
          text: this.text,
          sql: this.sql,
          values: this.values
        };
      }
    };
    __name(Sql2, "Sql");
    exports2.Sql = Sql2;
    Object.defineProperty(Sql2.prototype, "sql", { enumerable: true });
    Object.defineProperty(Sql2.prototype, "text", { enumerable: true });
    function join2(values, separator = ",") {
      if (values.length === 0) {
        throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      }
      return new Sql2(["", ...Array(values.length - 1).fill(separator), ""], values);
    }
    __name(join2, "join");
    exports2.join = join2;
    function raw2(value) {
      return new Sql2([value], []);
    }
    __name(raw2, "raw");
    exports2.raw = raw2;
    exports2.empty = raw2("");
    function sqltag3(strings, ...values) {
      return new Sql2(strings, values);
    }
    __name(sqltag3, "sqltag");
    exports2.sqltag = sqltag3;
    exports2.default = sqltag3;
  }
});

// package.json
var require_package2 = __commonJS2({
  "package.json"(exports2, module2) {
    module2.exports = {
      name: "@prisma/client",
      version: "3.6.0",
      description: "Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.",
      keywords: [
        "orm",
        "prisma2",
        "prisma",
        "client",
        "query",
        "database",
        "sql",
        "postgres",
        "postgresql",
        "mysql",
        "sqlite",
        "mariadb",
        "mssql",
        "typescript",
        "query-builder"
      ],
      main: "index.js",
      browser: "index-browser.js",
      types: "index.d.ts",
      license: "Apache-2.0",
      engines: {
        node: ">=12.6"
      },
      homepage: "https://www.prisma.io",
      repository: {
        type: "git",
        url: "https://github.com/prisma/prisma.git",
        directory: "packages/client"
      },
      author: "Tim Suchanek <suchanek@prisma.io>",
      maintainers: [
        "Jo\xEBl Galeran <galeran@prisma.io>",
        "Pierre-Antoine Mills <mills@prisma.io>",
        "Alexey Orlenko <orlenko@prisma.io>"
      ],
      bugs: "https://github.com/prisma/prisma/issues",
      scripts: {
        dev: "DEV=true node -r esbuild-register helpers/build.ts",
        build: "node -r esbuild-register helpers/build.ts",
        depcheck: "node -r esbuild-register ../../helpers/compile/depcheck.ts",
        test: "jest --verbose",
        "test-notypes": "jest --verbose --testPathIgnorePatterns src/__tests__/types/types.test.ts",
        format: "prettier --write .",
        lint: "eslint --cache --fix --ext .ts .",
        "lint-ci": "eslint --ext .ts .",
        generate: "node scripts/postinstall.js",
        postinstall: "node scripts/postinstall.js",
        prepare: "cp scripts/backup-index.js index.js && cp scripts/backup-index.d.ts index.d.ts",
        prepublishOnly: "pnpm run build",
        precommit: "lint-staged"
      },
      files: [
        "README.md",
        "runtime",
        "scripts",
        "generator-build",
        "index.js",
        "index.d.ts",
        "index-browser.js"
      ],
      devDependencies: {
        "@microsoft/api-extractor": "7.18.19",
        "@prisma/debug": "workspace:*",
        "@prisma/engine-core": "workspace:*",
        "@prisma/engines": "3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727",
        "@prisma/fetch-engine": "3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727",
        "@prisma/generator-helper": "workspace:*",
        "@prisma/get-platform": "3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727",
        "@prisma/migrate": "workspace:*",
        "@prisma/sdk": "workspace:*",
        "@timsuchanek/copy": "1.4.5",
        "@types/debug": "4.1.7",
        "@types/jest": "27.0.3",
        "@types/js-levenshtein": "1.1.0",
        "@types/mssql": "6.0.8",
        "@types/node": "12.20.37",
        "@types/pg": "8.6.1",
        "@typescript-eslint/eslint-plugin": "5.4.0",
        "@typescript-eslint/parser": "5.4.0",
        arg: "5.0.1",
        benchmark: "2.1.4",
        chalk: "4.1.2",
        "decimal.js": "10.3.1",
        esbuild: "0.13.14",
        eslint: "8.3.0",
        "eslint-config-prettier": "8.3.0",
        "eslint-plugin-eslint-comments": "3.2.0",
        "eslint-plugin-jest": "25.3.0",
        "eslint-plugin-prettier": "4.0.0",
        execa: "5.1.1",
        "flat-map-polyfill": "0.3.8",
        "fs-monkey": "1.0.3",
        "get-own-enumerable-property-symbols": "3.0.2",
        "indent-string": "4.0.0",
        "is-obj": "2.0.0",
        "is-regexp": "2.1.0",
        jest: "27.3.1",
        "js-levenshtein": "1.1.6",
        klona: "2.0.5",
        "lint-staged": "12.0.2",
        "lz-string": "1.4.4",
        "make-dir": "3.1.0",
        mariadb: "2.5.5",
        mssql: "7.2.1",
        pg: "8.7.1",
        "pkg-up": "3.1.0",
        pluralize: "8.0.0",
        prettier: "2.4.1",
        "replace-string": "3.1.0",
        rimraf: "3.0.2",
        "sort-keys": "4.2.0",
        "source-map-support": "0.5.20",
        "sql-template-tag": "4.0.0",
        "stacktrace-parser": "0.1.10",
        "strip-ansi": "6.0.1",
        "strip-indent": "3.0.0",
        "ts-jest": "27.0.7",
        "ts-node": "10.4.0",
        tsd: "0.18.0",
        typescript: "4.4.4"
      },
      peerDependencies: {
        prisma: "*"
      },
      peerDependenciesMeta: {
        prisma: {
          optional: true
        }
      },
      dependencies: {
        "@prisma/engines-version": "3.6.0-24.dc520b92b1ebb2d28dc3161f9f82e875bd35d727"
      },
      "lint-staged": {
        "*.ts": [
          "eslint",
          "prettier --write"
        ]
      },
      sideEffects: false
    };
  }
});

// ../../node_modules/.pnpm/lz-string@1.4.4/node_modules/lz-string/libs/lz-string.js
var require_lz_string = __commonJS2({
  "../../node_modules/.pnpm/lz-string@1.4.4/node_modules/lz-string/libs/lz-string.js"(exports2, module2) {
    var LZString = function() {
      var f = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      __name(getBaseValue, "getBaseValue");
      var LZString2 = {
        compressToBase64: function(input) {
          if (input == null)
            return "";
          var res = LZString2._compress(input, 6, function(a) {
            return keyStrBase64.charAt(a);
          });
          switch (res.length % 4) {
            default:
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input) {
          if (input == null)
            return "";
          if (input == "")
            return null;
          return LZString2._decompress(input.length, 32, function(index) {
            return getBaseValue(keyStrBase64, input.charAt(index));
          });
        },
        compressToUTF16: function(input) {
          if (input == null)
            return "";
          return LZString2._compress(input, 15, function(a) {
            return f(a + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          if (compressed == null)
            return "";
          if (compressed == "")
            return null;
          return LZString2._decompress(compressed.length, 16384, function(index) {
            return compressed.charCodeAt(index) - 32;
          });
        },
        compressToUint8Array: function(uncompressed) {
          var compressed = LZString2.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
            var current_value = compressed.charCodeAt(i);
            buf[i * 2] = current_value >>> 8;
            buf[i * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        decompressFromUint8Array: function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString2.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c) {
              result.push(f(c));
            });
            return LZString2.decompress(result.join(""));
          }
        },
        compressToEncodedURIComponent: function(input) {
          if (input == null)
            return "";
          return LZString2._compress(input, 6, function(a) {
            return keyStrUriSafe.charAt(a);
          });
        },
        decompressFromEncodedURIComponent: function(input) {
          if (input == null)
            return "";
          if (input == "")
            return null;
          input = input.replace(/ /g, "+");
          return LZString2._decompress(input.length, 32, function(index) {
            return getBaseValue(keyStrUriSafe, input.charAt(index));
          });
        },
        compress: function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a) {
            return f(a);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null)
            return "";
          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else
              context_data_position++;
          }
          return context_data.join("");
        },
        decompress: function(compressed) {
          if (compressed == null)
            return "";
          if (compressed == "")
            return null;
          return LZString2._decompress(compressed.length, 32768, function(index) {
            return compressed.charCodeAt(index);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i = 0; i < 3; i += 1) {
            dictionary[i] = i;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (next = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c;
          w = c;
          result.push(c);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c]) {
              entry = dictionary[c];
            } else {
              if (c === dictSize) {
                entry = w + w.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry);
            dictionary[dictSize++] = w + entry.charAt(0);
            enlargeIn--;
            w = entry;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString2;
    }();
    if (typeof define === "function" && false) {
      define(function() {
        return LZString;
      });
    } else if (typeof module2 !== "undefined" && module2 != null) {
      module2.exports = LZString;
    }
  }
});

// ../generator-helper/dist/esm/dmmf.mjs
var DMMF;
(function(DMMF2) {
  let ModelAction;
  (function(ModelAction2) {
    ModelAction2["findUnique"] = "findUnique";
    ModelAction2["findFirst"] = "findFirst";
    ModelAction2["findMany"] = "findMany";
    ModelAction2["create"] = "create";
    ModelAction2["createMany"] = "createMany";
    ModelAction2["update"] = "update";
    ModelAction2["updateMany"] = "updateMany";
    ModelAction2["upsert"] = "upsert";
    ModelAction2["delete"] = "delete";
    ModelAction2["deleteMany"] = "deleteMany";
    ModelAction2["groupBy"] = "groupBy";
    ModelAction2["count"] = "count";
    ModelAction2["aggregate"] = "aggregate";
  })(ModelAction = DMMF2.ModelAction || (DMMF2.ModelAction = {}));
})(DMMF || (DMMF = {}));

// src/runtime/utils/common.ts
var import_chalk = __toModule2(require_source2());
var import_indent_string = __toModule2(require_indent_string2());
var import_js_levenshtein = __toModule2(require_js_levenshtein());

// ../../node_modules/.pnpm/decimal.js@10.3.1/node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k; i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i = j; r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg2.d;
  if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg2, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg2, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
__name(digitsToString, "digitsToString");
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
__name(checkInt32, "checkInt32");
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1e3 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
__name(checkRoundingDigits, "checkRoundingDigits");
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
__name(convertBase, "convertBase");
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
__name(cosine, "cosine");
var divide = function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  __name(multiplyInteger, "multiplyInteger");
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  __name(compare, "compare");
  function subtract(a, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  __name(subtract, "subtract");
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits = 1, k = xd[0]; k >= 10; k /= 10)
        digits++;
      i = sd - digits;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits = 1; k >= 10; k /= 10)
            digits++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits;
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0]; j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length; xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
__name(finalise, "finalise");
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
__name(finiteToString, "finiteToString");
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE; w >= 10; w /= 10)
    e++;
  return e;
}
__name(getBase10Exponent, "getBase10Exponent");
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
__name(getLn10, "getLn10");
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
__name(getPi, "getPi");
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE + 1;
  w = digits[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
__name(getPrecision, "getPrecision");
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
__name(getZeroString, "getZeroString");
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
__name(intPow, "intPow");
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
__name(isOdd, "isOdd");
function maxOrMin(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
}
__name(maxOrMin, "maxOrMin");
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum3, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum3 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum3.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum3 = finalise(sum3.times(sum3), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum3, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum3;
      }
    }
    sum3 = t;
  }
}
__name(naturalExponential, "naturalExponential");
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum3 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
      sum3 = sum3.times(2);
      if (e !== 0)
        sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum3 = divide(sum3, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum3, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum3;
      }
    }
    sum3 = t;
    denominator += 2;
  }
}
__name(naturalLogarithm, "naturalLogarithm");
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
__name(nonFiniteToString, "nonFiniteToString");
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
__name(parseDecimal, "parseDecimal");
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
__name(parseOther, "parseOther");
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
__name(sine, "sine");
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
__name(taylorSeries, "taylorSeries");
function tinyPow(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
}
__name(tinyPow, "tinyPow");
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
__name(toLessThanHalfPi, "toLessThanHalfPi");
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i = 0, str = ""; i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 1, str = "1."; i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len; e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
__name(toStringBinary, "toStringBinary");
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
__name(truncate, "truncate");
function abs(x) {
  return new this(x).abs();
}
__name(abs, "abs");
function acos(x) {
  return new this(x).acos();
}
__name(acos, "acos");
function acosh(x) {
  return new this(x).acosh();
}
__name(acosh, "acosh");
function add(x, y) {
  return new this(x).plus(y);
}
__name(add, "add");
function asin(x) {
  return new this(x).asin();
}
__name(asin, "asin");
function asinh(x) {
  return new this(x).asinh();
}
__name(asinh, "asinh");
function atan(x) {
  return new this(x).atan();
}
__name(atan, "atan");
function atanh(x) {
  return new this(x).atanh();
}
__name(atanh, "atanh");
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
__name(atan2, "atan2");
function cbrt(x) {
  return new this(x).cbrt();
}
__name(cbrt, "cbrt");
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
__name(ceil, "ceil");
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
__name(clamp, "clamp");
function config(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
__name(config, "config");
function cos(x) {
  return new this(x).cos();
}
__name(cos, "cos");
function cosh(x) {
  return new this(x).cosh();
}
__name(cosh, "cosh");
function clone(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i2 === 43)
        v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  __name(Decimal2, "Decimal");
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
__name(clone, "clone");
function div(x, y) {
  return new this(x).div(y);
}
__name(div, "div");
function exp(x) {
  return new this(x).exp();
}
__name(exp, "exp");
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
__name(floor, "floor");
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
__name(hypot, "hypot");
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
__name(isDecimalInstance, "isDecimalInstance");
function ln(x) {
  return new this(x).ln();
}
__name(ln, "ln");
function log(x, y) {
  return new this(x).log(y);
}
__name(log, "log");
function log2(x) {
  return new this(x).log(2);
}
__name(log2, "log2");
function log10(x) {
  return new this(x).log(10);
}
__name(log10, "log10");
function max() {
  return maxOrMin(this, arguments, "lt");
}
__name(max, "max");
function min() {
  return maxOrMin(this, arguments, "gt");
}
__name(min, "min");
function mod(x, y) {
  return new this(x).mod(y);
}
__name(mod, "mod");
function mul(x, y) {
  return new this(x).mul(y);
}
__name(mul, "mul");
function pow(x, y) {
  return new this(x).pow(y);
}
__name(pow, "pow");
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
__name(random, "random");
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
__name(round, "round");
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
__name(sign, "sign");
function sin(x) {
  return new this(x).sin();
}
__name(sin, "sin");
function sinh(x) {
  return new this(x).sinh();
}
__name(sinh, "sinh");
function sqrt(x) {
  return new this(x).sqrt();
}
__name(sqrt, "sqrt");
function sub(x, y) {
  return new this(x).sub(y);
}
__name(sub, "sub");
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
__name(sum, "sum");
function tan(x) {
  return new this(x).tan();
}
__name(tan, "tan");
function tanh(x) {
  return new this(x).tanh();
}
__name(tanh, "tanh");
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
__name(trunc, "trunc");
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// src/runtime/utils/common.ts
var keyBy = /* @__PURE__ */ __name((collection, prop) => {
  const acc = {};
  for (const obj of collection) {
    const key = obj[prop];
    acc[key] = obj;
  }
  return acc;
}, "keyBy");
var keyBy2 = /* @__PURE__ */ __name((collection1, collection2, prop) => {
  const acc = {};
  for (const obj of collection1) {
    const key = obj[prop];
    acc[key] = obj;
  }
  for (const obj of collection2) {
    const key = obj[prop];
    acc[key] = obj;
  }
  return acc;
}, "keyBy2");
var ScalarTypeTable = {
  String: true,
  Int: true,
  Float: true,
  Boolean: true,
  Long: true,
  DateTime: true,
  ID: true,
  UUID: true,
  Json: true,
  Bytes: true,
  Decimal: true,
  BigInt: true
};
var JSTypeToGraphQLType = {
  string: "String",
  boolean: "Boolean",
  object: "Json"
};
function stringifyGraphQLType(type) {
  if (typeof type === "string") {
    return type;
  }
  return type.name;
}
__name(stringifyGraphQLType, "stringifyGraphQLType");
function wrapWithList(str, isList) {
  if (isList) {
    return `List<${str}>`;
  }
  return str;
}
__name(wrapWithList, "wrapWithList");
var RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
function getGraphQLType(value, potentialType) {
  if (value === null) {
    return "null";
  }
  if (Object.prototype.toString.call(value) === "[object BigInt]") {
    return "BigInt";
  }
  if (decimal_default.isDecimal(value)) {
    return "Decimal";
  }
  if (Buffer.isBuffer(value)) {
    return "Bytes";
  }
  if (Array.isArray(value)) {
    let scalarTypes = value.reduce((acc, val) => {
      const type = getGraphQLType(val, potentialType);
      if (!acc.includes(type)) {
        acc.push(type);
      }
      return acc;
    }, []);
    if (scalarTypes.includes("Float") && scalarTypes.includes("Int")) {
      scalarTypes = ["Float"];
    }
    return `List<${scalarTypes.join(" | ")}>`;
  }
  const jsType = typeof value;
  if (jsType === "number") {
    if (Math.trunc(value) === value) {
      return "Int";
    } else {
      return "Float";
    }
  }
  if (Object.prototype.toString.call(value) === "[object Date]") {
    return "DateTime";
  }
  if (jsType === "string") {
    if (UUID_REGEX.test(value)) {
      return "UUID";
    }
    const date = new Date(value);
    if (potentialType && typeof potentialType === "object" && potentialType.values && potentialType.values.includes(value)) {
      return potentialType.name;
    }
    if (date.toString() === "Invalid Date") {
      return "String";
    }
    if (RFC_3339_REGEX.test(value)) {
      return "DateTime";
    }
  }
  return JSTypeToGraphQLType[jsType];
}
__name(getGraphQLType, "getGraphQLType");
function getSuggestion(str, possibilities) {
  const bestMatch = possibilities.reduce((acc, curr) => {
    const distance = (0, import_js_levenshtein.default)(str, curr);
    if (distance < acc.distance) {
      return {
        distance,
        str: curr
      };
    }
    return acc;
  }, {
    distance: Math.min(Math.floor(str.length) * 1.1, ...possibilities.map((p) => p.length * 3)),
    str: null
  });
  return bestMatch.str;
}
__name(getSuggestion, "getSuggestion");
function stringifyInputType(input, greenKeys = false) {
  if (typeof input === "string") {
    return input;
  }
  if (input.values) {
    return `enum ${input.name} {
${(0, import_indent_string.default)(input.values.join(", "), 2)}
}`;
  } else {
    const body = (0, import_indent_string.default)(input.fields.map((arg2) => {
      const key = `${arg2.name}`;
      const str = `${greenKeys ? import_chalk.default.green(key) : key}${arg2.isRequired ? "" : "?"}: ${import_chalk.default.white(arg2.inputTypes.map((argType) => {
        return wrapWithList(argIsInputType(argType.type) ? argType.type.name : stringifyGraphQLType(argType.type), argType.isList);
      }).join(" | "))}`;
      if (!arg2.isRequired) {
        return import_chalk.default.dim(str);
      }
      return str;
    }).join("\n"), 2);
    return `${import_chalk.default.dim("type")} ${import_chalk.default.bold.dim(input.name)} ${import_chalk.default.dim("{")}
${body}
${import_chalk.default.dim("}")}`;
  }
}
__name(stringifyInputType, "stringifyInputType");
function argIsInputType(arg2) {
  if (typeof arg2 === "string") {
    return false;
  }
  return true;
}
__name(argIsInputType, "argIsInputType");
function getInputTypeName(input) {
  if (typeof input === "string") {
    if (input === "Null") {
      return "null";
    }
    return input;
  }
  return input.name;
}
__name(getInputTypeName, "getInputTypeName");
function getOutputTypeName(input) {
  if (typeof input === "string") {
    return input;
  }
  return input.name;
}
__name(getOutputTypeName, "getOutputTypeName");
function inputTypeToJson(input, isRequired, nameOnly = false) {
  if (typeof input === "string") {
    if (input === "Null") {
      return "null";
    }
    return input;
  }
  if (input.values) {
    return input.values.join(" | ");
  }
  const inputType = input;
  const showDeepType = isRequired && inputType.fields.every((arg2) => arg2.inputTypes[0].location === "inputObjectTypes" || arg2.inputTypes[1]?.location === "inputObjectTypes");
  if (nameOnly) {
    return getInputTypeName(input);
  }
  return inputType.fields.reduce((acc, curr) => {
    let str = "";
    if (!showDeepType && !curr.isRequired) {
      str = curr.inputTypes.map((argType) => getInputTypeName(argType.type)).join(" | ");
    } else {
      str = curr.inputTypes.map((argInputType) => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(" | ");
    }
    acc[curr.name + (curr.isRequired ? "" : "?")] = str;
    return acc;
  }, {});
}
__name(inputTypeToJson, "inputTypeToJson");
function unionBy(arr1, arr2, iteratee) {
  const map = {};
  for (const element of arr1) {
    map[iteratee(element)] = element;
  }
  for (const element of arr2) {
    const key = iteratee(element);
    if (!map[key]) {
      map[key] = element;
    }
  }
  return Object.values(map);
}
__name(unionBy, "unionBy");
function lowerCase(name) {
  return name.substring(0, 1).toLowerCase() + name.substring(1);
}
__name(lowerCase, "lowerCase");
function isGroupByOutputName(type) {
  return type.endsWith("GroupByOutputType");
}
__name(isGroupByOutputName, "isGroupByOutputName");

// src/runtime/dmmf.ts
var DMMFClass = class {
  constructor({ datamodel, schema, mappings }) {
    this.outputTypeToMergedOutputType = (outputType) => {
      return {
        ...outputType,
        fields: outputType.fields
      };
    };
    this.datamodel = datamodel;
    this.schema = schema;
    this.mappings = mappings;
    this.enumMap = this.getEnumMap();
    this.datamodelEnumMap = this.getDatamodelEnumMap();
    this.queryType = this.getQueryType();
    this.mutationType = this.getMutationType();
    this.modelMap = this.getModelMap();
    this.outputTypes = this.getOutputTypes();
    this.outputTypeMap = this.getMergedOutputTypeMap();
    this.resolveOutputTypes();
    this.inputObjectTypes = this.schema.inputObjectTypes;
    this.inputTypeMap = this.getInputTypeMap();
    this.resolveInputTypes();
    this.resolveFieldArgumentTypes();
    this.mappingsMap = this.getMappingsMap();
    this.queryType = this.outputTypeMap.Query;
    this.mutationType = this.outputTypeMap.Mutation;
    this.rootFieldMap = this.getRootFieldMap();
  }
  get [Symbol.toStringTag]() {
    return "DMMFClass";
  }
  resolveOutputTypes() {
    for (const type of this.outputTypes.model) {
      for (const field of type.fields) {
        if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
        }
      }
      type.fieldMap = keyBy(type.fields, "name");
    }
    for (const type of this.outputTypes.prisma) {
      for (const field of type.fields) {
        if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
        }
      }
      type.fieldMap = keyBy(type.fields, "name");
    }
  }
  resolveInputTypes() {
    const inputTypes = this.inputObjectTypes.prisma;
    if (this.inputObjectTypes.model) {
      inputTypes.push(...this.inputObjectTypes.model);
    }
    for (const type of inputTypes) {
      for (const field of type.fields) {
        for (const fieldInputType of field.inputTypes) {
          const fieldType = fieldInputType.type;
          if (typeof fieldType === "string" && !ScalarTypeTable[fieldType] && (this.inputTypeMap[fieldType] || this.enumMap[fieldType])) {
            fieldInputType.type = this.inputTypeMap[fieldType] || this.enumMap[fieldType] || fieldType;
          }
        }
      }
      type.fieldMap = keyBy(type.fields, "name");
    }
  }
  resolveFieldArgumentTypes() {
    for (const type of this.outputTypes.prisma) {
      for (const field of type.fields) {
        for (const arg2 of field.args) {
          for (const argInputType of arg2.inputTypes) {
            const argType = argInputType.type;
            if (typeof argType === "string" && !ScalarTypeTable[argType]) {
              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argType;
            }
          }
        }
      }
    }
    for (const type of this.outputTypes.model) {
      for (const field of type.fields) {
        for (const arg2 of field.args) {
          for (const argInputType of arg2.inputTypes) {
            const argType = argInputType.type;
            if (typeof argType === "string" && !ScalarTypeTable[argType]) {
              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argInputType.type;
            }
          }
        }
      }
    }
  }
  getQueryType() {
    return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Query");
  }
  getMutationType() {
    return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Mutation");
  }
  getOutputTypes() {
    return {
      model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType),
      prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType)
    };
  }
  getDatamodelEnumMap() {
    return keyBy(this.datamodel.enums, "name");
  }
  getEnumMap() {
    return {
      ...keyBy(this.schema.enumTypes.prisma, "name"),
      ...this.schema.enumTypes.model ? keyBy(this.schema.enumTypes.model, "name") : void 0
    };
  }
  getModelMap() {
    return keyBy(this.datamodel.models, "name");
  }
  getMergedOutputTypeMap() {
    return {
      ...keyBy(this.outputTypes.model, "name"),
      ...keyBy(this.outputTypes.prisma, "name")
    };
  }
  getInputTypeMap() {
    return {
      ...this.schema.inputObjectTypes.model ? keyBy(this.schema.inputObjectTypes.model, "name") : void 0,
      ...keyBy(this.schema.inputObjectTypes.prisma, "name")
    };
  }
  getMappingsMap() {
    return keyBy(this.mappings.modelOperations, "model");
  }
  getRootFieldMap() {
    return keyBy2(this.queryType.fields, this.mutationType.fields, "name");
  }
};
__name(DMMFClass, "DMMFClass");

// src/runtime/query.ts
var import_chalk5 = __toModule2(require_source2());
var import_indent_string2 = __toModule2(require_indent_string2());
var import_strip_ansi2 = __toModule2(require_strip_ansi());

// src/runtime/utils/deep-extend.ts
function isSpecificValue(val) {
  return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
}
__name(isSpecificValue, "isSpecificValue");
function cloneSpecificValue(val) {
  if (val instanceof Buffer) {
    const x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
    val.copy(x);
    return x;
  } else if (val instanceof Date) {
    return new Date(val.getTime());
  } else if (val instanceof RegExp) {
    return new RegExp(val);
  } else {
    throw new Error("Unexpected situation");
  }
}
__name(cloneSpecificValue, "cloneSpecificValue");
function deepCloneArray(arr) {
  const clone2 = [];
  arr.forEach(function(item, index) {
    if (typeof item === "object" && item !== null) {
      if (Array.isArray(item)) {
        clone2[index] = deepCloneArray(item);
      } else if (isSpecificValue(item)) {
        clone2[index] = cloneSpecificValue(item);
      } else {
        clone2[index] = deepExtend({}, item);
      }
    } else {
      clone2[index] = item;
    }
  });
  return clone2;
}
__name(deepCloneArray, "deepCloneArray");
function safeGetProperty(object, property) {
  return property === "__proto__" ? void 0 : object[property];
}
__name(safeGetProperty, "safeGetProperty");
var deepExtend = /* @__PURE__ */ __name(function(target, ...args) {
  if (!target || typeof target !== "object") {
    return false;
  }
  if (args.length === 0) {
    return target;
  }
  let val, src;
  for (const obj of args) {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
      continue;
    }
    for (const key of Object.keys(obj)) {
      src = safeGetProperty(target, key);
      val = safeGetProperty(obj, key);
      if (val === target) {
        continue;
      } else if (typeof val !== "object" || val === null) {
        target[key] = val;
        continue;
      } else if (Array.isArray(val)) {
        target[key] = deepCloneArray(val);
        continue;
      } else if (isSpecificValue(val)) {
        target[key] = cloneSpecificValue(val);
        continue;
      } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
        target[key] = deepExtend({}, val);
        continue;
      } else {
        target[key] = deepExtend(src, val);
        continue;
      }
    }
  }
  return target;
}, "deepExtend");

// src/runtime/utils/deep-set.ts
var keys = /* @__PURE__ */ __name((ks) => Array.isArray(ks) ? ks : ks.split("."), "keys");
var deepGet = /* @__PURE__ */ __name((o, kp) => keys(kp).reduce((o2, k) => o2 && o2[k], o), "deepGet");
var deepSet = /* @__PURE__ */ __name((o, kp, v) => keys(kp).reduceRight((v2, k, i, ks) => Object.assign({}, deepGet(o, ks.slice(0, i)), { [k]: v2 }), v), "deepSet");

// src/runtime/utils/filterObject.ts
function filterObject(obj, cb) {
  if (!obj || typeof obj !== "object" || typeof obj.hasOwnProperty !== "function") {
    return obj;
  }
  const newObj = {};
  for (const key in obj) {
    const value = obj[key];
    if (Object.hasOwnProperty.call(obj, key) && cb(key, value)) {
      newObj[key] = value;
    }
  }
  return newObj;
}
__name(filterObject, "filterObject");

// src/runtime/utils/flatMap.ts
function flatten(array) {
  return Array.prototype.concat.apply([], array);
}
__name(flatten, "flatten");
function flatMap(array, callbackFn, thisArg) {
  return flatten(array.map(callbackFn, thisArg));
}
__name(flatMap, "flatMap");

// src/runtime/utils/isObject.ts
var notReallyObjects = {
  "[object Date]": true,
  "[object BitInt]": true,
  "[object Uint8Array]": true,
  "[object Function]": true
};
function isObject(value) {
  return value && typeof value === "object" && !notReallyObjects[Object.prototype.toString.call(value)];
}
__name(isObject, "isObject");

// src/runtime/utils/omit.ts
function omit(object, path6) {
  const result = {};
  const paths = Array.isArray(path6) ? path6 : [path6];
  for (const key in object) {
    if (Object.hasOwnProperty.call(object, key) && !paths.includes(key)) {
      result[key] = object[key];
    }
  }
  return result;
}
__name(omit, "omit");

// src/runtime/utils/printJsonErrors.ts
var import_chalk2 = __toModule2(require_source2());
var import_strip_ansi = __toModule2(require_strip_ansi());

// src/runtime/utils/stringifyObject.ts
"use strict";
var isRegexp = require_is_regexp();
var isObj = require_is_obj();
var getOwnEnumPropSymbols = require_lib3().default;
var stringifyObject = /* @__PURE__ */ __name((input, options2, pad) => {
  const seen = [];
  return (/* @__PURE__ */ __name(function stringifyObject2(input2, options3 = {}, pad2 = "", path6 = []) {
    options3.indent = options3.indent || "	";
    let tokens;
    if (options3.inlineCharacterLimit === void 0) {
      tokens = {
        newLine: "\n",
        newLineOrSpace: "\n",
        pad: pad2,
        indent: pad2 + options3.indent
      };
    } else {
      tokens = {
        newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
        newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
        pad: "@@__STRINGIFY_OBJECT_PAD__@@",
        indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
      };
    }
    const expandWhiteSpace = /* @__PURE__ */ __name((string) => {
      if (options3.inlineCharacterLimit === void 0) {
        return string;
      }
      const oneLined = string.replace(new RegExp(tokens.newLine, "g"), "").replace(new RegExp(tokens.newLineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
      if (oneLined.length <= options3.inlineCharacterLimit) {
        return oneLined;
      }
      return string.replace(new RegExp(tokens.newLine + "|" + tokens.newLineOrSpace, "g"), "\n").replace(new RegExp(tokens.pad, "g"), pad2).replace(new RegExp(tokens.indent, "g"), pad2 + options3.indent);
    }, "expandWhiteSpace");
    if (seen.indexOf(input2) !== -1) {
      return '"[Circular]"';
    }
    if (Buffer.isBuffer(input2)) {
      return `Buffer(${Buffer.length})`;
    }
    if (input2 === null || input2 === void 0 || typeof input2 === "number" || typeof input2 === "boolean" || typeof input2 === "function" || typeof input2 === "symbol" || isRegexp(input2)) {
      return String(input2);
    }
    if (input2 instanceof Date) {
      return `new Date('${input2.toISOString()}')`;
    }
    if (Array.isArray(input2)) {
      if (input2.length === 0) {
        return "[]";
      }
      seen.push(input2);
      const ret = "[" + tokens.newLine + input2.map((el, i) => {
        const eol = input2.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
        let value = stringifyObject2(el, options3, pad2 + options3.indent, [...path6, i]);
        if (options3.transformValue) {
          value = options3.transformValue(input2, i, value);
        }
        return tokens.indent + value + eol;
      }).join("") + tokens.pad + "]";
      seen.pop();
      return expandWhiteSpace(ret);
    }
    if (isObj(input2)) {
      let objKeys = Object.keys(input2).concat(getOwnEnumPropSymbols(input2));
      if (options3.filter) {
        objKeys = objKeys.filter((el) => options3.filter(input2, el));
      }
      if (objKeys.length === 0) {
        return "{}";
      }
      seen.push(input2);
      const ret = "{" + tokens.newLine + objKeys.map((el, i) => {
        const eol = objKeys.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
        const isSymbol = typeof el === "symbol";
        const isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el);
        const key = isSymbol || isClassic ? el : stringifyObject2(el, options3, void 0, [...path6, el]);
        let value = stringifyObject2(input2[el], options3, pad2 + options3.indent, [...path6, el]);
        if (options3.transformValue) {
          value = options3.transformValue(input2, el, value);
        }
        let line = tokens.indent + String(key) + ": " + value + eol;
        if (options3.transformLine) {
          line = options3.transformLine({
            obj: input2,
            indent: tokens.indent,
            key,
            stringifiedValue: value,
            value: input2[el],
            eol,
            originalLine: line,
            path: path6.concat(key)
          });
        }
        return line;
      }).join("") + tokens.pad + "}";
      seen.pop();
      return expandWhiteSpace(ret);
    }
    input2 = String(input2).replace(/[\r\n]/g, (x) => x === "\n" ? "\\n" : "\\r");
    if (options3.singleQuotes === false) {
      input2 = input2.replace(/"/g, '\\"');
      return `"${input2}"`;
    }
    input2 = input2.replace(/\\?'/g, "\\'");
    return `'${input2}'`;
  }, "stringifyObject"))(input, options2, pad);
}, "stringifyObject");
var stringifyObject_default = stringifyObject;

// src/runtime/utils/printJsonErrors.ts
var DIM_TOKEN = "@@__DIM_POINTER__@@";
function printJsonWithErrors({ ast, keyPaths, valuePaths, missingItems }) {
  let obj = ast;
  for (const { path: path6, type } of missingItems) {
    obj = deepSet(obj, path6, type);
  }
  return stringifyObject_default(obj, {
    indent: "  ",
    transformLine: ({ indent: indent4, key, value, stringifiedValue, eol, path: path6 }) => {
      const dottedPath = path6.join(".");
      const keyError = keyPaths.includes(dottedPath);
      const valueError = valuePaths.includes(dottedPath);
      const missingItem = missingItems.find((item) => item.path === dottedPath);
      let valueStr = stringifiedValue;
      if (missingItem) {
        if (typeof value === "string") {
          valueStr = valueStr.slice(1, valueStr.length - 1);
        }
        const isRequiredStr = missingItem.isRequired ? "" : "?";
        const prefix = missingItem.isRequired ? "+" : "?";
        const color = missingItem.isRequired ? import_chalk2.default.greenBright : import_chalk2.default.green;
        let output = color(prefixLines(key + isRequiredStr + ": " + valueStr + eol, indent4, prefix));
        if (!missingItem.isRequired) {
          output = import_chalk2.default.dim(output);
        }
        return output;
      } else {
        const isOnMissingItemPath = missingItems.some((item) => dottedPath.startsWith(item.path));
        const isOptional = key[key.length - 2] === "?";
        if (isOptional) {
          key = key.slice(1, key.length - 1);
        }
        if (isOptional && typeof value === "object" && value !== null) {
          valueStr = valueStr.split("\n").map((line, index, arr) => index === arr.length - 1 ? line + DIM_TOKEN : line).join("\n");
        }
        if (isOnMissingItemPath && typeof value === "string") {
          valueStr = valueStr.slice(1, valueStr.length - 1);
          if (!isOptional) {
            valueStr = import_chalk2.default.bold(valueStr);
          }
        }
        if ((typeof value !== "object" || value === null) && !valueError && !isOnMissingItemPath) {
          valueStr = import_chalk2.default.dim(valueStr);
        }
        const keyStr = keyError ? import_chalk2.default.redBright(key) : key;
        valueStr = valueError ? import_chalk2.default.redBright(valueStr) : valueStr;
        let output = indent4 + keyStr + ": " + valueStr + (isOnMissingItemPath ? eol : import_chalk2.default.dim(eol));
        if (keyError || valueError) {
          const lines = output.split("\n");
          const keyLength = String(key).length;
          const keyScribbles = keyError ? import_chalk2.default.redBright("~".repeat(keyLength)) : " ".repeat(keyLength);
          const valueLength = valueError ? getValueLength(indent4, key, value, stringifiedValue) : 0;
          const hideValueScribbles = Boolean(valueError && typeof value === "object" && value !== null);
          const valueScribbles = valueError ? "  " + import_chalk2.default.redBright("~".repeat(valueLength)) : "";
          if (keyScribbles && keyScribbles.length > 0 && !hideValueScribbles) {
            lines.splice(1, 0, indent4 + keyScribbles + valueScribbles);
          }
          if (keyScribbles && keyScribbles.length > 0 && hideValueScribbles) {
            lines.splice(lines.length - 1, 0, indent4.slice(0, indent4.length - 2) + valueScribbles);
          }
          output = lines.join("\n");
        }
        return output;
      }
    }
  });
}
__name(printJsonWithErrors, "printJsonWithErrors");
function getValueLength(indent4, key, value, stringifiedValue) {
  if (value === null) {
    return 4;
  }
  if (typeof value === "string") {
    return value.length + 2;
  }
  if (typeof value === "object") {
    return Math.abs(getLongestLine(`${key}: ${(0, import_strip_ansi.default)(stringifiedValue)}`) - indent4.length);
  }
  return String(value).length;
}
__name(getValueLength, "getValueLength");
function getLongestLine(str) {
  return str.split("\n").reduce((max2, curr) => curr.length > max2 ? curr.length : max2, 0);
}
__name(getLongestLine, "getLongestLine");
function prefixLines(str, indent4, prefix) {
  return str.split("\n").map((line, index, arr) => index === 0 ? prefix + indent4.slice(1) + line : index < arr.length - 1 ? prefix + line.slice(1) : line).map((line) => {
    return (0, import_strip_ansi.default)(line).includes(DIM_TOKEN) ? import_chalk2.default.dim(line.replace(DIM_TOKEN, "")) : line.includes("?") ? import_chalk2.default.dim(line) : line;
  }).join("\n");
}
__name(prefixLines, "prefixLines");

// src/runtime/utils/printStack.ts
var import_chalk4 = __toModule2(require_source2());

// ../../node_modules/.pnpm/stacktrace-parser@0.1.10/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js
var UNKNOWN_FUNCTION = "<unknown>";
function parse(stackString) {
  var lines = stackString.split("\n");
  return lines.reduce(function(stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
    if (parseResult) {
      stack.push(parseResult);
    }
    return stack;
  }, []);
}
__name(parse, "parse");
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
function parseChrome(line) {
  var parts = chromeRe.exec(line);
  if (!parts) {
    return null;
  }
  var isNative = parts[2] && parts[2].indexOf("native") === 0;
  var isEval = parts[2] && parts[2].indexOf("eval") === 0;
  var submatch = chromeEvalRe.exec(parts[2]);
  if (isEval && submatch != null) {
    parts[2] = submatch[1];
    parts[3] = submatch[2];
    parts[4] = submatch[3];
  }
  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}
__name(parseChrome, "parseChrome");
var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseWinjs(line) {
  var parts = winjsRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}
__name(parseWinjs, "parseWinjs");
var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
function parseGecko(line) {
  var parts = geckoRe.exec(line);
  if (!parts) {
    return null;
  }
  var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
  var submatch = geckoEvalRe.exec(parts[3]);
  if (isEval && submatch != null) {
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null;
  }
  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(",") : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}
__name(parseGecko, "parseGecko");
var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}
__name(parseJSC, "parseJSC");
var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseNode(line) {
  var parts = nodeRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}
__name(parseNode, "parseNode");

// src/runtime/highlight/theme.ts
var import_chalk3 = __toModule2(require_source2());
var orange = import_chalk3.default.rgb(246, 145, 95);
var darkBrightBlue = import_chalk3.default.rgb(107, 139, 140);
var blue = import_chalk3.default.cyan;
var brightBlue = import_chalk3.default.rgb(127, 155, 155);
var identity = /* @__PURE__ */ __name((str) => str, "identity");
var theme = {
  keyword: blue,
  entity: blue,
  value: brightBlue,
  punctuation: darkBrightBlue,
  directive: blue,
  function: blue,
  variable: brightBlue,
  string: import_chalk3.default.greenBright,
  boolean: orange,
  number: import_chalk3.default.cyan,
  comment: import_chalk3.default.grey
};

// src/runtime/highlight/prism.ts
var _self = {};
var uniqueId = 0;
var Prism = {
  manual: _self.Prism && _self.Prism.manual,
  disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
  util: {
    encode: function(tokens) {
      if (tokens instanceof Token) {
        const anyTokens = tokens;
        return new Token(anyTokens.type, Prism.util.encode(anyTokens.content), anyTokens.alias);
      } else if (Array.isArray(tokens)) {
        return tokens.map(Prism.util.encode);
      } else {
        return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
      }
    },
    type: function(o) {
      return Object.prototype.toString.call(o).slice(8, -1);
    },
    objId: function(obj) {
      if (!obj["__id"]) {
        Object.defineProperty(obj, "__id", { value: ++uniqueId });
      }
      return obj["__id"];
    },
    clone: /* @__PURE__ */ __name(function deepClone(o, visited) {
      let clone2, id, type = Prism.util.type(o);
      visited = visited || {};
      switch (type) {
        case "Object":
          id = Prism.util.objId(o);
          if (visited[id]) {
            return visited[id];
          }
          clone2 = {};
          visited[id] = clone2;
          for (const key in o) {
            if (o.hasOwnProperty(key)) {
              clone2[key] = deepClone(o[key], visited);
            }
          }
          return clone2;
        case "Array":
          id = Prism.util.objId(o);
          if (visited[id]) {
            return visited[id];
          }
          clone2 = [];
          visited[id] = clone2;
          o.forEach(function(v, i) {
            clone2[i] = deepClone(v, visited);
          });
          return clone2;
        default:
          return o;
      }
    }, "deepClone")
  },
  languages: {
    extend: function(id, redef) {
      const lang = Prism.util.clone(Prism.languages[id]);
      for (const key in redef) {
        lang[key] = redef[key];
      }
      return lang;
    },
    insertBefore: function(inside, before, insert, root) {
      root = root || Prism.languages;
      const grammar = root[inside];
      const ret = {};
      for (const token in grammar) {
        if (grammar.hasOwnProperty(token)) {
          if (token == before) {
            for (const newToken in insert) {
              if (insert.hasOwnProperty(newToken)) {
                ret[newToken] = insert[newToken];
              }
            }
          }
          if (!insert.hasOwnProperty(token)) {
            ret[token] = grammar[token];
          }
        }
      }
      const old = root[inside];
      root[inside] = ret;
      Prism.languages.DFS(Prism.languages, function(key, value) {
        if (value === old && key != inside) {
          this[key] = ret;
        }
      });
      return ret;
    },
    DFS: /* @__PURE__ */ __name(function DFS(o, callback, type, visited) {
      visited = visited || {};
      const objId = Prism.util.objId;
      for (const i in o) {
        if (o.hasOwnProperty(i)) {
          callback.call(o, i, o[i], type || i);
          const property = o[i], propertyType = Prism.util.type(property);
          if (propertyType === "Object" && !visited[objId(property)]) {
            visited[objId(property)] = true;
            DFS(property, callback, null, visited);
          } else if (propertyType === "Array" && !visited[objId(property)]) {
            visited[objId(property)] = true;
            DFS(property, callback, i, visited);
          }
        }
      }
    }, "DFS")
  },
  plugins: {},
  highlight: function(text, grammar, language) {
    const env = {
      code: text,
      grammar,
      language
    };
    Prism.hooks.run("before-tokenize", env);
    env.tokens = Prism.tokenize(env.code, env.grammar);
    Prism.hooks.run("after-tokenize", env);
    return Token.stringify(Prism.util.encode(env.tokens), env.language);
  },
  matchGrammar: function(text, strarr, grammar, index, startPos, oneshot, target) {
    for (const token in grammar) {
      if (!grammar.hasOwnProperty(token) || !grammar[token]) {
        continue;
      }
      if (token == target) {
        return;
      }
      let patterns = grammar[token];
      patterns = Prism.util.type(patterns) === "Array" ? patterns : [patterns];
      for (let j = 0; j < patterns.length; ++j) {
        let pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;
        if (greedy && !pattern.pattern.global) {
          const flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
          pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
        }
        pattern = pattern.pattern || pattern;
        for (let i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
          let str = strarr[i];
          if (strarr.length > text.length) {
            return;
          }
          if (str instanceof Token) {
            continue;
          }
          if (greedy && i != strarr.length - 1) {
            pattern.lastIndex = pos;
            var match = pattern.exec(text);
            if (!match) {
              break;
            }
            var from = match.index + (lookbehind ? match[1].length : 0), to = match.index + match[0].length, k = i, p = pos;
            for (let len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {
              p += strarr[k].length;
              if (from >= p) {
                ++i;
                pos = p;
              }
            }
            if (strarr[i] instanceof Token) {
              continue;
            }
            delNum = k - i;
            str = text.slice(pos, p);
            match.index -= pos;
          } else {
            pattern.lastIndex = 0;
            var match = pattern.exec(str), delNum = 1;
          }
          if (!match) {
            if (oneshot) {
              break;
            }
            continue;
          }
          if (lookbehind) {
            lookbehindLength = match[1] ? match[1].length : 0;
          }
          var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);
          const args = [i, delNum];
          if (before) {
            ++i;
            pos += before.length;
            args.push(before);
          }
          const wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);
          args.push(wrapped);
          if (after) {
            args.push(after);
          }
          Array.prototype.splice.apply(strarr, args);
          if (delNum != 1)
            Prism.matchGrammar(text, strarr, grammar, i, pos, true, token);
          if (oneshot)
            break;
        }
      }
    }
  },
  tokenize: function(text, grammar) {
    const strarr = [text];
    const rest = grammar.rest;
    if (rest) {
      for (const token in rest) {
        grammar[token] = rest[token];
      }
      delete grammar.rest;
    }
    Prism.matchGrammar(text, strarr, grammar, 0, 0, false);
    return strarr;
  },
  hooks: {
    all: {},
    add: function(name, callback) {
      const hooks = Prism.hooks.all;
      hooks[name] = hooks[name] || [];
      hooks[name].push(callback);
    },
    run: function(name, env) {
      const callbacks = Prism.hooks.all[name];
      if (!callbacks || !callbacks.length) {
        return;
      }
      for (var i = 0, callback; callback = callbacks[i++]; ) {
        callback(env);
      }
    }
  },
  Token
};
Prism.languages.clike = {
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true
    },
    {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }
  ],
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
    lookbehind: true,
    inside: {
      punctuation: /[.\\]/
    }
  },
  keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
  boolean: /\b(?:true|false)\b/,
  function: /\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
  punctuation: /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
      lookbehind: true
    }
  ],
  keyword: [
    {
      pattern: /((?:^|})\s*)(?:catch|finally)\b/,
      lookbehind: true
    },
    {
      pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }
  ],
  number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
  function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,
    lookbehind: true,
    greedy: true
  },
  "function-variable": {
    pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
    alias: "function"
  },
  parameter: [
    {
      pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  ],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
}
Prism.languages.js = Prism.languages.javascript;
Prism.languages.typescript = Prism.languages.extend("javascript", {
  keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,
  builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/
});
Prism.languages.ts = Prism.languages.typescript;
function Token(type, content, alias, matchedStr, greedy) {
  this.type = type;
  this.content = content;
  this.alias = alias;
  this.length = (matchedStr || "").length | 0;
  this.greedy = !!greedy;
}
__name(Token, "Token");
Token.stringify = function(o, language) {
  if (typeof o == "string") {
    return o;
  }
  if (Array.isArray(o)) {
    return o.map(function(element) {
      return Token.stringify(element, language);
    }).join("");
  }
  return getColorForSyntaxKind(o.type)(o.content);
};
function getColorForSyntaxKind(syntaxKind) {
  return theme[syntaxKind] || identity;
}
__name(getColorForSyntaxKind, "getColorForSyntaxKind");

// src/runtime/highlight/highlight.ts
function highlightTS(str) {
  return highlight(str, Prism.languages.javascript);
}
__name(highlightTS, "highlightTS");
function highlight(str, grammar) {
  const tokens = Prism.tokenize(str, grammar);
  return tokens.map((t) => Token.stringify(t)).join("");
}
__name(highlight, "highlight");

// src/runtime/utils/dedent.ts
var import_strip_indent = __toModule2(require_strip_indent());
function dedent(str) {
  return (0, import_strip_indent.default)(str);
}
__name(dedent, "dedent");

// src/runtime/utils/printStack.ts
function renderN(n, max2) {
  const wantedLetters = String(max2).length;
  const hasLetters = String(n).length;
  if (hasLetters >= wantedLetters) {
    return String(n);
  }
  return " ".repeat(wantedLetters - hasLetters) + n;
}
__name(renderN, "renderN");
function getIndent(line) {
  let spaceCount = 0;
  for (let i = 0; i < line.length; i++) {
    if (line.charAt(i) !== " ") {
      return spaceCount;
    }
    spaceCount++;
  }
  return spaceCount;
}
__name(getIndent, "getIndent");
function parseStack({
  callsite,
  renderPathRelative,
  originalMethod,
  onUs,
  showColors,
  isValidationError
}) {
  const params = {
    callsiteStr: ":",
    prevLines: "\n",
    functionName: `prisma.${originalMethod}()`,
    afterLines: "",
    indentValue: 0,
    lastErrorHeight: 20
  };
  if (!callsite || typeof window !== "undefined") {
    return params;
  }
  const stack = parse(callsite);
  const trace = stack.find((t) => {
    return t.file && t.file !== "<anonymous>" && !t.file.includes("@prisma") && !t.file.includes("getPrismaClient") && !t.file.startsWith("internal/") && !t.methodName.includes("new ") && !t.methodName.includes("_getCallsite") && t.methodName.split(".").length < 4;
  });
  if (process.env.NODE_ENV !== "production" && trace && trace.file && trace.lineNumber && trace.column) {
    const lineNumber = trace.lineNumber;
    const printedFileName = renderPathRelative ? __require("path").relative(process.cwd(), trace.file) : trace.file;
    const start = Math.max(0, lineNumber - 4);
    const fs7 = __require("fs");
    const exists4 = fs7.existsSync(trace.file);
    if (exists4) {
      const file2 = fs7.readFileSync(trace.file, "utf-8");
      const slicedFile = file2.split("\n").slice(start, lineNumber).join("\n");
      const lines = dedent(slicedFile).split("\n");
      const theLine = lines[lines.length - 1];
      if (!theLine || theLine.trim() === "") {
        params.callsiteStr = ":";
      } else {
        const prismaClientRegex = /(\S+(create|createMany|updateMany|deleteMany|update|delete|findMany|findUnique)\()/;
        const match = prismaClientRegex.exec(theLine);
        if (!match) {
          return params;
        }
        params.functionName = `${match[1]})`;
        params.callsiteStr = ` in
${import_chalk4.default.underline(`${printedFileName}:${trace.lineNumber}:${trace.column}`)}`;
        const slicePoint = theLine.indexOf("{");
        const linesToHighlight = lines.map((l, i, all) => !onUs && i === all.length - 1 ? l.slice(0, slicePoint > -1 ? slicePoint : l.length - 1) : l).join("\n");
        const highlightedLines = showColors ? highlightTS(linesToHighlight).split("\n") : linesToHighlight.split("\n");
        params.prevLines = "\n" + highlightedLines.map((l, i) => import_chalk4.default.grey(renderN(i + start + 1, lineNumber + start + 1) + " ") + import_chalk4.default.reset() + l).map((l, i, arr) => i === arr.length - 1 ? `${import_chalk4.default.red.bold("\u2192")} ${import_chalk4.default.dim(l)}` : import_chalk4.default.dim("  " + l)).join("\n");
        if (!match && !isValidationError) {
          params.prevLines += "\n\n";
        }
        params.afterLines = ")";
        params.indentValue = String(lineNumber + start + 1).length + getIndent(theLine) + 1 + (match ? 2 : 0);
      }
    }
  }
  return params;
}
__name(parseStack, "parseStack");
var printStack = /* @__PURE__ */ __name((args) => {
  const { callsiteStr, prevLines, functionName, afterLines, indentValue, lastErrorHeight } = parseStack(args);
  const introText = args.onUs ? import_chalk4.default.red(`Oops, an unknown error occured! This is ${import_chalk4.default.bold("on us")}, you did nothing wrong.
It occured in the ${import_chalk4.default.bold(`\`${functionName}\``)} invocation${callsiteStr}`) : import_chalk4.default.red(`Invalid ${import_chalk4.default.bold(`\`${functionName}\``)} invocation${callsiteStr}`);
  const stackStr = `
${introText}
${prevLines}${import_chalk4.default.reset()}`;
  return { indent: indentValue, stack: stackStr, afterLines, lastErrorHeight };
}, "printStack");

// src/runtime/query.ts
var tab = 2;
var Document = class {
  constructor(type, children) {
    this.type = type;
    this.children = children;
    this.printFieldError = ({ error: error2 }, missingItems, minimal) => {
      if (error2.type === "emptySelect") {
        const additional = minimal ? "" : ` Available options are listed in ${import_chalk5.default.greenBright.dim("green")}.`;
        return `The ${import_chalk5.default.redBright("`select`")} statement for type ${import_chalk5.default.bold(getOutputTypeName(error2.field.outputType.type))} must not be empty.${additional}`;
      }
      if (error2.type === "emptyInclude") {
        if (missingItems.length === 0) {
          return `${import_chalk5.default.bold(getOutputTypeName(error2.field.outputType.type))} does not have any relation and therefore can't have an ${import_chalk5.default.redBright("`include`")} statement.`;
        }
        const additional = minimal ? "" : ` Available options are listed in ${import_chalk5.default.greenBright.dim("green")}.`;
        return `The ${import_chalk5.default.redBright("`include`")} statement for type ${import_chalk5.default.bold(getOutputTypeName(error2.field.outputType.type))} must not be empty.${additional}`;
      }
      if (error2.type === "noTrueSelect") {
        return `The ${import_chalk5.default.redBright("`select`")} statement for type ${import_chalk5.default.bold(getOutputTypeName(error2.field.outputType.type))} needs ${import_chalk5.default.bold("at least one truthy value")}.`;
      }
      if (error2.type === "includeAndSelect") {
        return `Please ${import_chalk5.default.bold("either")} use ${import_chalk5.default.greenBright("`include`")} or ${import_chalk5.default.greenBright("`select`")}, but ${import_chalk5.default.redBright("not both")} at the same time.`;
      }
      if (error2.type === "invalidFieldName") {
        const statement = error2.isInclude ? "include" : "select";
        const wording = error2.isIncludeScalar ? "Invalid scalar" : "Unknown";
        const additional = minimal ? "" : error2.isInclude && missingItems.length === 0 ? `
This model has no relations, so you can't use ${import_chalk5.default.redBright("include")} with it.` : ` Available options are listed in ${import_chalk5.default.greenBright.dim("green")}.`;
        let str = `${wording} field ${import_chalk5.default.redBright(`\`${error2.providedName}\``)} for ${import_chalk5.default.bold(statement)} statement on model ${import_chalk5.default.bold.white(error2.modelName)}.${additional}`;
        if (error2.didYouMean) {
          str += ` Did you mean ${import_chalk5.default.greenBright(`\`${error2.didYouMean}\``)}?`;
        }
        if (error2.isIncludeScalar) {
          str += `
Note, that ${import_chalk5.default.bold("include")} statements only accept relation fields.`;
        }
        return str;
      }
      if (error2.type === "invalidFieldType") {
        const str = `Invalid value ${import_chalk5.default.redBright(`${stringifyObject_default(error2.providedValue)}`)} of type ${import_chalk5.default.redBright(getGraphQLType(error2.providedValue, void 0))} for field ${import_chalk5.default.bold(`${error2.fieldName}`)} on model ${import_chalk5.default.bold.white(error2.modelName)}. Expected either ${import_chalk5.default.greenBright("true")} or ${import_chalk5.default.greenBright("false")}.`;
        return str;
      }
      return void 0;
    };
    this.printArgError = ({ error: error2, path: path6, id }, hasMissingItems, minimal) => {
      if (error2.type === "invalidName") {
        let str = `Unknown arg ${import_chalk5.default.redBright(`\`${error2.providedName}\``)} in ${import_chalk5.default.bold(path6.join("."))} for type ${import_chalk5.default.bold(error2.outputType ? error2.outputType.name : getInputTypeName(error2.originalType))}.`;
        if (error2.didYouMeanField) {
          str += `
\u2192 Did you forget to wrap it with \`${import_chalk5.default.greenBright("select")}\`? ${import_chalk5.default.dim("e.g. " + import_chalk5.default.greenBright(`{ select: { ${error2.providedName}: ${error2.providedValue} } }`))}`;
        } else if (error2.didYouMeanArg) {
          str += ` Did you mean \`${import_chalk5.default.greenBright(error2.didYouMeanArg)}\`?`;
          if (!hasMissingItems && !minimal) {
            str += ` ${import_chalk5.default.dim("Available args:")}
` + stringifyInputType(error2.originalType, true);
          }
        } else {
          if (error2.originalType.fields.length === 0) {
            str += ` The field ${import_chalk5.default.bold(error2.originalType.name)} has no arguments.`;
          } else if (!hasMissingItems && !minimal) {
            str += ` Available args:

` + stringifyInputType(error2.originalType, true);
          }
        }
        return str;
      }
      if (error2.type === "invalidType") {
        let valueStr = stringifyObject_default(error2.providedValue, { indent: "  " });
        const multilineValue = valueStr.split("\n").length > 1;
        if (multilineValue) {
          valueStr = `
${valueStr}
`;
        }
        if (error2.requiredType.bestFittingType.location === "enumTypes") {
          return `Argument ${import_chalk5.default.bold(error2.argName)}: Provided value ${import_chalk5.default.redBright(valueStr)}${multilineValue ? "" : " "}of type ${import_chalk5.default.redBright(getGraphQLType(error2.providedValue))} on ${import_chalk5.default.bold(`prisma.${this.children[0].name}`)} is not a ${import_chalk5.default.greenBright(wrapWithList(stringifyGraphQLType(error2.requiredType.bestFittingType.location), error2.requiredType.bestFittingType.isList))}.
\u2192 Possible values: ${error2.requiredType.bestFittingType.type.values.map((v) => import_chalk5.default.greenBright(`${stringifyGraphQLType(error2.requiredType.bestFittingType.type)}.${v}`)).join(", ")}`;
        }
        let typeStr = ".";
        if (isInputArgType(error2.requiredType.bestFittingType.type)) {
          typeStr = ":\n" + stringifyInputType(error2.requiredType.bestFittingType.type);
        }
        let expected = `${error2.requiredType.inputType.map((t) => import_chalk5.default.greenBright(wrapWithList(stringifyGraphQLType(t.type), error2.requiredType.bestFittingType.isList))).join(" or ")}${typeStr}`;
        const inputType = error2.requiredType.inputType.length === 2 && error2.requiredType.inputType.find((t) => isInputArgType(t.type)) || null;
        if (inputType) {
          expected += `
` + stringifyInputType(inputType.type, true);
        }
        return `Argument ${import_chalk5.default.bold(error2.argName)}: Got invalid value ${import_chalk5.default.redBright(valueStr)}${multilineValue ? "" : " "}on ${import_chalk5.default.bold(`prisma.${this.children[0].name}`)}. Provided ${import_chalk5.default.redBright(getGraphQLType(error2.providedValue))}, expected ${expected}`;
      }
      if (error2.type === "invalidNullArg") {
        const forStr = path6.length === 1 && path6[0] === error2.name ? "" : ` for ${import_chalk5.default.bold(`${path6.join(".")}`)}`;
        const undefinedTip = ` Please use ${import_chalk5.default.bold.greenBright("undefined")} instead.`;
        return `Argument ${import_chalk5.default.greenBright(error2.name)}${forStr} must not be ${import_chalk5.default.bold("null")}.${undefinedTip}`;
      }
      if (error2.type === "missingArg") {
        const forStr = path6.length === 1 && path6[0] === error2.missingName ? "" : ` for ${import_chalk5.default.bold(`${path6.join(".")}`)}`;
        return `Argument ${import_chalk5.default.greenBright(error2.missingName)}${forStr} is missing.`;
      }
      if (error2.type === "atLeastOne") {
        const additional = minimal ? "" : ` Available args are listed in ${import_chalk5.default.dim.green("green")}.`;
        return `Argument ${import_chalk5.default.bold(path6.join("."))} of type ${import_chalk5.default.bold(error2.inputType.name)} needs ${import_chalk5.default.greenBright("at least one")} argument.${additional}`;
      }
      if (error2.type === "atMostOne") {
        const additional = minimal ? "" : ` Please choose one. ${import_chalk5.default.dim("Available args:")} 
${stringifyInputType(error2.inputType, true)}`;
        return `Argument ${import_chalk5.default.bold(path6.join("."))} of type ${import_chalk5.default.bold(error2.inputType.name)} needs ${import_chalk5.default.greenBright("exactly one")} argument, but you provided ${error2.providedKeys.map((key) => import_chalk5.default.redBright(key)).join(" and ")}.${additional}`;
      }
      return void 0;
    };
    this.type = type;
    this.children = children;
  }
  get [Symbol.toStringTag]() {
    return "Document";
  }
  toString() {
    return `${this.type} {
${(0, import_indent_string2.default)(this.children.map(String).join("\n"), tab)}
}`;
  }
  validate(select, isTopLevelQuery = false, originalMethod, errorFormat, validationCallsite) {
    if (!select) {
      select = {};
    }
    const invalidChildren = this.children.filter((child) => child.hasInvalidChild || child.hasInvalidArg);
    if (invalidChildren.length === 0) {
      return;
    }
    const fieldErrors = [];
    const argErrors = [];
    const prefix = select && select.select ? "select" : select.include ? "include" : void 0;
    for (const child of invalidChildren) {
      const errors2 = child.collectErrors(prefix);
      fieldErrors.push(...errors2.fieldErrors.map((e) => ({
        ...e,
        path: isTopLevelQuery ? e.path : e.path.slice(1)
      })));
      argErrors.push(...errors2.argErrors.map((e) => ({
        ...e,
        path: isTopLevelQuery ? e.path : e.path.slice(1)
      })));
    }
    const topLevelQueryName = this.children[0].name;
    const queryName = isTopLevelQuery ? this.type : topLevelQueryName;
    const keyPaths = [];
    const valuePaths = [];
    const missingItems = [];
    for (const fieldError of fieldErrors) {
      const path6 = this.normalizePath(fieldError.path, select).join(".");
      if (fieldError.error.type === "invalidFieldName") {
        keyPaths.push(path6);
        const fieldType = fieldError.error.outputType;
        const { isInclude } = fieldError.error;
        fieldType.fields.filter((field) => isInclude ? field.outputType.location === "outputObjectTypes" : true).forEach((field) => {
          const splittedPath = path6.split(".");
          missingItems.push({
            path: `${splittedPath.slice(0, splittedPath.length - 1).join(".")}.${field.name}`,
            type: "true",
            isRequired: false
          });
        });
      } else if (fieldError.error.type === "includeAndSelect") {
        keyPaths.push("select");
        keyPaths.push("include");
      } else {
        valuePaths.push(path6);
      }
      if (fieldError.error.type === "emptySelect" || fieldError.error.type === "noTrueSelect" || fieldError.error.type === "emptyInclude") {
        const selectPathArray = this.normalizePath(fieldError.path, select);
        const selectPath = selectPathArray.slice(0, selectPathArray.length - 1).join(".");
        const fieldType = fieldError.error.field.outputType.type;
        fieldType.fields?.filter((field) => fieldError.error.type === "emptyInclude" ? field.outputType.location === "outputObjectTypes" : true).forEach((field) => {
          missingItems.push({
            path: `${selectPath}.${field.name}`,
            type: "true",
            isRequired: false
          });
        });
      }
    }
    for (const argError of argErrors) {
      const path6 = this.normalizePath(argError.path, select).join(".");
      if (argError.error.type === "invalidName") {
        keyPaths.push(path6);
      } else if (argError.error.type !== "missingArg" && argError.error.type !== "atLeastOne") {
        valuePaths.push(path6);
      } else if (argError.error.type === "missingArg") {
        const type = argError.error.missingArg.inputTypes.length === 1 ? argError.error.missingArg.inputTypes[0].type : argError.error.missingArg.inputTypes.map((t) => {
          const inputTypeName = getInputTypeName(t.type);
          if (inputTypeName === "Null") {
            return "null";
          }
          if (t.isList) {
            return inputTypeName + "[]";
          }
          return inputTypeName;
        }).join(" | ");
        missingItems.push({
          path: path6,
          type: inputTypeToJson(type, true, path6.split("where.").length === 2),
          isRequired: argError.error.missingArg.isRequired
        });
      }
    }
    const renderErrorStr = /* @__PURE__ */ __name((callsite) => {
      const hasRequiredMissingArgsErrors = argErrors.some((e) => e.error.type === "missingArg" && e.error.missingArg.isRequired);
      const hasOptionalMissingArgsErrors = Boolean(argErrors.find((e) => e.error.type === "missingArg" && !e.error.missingArg.isRequired));
      const hasMissingArgsErrors = hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors;
      let missingArgsLegend = "";
      if (hasRequiredMissingArgsErrors) {
        missingArgsLegend += `
${import_chalk5.default.dim("Note: Lines with ")}${import_chalk5.default.reset.greenBright("+")} ${import_chalk5.default.dim("are required")}`;
      }
      if (hasOptionalMissingArgsErrors) {
        if (missingArgsLegend.length === 0) {
          missingArgsLegend = "\n";
        }
        if (hasRequiredMissingArgsErrors) {
          missingArgsLegend += import_chalk5.default.dim(`, lines with ${import_chalk5.default.green("?")} are optional`);
        } else {
          missingArgsLegend += import_chalk5.default.dim(`Note: Lines with ${import_chalk5.default.green("?")} are optional`);
        }
        missingArgsLegend += import_chalk5.default.dim(".");
      }
      const relevantArgErrors = argErrors.filter((e) => e.error.type !== "missingArg" || e.error.missingArg.isRequired);
      let errorMessages = relevantArgErrors.map((e) => this.printArgError(e, hasMissingArgsErrors, errorFormat === "minimal")).join("\n");
      errorMessages += `
${fieldErrors.map((e) => this.printFieldError(e, missingItems, errorFormat === "minimal")).join("\n")}`;
      if (errorFormat === "minimal") {
        return (0, import_strip_ansi2.default)(errorMessages);
      }
      const {
        stack,
        indent: indentValue,
        afterLines
      } = printStack({
        callsite,
        originalMethod: originalMethod || queryName,
        showColors: errorFormat && errorFormat === "pretty",
        isValidationError: true
      });
      let printJsonArgs = {
        ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,
        keyPaths,
        valuePaths,
        missingItems
      };
      if (originalMethod?.endsWith("aggregate")) {
        printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs);
      }
      const errorStr = `${stack}${(0, import_indent_string2.default)(printJsonWithErrors(printJsonArgs), indentValue).slice(indentValue)}${import_chalk5.default.dim(afterLines)}

${errorMessages}${missingArgsLegend}
`;
      if (process.env.NO_COLOR || errorFormat === "colorless") {
        return (0, import_strip_ansi2.default)(errorStr);
      }
      return errorStr;
    }, "renderErrorStr");
    const error2 = new PrismaClientValidationError(renderErrorStr(validationCallsite));
    if (process.env.NODE_ENV !== "production") {
      Object.defineProperty(error2, "render", {
        get: () => renderErrorStr,
        enumerable: false
      });
    }
    throw error2;
  }
  normalizePath(inputPath, select) {
    const path6 = inputPath.slice();
    const newPath = [];
    let key;
    let pointer = select;
    while ((key = path6.shift()) !== void 0) {
      if (!Array.isArray(pointer) && key === 0) {
        continue;
      }
      if (key === "select") {
        if (!pointer[key]) {
          pointer = pointer.include;
        } else {
          pointer = pointer[key];
        }
      } else if (pointer && pointer[key]) {
        pointer = pointer[key];
      }
      newPath.push(key);
    }
    return newPath;
  }
};
__name(Document, "Document");
var PrismaClientValidationError = class extends Error {
  get [Symbol.toStringTag]() {
    return "PrismaClientValidationError";
  }
};
__name(PrismaClientValidationError, "PrismaClientValidationError");
var PrismaClientConstructorValidationError = class extends Error {
  constructor(message) {
    super(message + `
Read more at https://pris.ly/d/client-constructor`);
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientConstructorValidationError";
  }
};
__name(PrismaClientConstructorValidationError, "PrismaClientConstructorValidationError");
var Field = class {
  constructor({ name, args, children, error: error2, schemaField }) {
    this.name = name;
    this.args = args;
    this.children = children;
    this.error = error2;
    this.schemaField = schemaField;
    this.hasInvalidChild = children ? children.some((child) => Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild)) : false;
    this.hasInvalidArg = args ? args.hasInvalidArg : false;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    let str = this.name;
    if (this.error) {
      return str + " # INVALID_FIELD";
    }
    if (this.args && this.args.args && this.args.args.length > 0) {
      if (this.args.args.length === 1) {
        str += `(${this.args.toString()})`;
      } else {
        str += `(
${(0, import_indent_string2.default)(this.args.toString(), tab)}
)`;
      }
    }
    if (this.children) {
      str += ` {
${(0, import_indent_string2.default)(this.children.map(String).join("\n"), tab)}
}`;
    }
    return str;
  }
  collectErrors(prefix = "select") {
    const fieldErrors = [];
    const argErrors = [];
    if (this.error) {
      fieldErrors.push({
        path: [this.name],
        error: this.error
      });
    }
    if (this.children) {
      for (const child of this.children) {
        const errors2 = child.collectErrors(prefix);
        fieldErrors.push(...errors2.fieldErrors.map((e) => ({
          ...e,
          path: [this.name, prefix, ...e.path]
        })));
        argErrors.push(...errors2.argErrors.map((e) => ({
          ...e,
          path: [this.name, prefix, ...e.path]
        })));
      }
    }
    if (this.args) {
      argErrors.push(...this.args.collectErrors().map((e) => ({ ...e, path: [this.name, ...e.path] })));
    }
    return {
      fieldErrors,
      argErrors
    };
  }
};
__name(Field, "Field");
var Args = class {
  constructor(args = []) {
    this.args = args;
    this.hasInvalidArg = args ? args.some((arg2) => Boolean(arg2.hasError)) : false;
  }
  get [Symbol.toStringTag]() {
    return "Args";
  }
  toString() {
    if (this.args.length === 0) {
      return "";
    }
    return `${this.args.map((arg2) => arg2.toString()).filter((a) => a).join("\n")}`;
  }
  collectErrors() {
    if (!this.hasInvalidArg) {
      return [];
    }
    return flatMap(this.args, (arg2) => arg2.collectErrors());
  }
};
__name(Args, "Args");
function stringify(value, inputType) {
  if (Buffer.isBuffer(value)) {
    return JSON.stringify(value.toString("base64"));
  }
  if (Object.prototype.toString.call(value) === "[object BigInt]") {
    return value.toString();
  }
  if (typeof inputType?.type === "string" && inputType.type === "Json") {
    if (value === null) {
      return "null";
    }
    if (value && value.values && value.__prismaRawParamaters__) {
      return JSON.stringify(value.values);
    }
    if (inputType?.isList && Array.isArray(value)) {
      return JSON.stringify(value.map((o) => JSON.stringify(o)));
    }
    return JSON.stringify(JSON.stringify(value));
  }
  if (value === void 0) {
    return null;
  }
  if (value === null) {
    return "null";
  }
  if (decimal_default.isDecimal(value)) {
    return value.toString();
  }
  if (inputType?.location === "enumTypes" && typeof value === "string") {
    if (Array.isArray(value)) {
      return `[${value.join(", ")}]`;
    }
    return value;
  }
  return JSON.stringify(value, null, 2);
}
__name(stringify, "stringify");
var Arg = class {
  constructor({ key, value, isEnum = false, error: error2, schemaArg, inputType }) {
    this.inputType = inputType;
    this.key = key;
    this.value = value;
    this.isEnum = isEnum;
    this.error = error2;
    this.schemaArg = schemaArg;
    this.isNullable = schemaArg?.inputTypes.reduce((isNullable) => isNullable && schemaArg.isNullable, true) || false;
    this.hasError = Boolean(error2) || (value instanceof Args ? value.hasInvalidArg : false) || Array.isArray(value) && value.some((v) => v instanceof Args ? v.hasInvalidArg : false);
  }
  get [Symbol.toStringTag]() {
    return "Arg";
  }
  _toString(value, key) {
    if (typeof value === "undefined") {
      return void 0;
    }
    if (value instanceof Args) {
      return `${key}: {
${(0, import_indent_string2.default)(value.toString(), 2)}
}`;
    }
    if (Array.isArray(value)) {
      if (this.inputType?.type === "Json") {
        return `${key}: ${stringify(value, this.inputType)}`;
      }
      const isScalar = !value.some((v) => typeof v === "object");
      return `${key}: [${isScalar ? "" : "\n"}${(0, import_indent_string2.default)(value.map((nestedValue) => {
        if (nestedValue instanceof Args) {
          return `{
${(0, import_indent_string2.default)(nestedValue.toString(), tab)}
}`;
        }
        return stringify(nestedValue, this.inputType);
      }).join(`,${isScalar ? " " : "\n"}`), isScalar ? 0 : tab)}${isScalar ? "" : "\n"}]`;
    }
    return `${key}: ${stringify(value, this.inputType)}`;
  }
  toString() {
    return this._toString(this.value, this.key);
  }
  collectErrors() {
    if (!this.hasError) {
      return [];
    }
    const errors2 = [];
    if (this.error) {
      const id = typeof this.inputType?.type === "object" ? `${this.inputType.type.name}${this.inputType.isList ? "[]" : ""}` : void 0;
      errors2.push({
        error: this.error,
        path: [this.key],
        id
      });
    }
    if (Array.isArray(this.value)) {
      errors2.push(...flatMap(this.value, (val, index) => {
        if (!val?.collectErrors) {
          return [];
        }
        return val.collectErrors().map((e) => {
          return { ...e, path: [this.key, index, ...e.path] };
        });
      }));
    }
    if (this.value instanceof Args) {
      errors2.push(...this.value.collectErrors().map((e) => ({ ...e, path: [this.key, ...e.path] })));
    }
    return errors2;
  }
};
__name(Arg, "Arg");
function makeDocument({ dmmf, rootTypeName, rootField, select }) {
  if (!select) {
    select = {};
  }
  const rootType = rootTypeName === "query" ? dmmf.queryType : dmmf.mutationType;
  const fakeRootField = {
    args: [],
    outputType: {
      isList: false,
      type: rootType,
      location: "outputObjectTypes"
    },
    name: rootTypeName
  };
  const children = selectionToFields(dmmf, { [rootField]: select }, fakeRootField, [rootTypeName]);
  return new Document(rootTypeName, children);
}
__name(makeDocument, "makeDocument");
function transformDocument(document2) {
  return document2;
}
__name(transformDocument, "transformDocument");
function selectionToFields(dmmf, selection, schemaField, path6) {
  const outputType = schemaField.outputType.type;
  return Object.entries(selection).reduce((acc, [name, value]) => {
    const field = outputType.fieldMap ? outputType.fieldMap[name] : outputType.fields.find((f) => f.name === name);
    if (!field) {
      acc.push(new Field({
        name,
        children: [],
        error: {
          type: "invalidFieldName",
          modelName: outputType.name,
          providedName: name,
          didYouMean: getSuggestion(name, outputType.fields.map((f) => f.name)),
          outputType
        }
      }));
      return acc;
    }
    if (typeof value !== "boolean" && field.outputType.location === "scalar" && field.name !== "executeRaw" && field.name !== "queryRaw" && outputType.name !== "Query" && !name.startsWith("aggregate") && field.name !== "count") {
      acc.push(new Field({
        name,
        children: [],
        error: {
          type: "invalidFieldType",
          modelName: outputType.name,
          fieldName: name,
          providedValue: value
        }
      }));
      return acc;
    }
    if (value === false) {
      return acc;
    }
    const transformedField = {
      name: field.name,
      fields: field.args,
      constraints: {
        minNumFields: null,
        maxNumFields: null
      }
    };
    const argsWithoutIncludeAndSelect = typeof value === "object" ? omit(value, ["include", "select"]) : void 0;
    const args = argsWithoutIncludeAndSelect ? objectToArgs(argsWithoutIncludeAndSelect, transformedField, [], typeof field === "string" ? void 0 : field.outputType.type) : void 0;
    const isRelation = field.outputType.location === "outputObjectTypes";
    if (value) {
      if (value.select && value.include) {
        acc.push(new Field({
          name,
          children: [
            new Field({
              name: "include",
              args: new Args(),
              error: {
                type: "includeAndSelect",
                field
              }
            })
          ]
        }));
      } else if (value.include) {
        const keys2 = Object.keys(value.include);
        if (keys2.length === 0) {
          acc.push(new Field({
            name,
            children: [
              new Field({
                name: "include",
                args: new Args(),
                error: {
                  type: "emptyInclude",
                  field
                }
              })
            ]
          }));
          return acc;
        }
        if (field.outputType.location === "outputObjectTypes") {
          const fieldOutputType = field.outputType.type;
          const allowedKeys = fieldOutputType.fields.filter((f) => f.outputType.location === "outputObjectTypes").map((f) => f.name);
          const invalidKeys = keys2.filter((key) => !allowedKeys.includes(key));
          if (invalidKeys.length > 0) {
            acc.push(...invalidKeys.map((invalidKey) => new Field({
              name: invalidKey,
              children: [
                new Field({
                  name: invalidKey,
                  args: new Args(),
                  error: {
                    type: "invalidFieldName",
                    modelName: fieldOutputType.name,
                    outputType: fieldOutputType,
                    providedName: invalidKey,
                    didYouMean: getSuggestion(invalidKey, allowedKeys) || void 0,
                    isInclude: true,
                    isIncludeScalar: fieldOutputType.fields.some((f) => f.name === invalidKey)
                  }
                })
              ]
            })));
            return acc;
          }
        }
      } else if (value.select) {
        const values = Object.values(value.select);
        if (values.length === 0) {
          acc.push(new Field({
            name,
            children: [
              new Field({
                name: "select",
                args: new Args(),
                error: {
                  type: "emptySelect",
                  field
                }
              })
            ]
          }));
          return acc;
        }
        const truthyValues = values.filter((v) => v);
        if (truthyValues.length === 0) {
          acc.push(new Field({
            name,
            children: [
              new Field({
                name: "select",
                args: new Args(),
                error: {
                  type: "noTrueSelect",
                  field
                }
              })
            ]
          }));
          return acc;
        }
      }
    }
    const defaultSelection = isRelation ? getDefaultSelection(field.outputType.type) : null;
    let select = defaultSelection;
    if (value) {
      if (value.select) {
        select = value.select;
      } else if (value.include) {
        select = deepExtend(defaultSelection, value.include);
      } else if (value.by && Array.isArray(value.by) && field.outputType.namespace === "prisma" && field.outputType.location === "outputObjectTypes" && isGroupByOutputName(field.outputType.type.name)) {
        select = byToSelect(value.by);
      }
    }
    const children = select !== false && isRelation ? selectionToFields(dmmf, select, field, [...path6, name]) : void 0;
    acc.push(new Field({ name, args, children, schemaField: field }));
    return acc;
  }, []);
}
__name(selectionToFields, "selectionToFields");
function byToSelect(by) {
  const obj = Object.create(null);
  for (const b of by) {
    obj[b] = true;
  }
  return obj;
}
__name(byToSelect, "byToSelect");
function getDefaultSelection(outputType) {
  const acc = Object.create(null);
  for (const f of outputType.fields) {
    if (f.outputType.location === "scalar" || f.outputType.location === "enumTypes") {
      acc[f.name] = true;
    }
  }
  return acc;
}
__name(getDefaultSelection, "getDefaultSelection");
function getInvalidTypeArg(key, value, arg2, bestFittingType) {
  const arrg = new Arg({
    key,
    value,
    isEnum: bestFittingType.location === "enumTypes",
    inputType: bestFittingType,
    error: {
      type: "invalidType",
      providedValue: value,
      argName: key,
      requiredType: {
        inputType: arg2.inputTypes,
        bestFittingType
      }
    }
  });
  return arrg;
}
__name(getInvalidTypeArg, "getInvalidTypeArg");
function hasCorrectScalarType(value, arg2, inputType) {
  const { type, isList } = inputType;
  const expectedType = wrapWithList(stringifyGraphQLType(type), isList);
  const graphQLType = getGraphQLType(value, type);
  if (graphQLType === expectedType) {
    return true;
  }
  if (isList && graphQLType === "List<>") {
    return true;
  }
  if (expectedType === "Json") {
    return true;
  }
  if (graphQLType === "Int" && expectedType === "BigInt") {
    return true;
  }
  if (graphQLType === "List<Int>" && expectedType === "List<BigInt>") {
    return true;
  }
  if (graphQLType === "List<BigInt | Int>" && expectedType === "List<BigInt>") {
    return true;
  }
  if (graphQLType === "List<Int | BigInt>" && expectedType === "List<BigInt>") {
    return true;
  }
  if ((graphQLType === "Int" || graphQLType === "Float") && expectedType === "Decimal") {
    return true;
  }
  if ((graphQLType === "List<Int>" || graphQLType === "List<Float>") && expectedType === "List<Decimal>") {
    return true;
  }
  if (graphQLType === "DateTime" && expectedType === "String") {
    return true;
  }
  if (graphQLType === "List<DateTime>" && expectedType === "List<String>") {
    return true;
  }
  if (graphQLType === "UUID" && expectedType === "String") {
    return true;
  }
  if (graphQLType === "List<UUID>" && expectedType === "List<String>") {
    return true;
  }
  if (graphQLType === "String" && expectedType === "ID") {
    return true;
  }
  if (graphQLType === "List<String>" && expectedType === "List<ID>") {
    return true;
  }
  if (graphQLType === "List<String>" && expectedType === "List<Json>") {
    return true;
  }
  if (expectedType === "List<String>" && (graphQLType === "List<String | UUID>" || graphQLType === "List<UUID | String>")) {
    return true;
  }
  if (graphQLType === "Int" && expectedType === "Float") {
    return true;
  }
  if (graphQLType === "List<Int>" && expectedType === "List<Float>") {
    return true;
  }
  if (graphQLType === "Int" && expectedType === "Long") {
    return true;
  }
  if (graphQLType === "List<Int>" && expectedType === "List<Long>") {
    return true;
  }
  if (graphQLType === "String" && expectedType === "Decimal" && /^\-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i.test(value)) {
    return true;
  }
  if (!arg2.isRequired && value === null) {
    return true;
  }
  return false;
}
__name(hasCorrectScalarType, "hasCorrectScalarType");
var cleanObject = /* @__PURE__ */ __name((obj) => filterObject(obj, (k, v) => v !== void 0), "cleanObject");
function valueToArg(key, value, arg2) {
  let maybeArg = null;
  const argsWithErrors = [];
  for (const inputType of arg2.inputTypes) {
    maybeArg = tryInferArgs(key, value, arg2, inputType);
    if (maybeArg?.collectErrors().length === 0) {
      return maybeArg;
    }
    if (maybeArg && maybeArg?.collectErrors()) {
      const argErrors = maybeArg?.collectErrors();
      if (argErrors && argErrors.length > 0) {
        argsWithErrors.push({ arg: maybeArg, errors: argErrors });
      }
    }
  }
  if (maybeArg?.hasError && argsWithErrors.length > 0) {
    const argsWithScores = argsWithErrors.map(({ arg: arg3, errors: errors2 }) => {
      const errorScores = errors2.map((e) => {
        let score = 1;
        if (e.error.type === "invalidType") {
          score = 2 * Math.exp(getDepth(e.error.providedValue)) + 1;
        }
        score += Math.log(e.path.length);
        if (e.error.type === "missingArg") {
          if (arg3.inputType && isInputArgType(arg3.inputType.type) && arg3.inputType.type.name.includes("Unchecked")) {
            score *= 2;
          }
        }
        if (e.error.type === "invalidName") {
          if (isInputArgType(e.error.originalType)) {
            if (e.error.originalType.name.includes("Unchecked")) {
              score *= 2;
            }
          }
        }
        return score;
      });
      return {
        score: errors2.length + sum2(errorScores),
        arg: arg3,
        errors: errors2
      };
    });
    argsWithScores.sort((a, b) => a.score < b.score ? -1 : 1);
    return argsWithScores[0].arg;
  }
  return maybeArg;
}
__name(valueToArg, "valueToArg");
function getDepth(object) {
  let level = 1;
  if (!object || typeof object !== "object") {
    return level;
  }
  for (const key in object) {
    if (!Object.prototype.hasOwnProperty.call(object, key)) {
      continue;
    }
    if (typeof object[key] === "object") {
      const depth = getDepth(object[key]) + 1;
      level = Math.max(depth, level);
    }
  }
  return level;
}
__name(getDepth, "getDepth");
function sum2(n) {
  return n.reduce((acc, curr) => acc + curr, 0);
}
__name(sum2, "sum");
function tryInferArgs(key, value, arg2, inputType) {
  if (typeof value === "undefined") {
    if (!arg2.isRequired) {
      return null;
    }
    return new Arg({
      key,
      value,
      isEnum: inputType.location === "enumTypes",
      inputType,
      error: {
        type: "missingArg",
        missingName: key,
        missingArg: arg2,
        atLeastOne: false,
        atMostOne: false
      }
    });
  }
  const { isNullable, isRequired } = arg2;
  if (value === null && !isNullable && !isRequired) {
    const isAtLeastOne = isInputArgType(inputType.type) ? inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0 : false;
    if (!isAtLeastOne) {
      return new Arg({
        key,
        value,
        isEnum: inputType.location === "enumTypes",
        inputType,
        error: {
          type: "invalidNullArg",
          name: key,
          invalidType: arg2.inputTypes,
          atLeastOne: false,
          atMostOne: false
        }
      });
    }
  }
  if (!inputType.isList) {
    if (isInputArgType(inputType.type)) {
      if (typeof value !== "object" || Array.isArray(value) || inputType.location === "inputObjectTypes" && !isObject(value)) {
        return getInvalidTypeArg(key, value, arg2, inputType);
      } else {
        const val = cleanObject(value);
        let error2;
        const keys2 = Object.keys(val || {});
        const numKeys = keys2.length;
        if (numKeys === 0 && typeof inputType.type.constraints.minNumFields === "number" && inputType.type.constraints.minNumFields > 0) {
          error2 = {
            type: "atLeastOne",
            key,
            inputType: inputType.type
          };
        } else if (numKeys > 1 && typeof inputType.type.constraints.maxNumFields === "number" && inputType.type.constraints.maxNumFields < 2) {
          error2 = {
            type: "atMostOne",
            key,
            inputType: inputType.type,
            providedKeys: keys2
          };
        }
        return new Arg({
          key,
          value: val === null ? null : objectToArgs(val, inputType.type, arg2.inputTypes),
          isEnum: inputType.location === "enumTypes",
          error: error2,
          inputType,
          schemaArg: arg2
        });
      }
    } else {
      return scalarToArg(key, value, arg2, inputType);
    }
  }
  if (!Array.isArray(value) && inputType.isList) {
    if (key !== "updateMany") {
      value = [value];
    }
  }
  if (inputType.location === "enumTypes" || inputType.location === "scalar") {
    return scalarToArg(key, value, arg2, inputType);
  }
  const argInputType = inputType.type;
  const hasAtLeastOneError = typeof argInputType.constraints?.minNumFields === "number" && argInputType.constraints?.minNumFields > 0 ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0) : false;
  let err = hasAtLeastOneError ? {
    inputType: argInputType,
    key,
    type: "atLeastOne"
  } : void 0;
  if (!err) {
    const hasOneOfError = typeof argInputType.constraints?.maxNumFields === "number" && argInputType.constraints?.maxNumFields < 2 ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1) : false;
    if (hasOneOfError) {
      err = {
        inputType: argInputType,
        key,
        type: "atMostOne",
        providedKeys: Object.keys(hasOneOfError)
      };
    }
  }
  if (!Array.isArray(value)) {
    for (const nestedArgInputType of arg2.inputTypes) {
      const args = objectToArgs(value, nestedArgInputType.type);
      if (args.collectErrors().length === 0) {
        return new Arg({
          key,
          value: args,
          isEnum: false,
          schemaArg: arg2,
          inputType: nestedArgInputType
        });
      }
    }
  }
  return new Arg({
    key,
    value: value.map((v) => {
      if (inputType.isList && typeof v !== "object") {
        return v;
      }
      if (typeof v !== "object" || !value) {
        return getInvalidTypeArg(key, v, arg2, inputType);
      }
      return objectToArgs(v, argInputType);
    }),
    isEnum: false,
    inputType,
    schemaArg: arg2,
    error: err
  });
}
__name(tryInferArgs, "tryInferArgs");
function isInputArgType(argType) {
  if (typeof argType === "string") {
    return false;
  }
  if (Object.hasOwnProperty.call(argType, "values")) {
    return false;
  }
  return true;
}
__name(isInputArgType, "isInputArgType");
function scalarToArg(key, value, arg2, inputType) {
  if (hasCorrectScalarType(value, arg2, inputType)) {
    return new Arg({
      key,
      value,
      isEnum: inputType.location === "enumTypes",
      schemaArg: arg2,
      inputType
    });
  }
  return getInvalidTypeArg(key, value, arg2, inputType);
}
__name(scalarToArg, "scalarToArg");
function objectToArgs(initialObj, inputType, possibilities, outputType) {
  const obj = cleanObject(initialObj);
  const { fields: args, fieldMap } = inputType;
  const requiredArgs = args.map((arg2) => [arg2.name, void 0]);
  const objEntries = Object.entries(obj || {});
  const entries = unionBy(objEntries, requiredArgs, (a) => a[0]);
  const argsList = entries.reduce((acc, [argName, value]) => {
    const schemaArg = fieldMap ? fieldMap[argName] : args.find((a) => a.name === argName);
    if (!schemaArg) {
      const didYouMeanField = typeof value === "boolean" && outputType && outputType.fields.some((f) => f.name === argName) ? argName : null;
      acc.push(new Arg({
        key: argName,
        value,
        error: {
          type: "invalidName",
          providedName: argName,
          providedValue: value,
          didYouMeanField,
          didYouMeanArg: !didYouMeanField && getSuggestion(argName, [...args.map((a) => a.name), "select"]) || void 0,
          originalType: inputType,
          possibilities,
          outputType
        }
      }));
      return acc;
    }
    const arg2 = valueToArg(argName, value, schemaArg);
    if (arg2) {
      acc.push(arg2);
    }
    return acc;
  }, []);
  if (typeof inputType.constraints.minNumFields === "number" && objEntries.length < inputType.constraints.minNumFields || argsList.find((arg2) => arg2.error?.type === "missingArg" || arg2.error?.type === "atLeastOne")) {
    const optionalMissingArgs = inputType.fields.filter((field) => !field.isRequired && obj && (typeof obj[field.name] === "undefined" || obj[field.name] === null));
    argsList.push(...optionalMissingArgs.map((arg2) => {
      const argInputType = arg2.inputTypes[0];
      return new Arg({
        key: arg2.name,
        value: void 0,
        isEnum: argInputType.location === "enumTypes",
        error: {
          type: "missingArg",
          missingName: arg2.name,
          missingArg: arg2,
          atLeastOne: Boolean(inputType.constraints.minNumFields) || false,
          atMostOne: inputType.constraints.maxNumFields === 1 || false
        },
        inputType: argInputType
      });
    }));
  }
  return new Args(argsList);
}
__name(objectToArgs, "objectToArgs");
function unpack({ document: document2, path: path6, data }) {
  const result = deepGet(data, path6);
  if (result === "undefined") {
    return null;
  }
  if (typeof result !== "object") {
    return result;
  }
  const field = getField(document2, path6);
  return mapScalars({ field, data: result });
}
__name(unpack, "unpack");
function mapScalars({ field, data }) {
  if (!data || typeof data !== "object" || !field.children || !field.schemaField) {
    return data;
  }
  const deserializers = {
    DateTime: (value) => new Date(value),
    Json: (value) => JSON.parse(value),
    Bytes: (value) => Buffer.from(value, "base64"),
    Decimal: (value) => {
      return new decimal_default(value);
    },
    BigInt: (value) => BigInt(value)
  };
  for (const child of field.children) {
    const outputType = child.schemaField?.outputType.type;
    if (outputType && typeof outputType === "string") {
      const deserializer = deserializers[outputType];
      if (deserializer) {
        if (Array.isArray(data)) {
          for (const entry of data) {
            if (typeof entry[child.name] !== "undefined" && entry[child.name] !== null) {
              if (Array.isArray(entry[child.name])) {
                entry[child.name] = entry[child.name].map(deserializer);
              } else {
                entry[child.name] = deserializer(entry[child.name]);
              }
            }
          }
        } else {
          if (typeof data[child.name] !== "undefined" && data[child.name] !== null) {
            if (Array.isArray(data[child.name])) {
              data[child.name] = data[child.name].map(deserializer);
            } else {
              data[child.name] = deserializer(data[child.name]);
            }
          }
        }
      }
    }
    if (child.schemaField && child.schemaField.outputType.location === "outputObjectTypes") {
      if (Array.isArray(data)) {
        for (const entry of data) {
          mapScalars({ field: child, data: entry[child.name] });
        }
      } else {
        mapScalars({ field: child, data: data[child.name] });
      }
    }
  }
  return data;
}
__name(mapScalars, "mapScalars");
function getField(document2, path6) {
  const todo = path6.slice();
  const firstElement = todo.shift();
  let pointer = document2.children.find((c) => c.name === firstElement);
  if (!pointer) {
    throw new Error(`Could not find field ${firstElement} in document ${document2}`);
  }
  while (todo.length > 0) {
    const key = todo.shift();
    if (!pointer.children) {
      throw new Error(`Can't get children for field ${pointer} with child ${key}`);
    }
    const child = pointer.children.find((c) => c.name === key);
    if (!child) {
      throw new Error(`Can't find child ${key} of field ${pointer}`);
    }
    pointer = child;
  }
  return pointer;
}
__name(getField, "getField");
function removeSelectFromPath(path6) {
  return path6.split(".").filter((p) => p !== "select").join(".");
}
__name(removeSelectFromPath, "removeSelectFromPath");
function removeSelectFromObject(obj) {
  const type = Object.prototype.toString.call(obj);
  if (type === "[object Object]") {
    const copy = {};
    for (const key in obj) {
      if (key === "select") {
        for (const subKey in obj["select"]) {
          copy[subKey] = removeSelectFromObject(obj["select"][subKey]);
        }
      } else {
        copy[key] = removeSelectFromObject(obj[key]);
      }
    }
    return copy;
  }
  return obj;
}
__name(removeSelectFromObject, "removeSelectFromObject");
function transformAggregatePrintJsonArgs({
  ast,
  keyPaths,
  missingItems,
  valuePaths
}) {
  const newKeyPaths = keyPaths.map(removeSelectFromPath);
  const newValuePaths = valuePaths.map(removeSelectFromPath);
  const newMissingItems = missingItems.map((item) => ({
    path: removeSelectFromPath(item.path),
    isRequired: item.isRequired,
    type: item.type
  }));
  const newAst = removeSelectFromObject(ast);
  return {
    ast: newAst,
    keyPaths: newKeyPaths,
    missingItems: newMissingItems,
    valuePaths: newValuePaths
  };
}
__name(transformAggregatePrintJsonArgs, "transformAggregatePrintJsonArgs");

// ../engine-core/dist/esm/common/errors/PrismaClientInitializationError.mjs
var __defProp3 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp3(target, "name", { value, configurable: true }), "__name");
var PrismaClientInitializationError = class extends Error {
  constructor(message, clientVersion2, errorCode) {
    super(message);
    this.clientVersion = clientVersion2;
    this.errorCode = errorCode;
    Error.captureStackTrace(PrismaClientInitializationError);
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientInitializationError";
  }
};
__name(PrismaClientInitializationError, "PrismaClientInitializationError");
__name2(PrismaClientInitializationError, "PrismaClientInitializationError");

// ../engine-core/dist/esm/common/errors/PrismaClientKnownRequestError.mjs
var __defProp4 = Object.defineProperty;
var __name3 = /* @__PURE__ */ __name((target, value) => __defProp4(target, "name", { value, configurable: true }), "__name");
var PrismaClientKnownRequestError = class extends Error {
  constructor(message, code, clientVersion2, meta) {
    super(message);
    this.code = code;
    this.clientVersion = clientVersion2;
    this.meta = meta;
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientKnownRequestError";
  }
};
__name(PrismaClientKnownRequestError, "PrismaClientKnownRequestError");
__name3(PrismaClientKnownRequestError, "PrismaClientKnownRequestError");

// ../engine-core/dist/esm/common/errors/PrismaClientRustPanicError.mjs
var __defProp5 = Object.defineProperty;
var __name4 = /* @__PURE__ */ __name((target, value) => __defProp5(target, "name", { value, configurable: true }), "__name");
var PrismaClientRustPanicError = class extends Error {
  constructor(message, clientVersion2) {
    super(message);
    this.clientVersion = clientVersion2;
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientRustPanicError";
  }
};
__name(PrismaClientRustPanicError, "PrismaClientRustPanicError");
__name4(PrismaClientRustPanicError, "PrismaClientRustPanicError");

// ../engine-core/dist/esm/common/errors/PrismaClientUnknownRequestError.mjs
var __defProp6 = Object.defineProperty;
var __name5 = /* @__PURE__ */ __name((target, value) => __defProp6(target, "name", { value, configurable: true }), "__name");
var PrismaClientUnknownRequestError = class extends Error {
  constructor(message, clientVersion2) {
    super(message);
    this.clientVersion = clientVersion2;
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientUnknownRequestError";
  }
};
__name(PrismaClientUnknownRequestError, "PrismaClientUnknownRequestError");
__name5(PrismaClientUnknownRequestError, "PrismaClientUnknownRequestError");

// ../engine-core/dist/esm/common/Engine.mjs
var __defProp7 = Object.defineProperty;
var __name6 = /* @__PURE__ */ __name((target, value) => __defProp7(target, "name", { value, configurable: true }), "__name");
var Engine = class {
};
__name(Engine, "Engine");
__name6(Engine, "Engine");

// ../engine-core/dist/esm/library/LibraryEngine.mjs
var import_debug4 = __toModule2(require_dist7());
var import_engines = __toModule2(require_dist8());
var import_get_platform = __toModule2(require_dist9());
var import_chalk7 = __toModule2(require_source2());
import EventEmitter from "events";
import fs2 from "fs";
import path from "path";

// ../engine-core/dist/esm/common/errors/utils/getErrorMessageWithLink.mjs
var import_debug3 = __toModule2(require_dist7());

// ../engine-core/dist/esm/common/utils/util.mjs
var import_terminal_link = __toModule2(require_terminal_link());
var import_new_github_issue_url = __toModule2(require_new_github_issue_url());
var import_chalk6 = __toModule2(require_source2());
var import_debug2 = __toModule2(require_dist7());
import fs from "fs";
import crypto2 from "crypto";
var __defProp8 = Object.defineProperty;
var __name7 = /* @__PURE__ */ __name((target, value) => __defProp8(target, "name", { value, configurable: true }), "__name");
var debug3 = (0, import_debug2.default)("plusX");
function plusX2(file2) {
  const s = fs.statSync(file2);
  const newMode = s.mode | 64 | 8 | 1;
  if (s.mode === newMode) {
    debug3(`Execution permissions of ${file2} are fine`);
    return;
  }
  const base8 = newMode.toString(8).slice(-3);
  debug3(`Have to call plusX on ${file2}`);
  fs.chmodSync(file2, base8);
}
__name(plusX2, "plusX");
__name7(plusX2, "plusX");
function transformPlatformToEnvValue(platform2) {
  return { fromEnvVar: null, value: platform2 };
}
__name(transformPlatformToEnvValue, "transformPlatformToEnvValue");
__name7(transformPlatformToEnvValue, "transformPlatformToEnvValue");
function fixBinaryTargets(binaryTargets, platform2) {
  binaryTargets = binaryTargets || [];
  if (!binaryTargets.find((object) => object.value === "native")) {
    return [transformPlatformToEnvValue("native"), ...binaryTargets];
  }
  return [...binaryTargets, transformPlatformToEnvValue(platform2)];
}
__name(fixBinaryTargets, "fixBinaryTargets");
__name7(fixBinaryTargets, "fixBinaryTargets");
function link(url2) {
  return (0, import_terminal_link.default)(url2, url2, {
    fallback: (url22) => import_chalk6.default.underline(url22)
  });
}
__name(link, "link");
__name7(link, "link");
function getGithubIssueUrl({
  title,
  user = "prisma",
  repo = "prisma",
  template = "bug_report.md",
  body
}) {
  return (0, import_new_github_issue_url.default)({
    user,
    repo,
    template,
    title,
    body
  });
}
__name(getGithubIssueUrl, "getGithubIssueUrl");
__name7(getGithubIssueUrl, "getGithubIssueUrl");
function getRandomString() {
  return crypto2.randomBytes(12).toString("hex");
}
__name(getRandomString, "getRandomString");
__name7(getRandomString, "getRandomString");

// ../engine-core/dist/esm/common/errors/utils/getErrorMessageWithLink.mjs
var import_strip_ansi3 = __toModule2(require_strip_ansi());

// ../engine-core/dist/esm/common/errors/utils/maskQuery.mjs
var __defProp9 = Object.defineProperty;
var __name8 = /* @__PURE__ */ __name((target, value) => __defProp9(target, "name", { value, configurable: true }), "__name");
function maskQuery(query2) {
  if (!query2) {
    return "";
  }
  return query2.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (substr) => {
    return `${substr[0]}5`;
  });
}
__name(maskQuery, "maskQuery");
__name8(maskQuery, "maskQuery");

// ../engine-core/dist/esm/common/errors/utils/normalizeLogs.mjs
var __defProp10 = Object.defineProperty;
var __name9 = /* @__PURE__ */ __name((target, value) => __defProp10(target, "name", { value, configurable: true }), "__name");
function normalizeLogs(logs) {
  return logs.split("\n").map((l) => {
    return l.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "");
  }).join("\n");
}
__name(normalizeLogs, "normalizeLogs");
__name9(normalizeLogs, "normalizeLogs");

// ../engine-core/dist/esm/common/errors/utils/getErrorMessageWithLink.mjs
var __defProp11 = Object.defineProperty;
var __name10 = /* @__PURE__ */ __name((target, value) => __defProp11(target, "name", { value, configurable: true }), "__name");
function getErrorMessageWithLink({
  version,
  platform: platform2,
  title,
  description,
  engineVersion,
  database,
  query: query2
}) {
  const gotLogs = (0, import_debug3.getLogs)(6e3 - (query2?.length ?? 0));
  const logs = normalizeLogs((0, import_strip_ansi3.default)(gotLogs));
  const moreInfo = description ? `# Description
\`\`\`
${description}
\`\`\`` : "";
  const body = (0, import_strip_ansi3.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${platform2?.padEnd(19)}|
| Prisma Client   | ${version?.padEnd(19)}|
| Query Engine    | ${engineVersion?.padEnd(19)}|
| Database        | ${database?.padEnd(19)}|

${moreInfo}

## Logs
\`\`\`
${logs}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${query2 ? maskQuery(query2) : ""}
\`\`\`
`);
  const url2 = getGithubIssueUrl({ title, body });
  return `${title}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${link(url2)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
}
__name(getErrorMessageWithLink, "getErrorMessageWithLink");
__name10(getErrorMessageWithLink, "getErrorMessageWithLink");

// ../engine-core/dist/esm/common/errors/utils/prismaGraphQLToJSError.mjs
var __defProp12 = Object.defineProperty;
var __name11 = /* @__PURE__ */ __name((target, value) => __defProp12(target, "name", { value, configurable: true }), "__name");
function prismaGraphQLToJSError(error2, clientVersion2) {
  if (error2.user_facing_error.error_code) {
    return new PrismaClientKnownRequestError(error2.user_facing_error.message, error2.user_facing_error.error_code, clientVersion2, error2.user_facing_error.meta);
  }
  return new PrismaClientUnknownRequestError(error2.error, clientVersion2);
}
__name(prismaGraphQLToJSError, "prismaGraphQLToJSError");
__name11(prismaGraphQLToJSError, "prismaGraphQLToJSError");

// ../engine-core/dist/esm/common/utils/printGeneratorConfig.mjs
var import_indent_string3 = __toModule2(require_indent_string2());
var __defProp13 = Object.defineProperty;
var __name12 = /* @__PURE__ */ __name((target, value) => __defProp13(target, "name", { value, configurable: true }), "__name");
function printGeneratorConfig(config2) {
  return String(new GeneratorConfigClass(config2));
}
__name(printGeneratorConfig, "printGeneratorConfig");
__name12(printGeneratorConfig, "printGeneratorConfig");
var GeneratorConfigClass = class {
  constructor(config2) {
    this.config = config2;
  }
  toString() {
    const { config: config2 } = this;
    const provider = config2.provider.fromEnvVar ? `env("${config2.provider.fromEnvVar}")` : config2.provider.value;
    const obj = JSON.parse(JSON.stringify({
      provider,
      binaryTargets: getOriginalBinaryTargetsValue(config2.binaryTargets)
    }));
    return `generator ${config2.name} {
${(0, import_indent_string3.default)(printDatamodelObject(obj), 2)}
}`;
  }
};
__name(GeneratorConfigClass, "GeneratorConfigClass");
__name12(GeneratorConfigClass, "GeneratorConfigClass");
function getOriginalBinaryTargetsValue(binaryTargets) {
  let value;
  if (binaryTargets.length > 0) {
    const binaryTargetsFromEnvVar = binaryTargets.find((object) => object.fromEnvVar !== null);
    if (binaryTargetsFromEnvVar) {
      value = `env("${binaryTargetsFromEnvVar.fromEnvVar}")`;
    } else {
      value = binaryTargets.map((object) => object.value);
    }
  } else {
    value = void 0;
  }
  return value;
}
__name(getOriginalBinaryTargetsValue, "getOriginalBinaryTargetsValue");
__name12(getOriginalBinaryTargetsValue, "getOriginalBinaryTargetsValue");
function printDatamodelObject(obj) {
  const maxLength = Object.keys(obj).reduce((max2, curr) => Math.max(max2, curr.length), 0);
  return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${niceStringify(value)}`).join("\n");
}
__name(printDatamodelObject, "printDatamodelObject");
__name12(printDatamodelObject, "printDatamodelObject");
function niceStringify(value) {
  return JSON.parse(JSON.stringify(value, (_, value2) => {
    if (Array.isArray(value2)) {
      return `[${value2.map((element) => JSON.stringify(element)).join(", ")}]`;
    }
    return JSON.stringify(value2);
  }));
}
__name(niceStringify, "niceStringify");
__name12(niceStringify, "niceStringify");

// ../engine-core/dist/esm/library/LibraryEngine.mjs
var __defProp14 = Object.defineProperty;
var __name13 = /* @__PURE__ */ __name((target, value) => __defProp14(target, "name", { value, configurable: true }), "__name");
var debug4 = (0, import_debug4.default)("prisma:client:libraryEngine");
function isQueryEvent(event) {
  return event["item_type"] === "query" && "query" in event;
}
__name(isQueryEvent, "isQueryEvent");
__name13(isQueryEvent, "isQueryEvent");
function isPanicEvent(event) {
  return event.level === "error" && event["message"] === "PANIC";
}
__name(isPanicEvent, "isPanicEvent");
__name13(isPanicEvent, "isPanicEvent");
var knownPlatforms = [...import_get_platform.platforms, "native"];
var engines = [];
var LibraryEngine = class extends Engine {
  constructor(config2) {
    super();
    this.datamodel = fs2.readFileSync(config2.datamodelPath, "utf-8");
    this.config = config2;
    this.libraryStarted = false;
    this.logQueries = config2.logQueries ?? false;
    this.logLevel = config2.logLevel ?? "error";
    this.logEmitter = new EventEmitter();
    this.logEmitter.on("error", (e) => {
    });
    this.datasourceOverrides = config2.datasources ? this.convertDatasources(config2.datasources) : {};
    if (config2.enableDebugLogs) {
      this.logLevel = "debug";
    }
    this.libraryInstantiationPromise = this.instantiateLibrary();
    initHooks();
    engines.push(this);
    this.checkForTooManyEngines();
  }
  checkForTooManyEngines() {
    if (engines.length >= 10) {
      const runningEngines = engines.filter((e) => e.engine);
      if (runningEngines.length === 10) {
        console.warn(`${import_chalk7.default.yellow("warn(prisma-client)")} Already 10 Prisma Clients are actively running.`);
      }
    }
  }
  async transaction(action, arg2) {
    await this.start();
    if (action === "start") {
      const jsonOptions = JSON.stringify({
        max_wait: arg2?.maxWait ?? 2e3,
        timeout: arg2?.timeout ?? 5e3
      });
      const result = await this.engine?.startTransaction(jsonOptions, "{}");
      return this.parseEngineResponse(result);
    } else if (action === "commit") {
      await this.engine?.commitTransaction(arg2.id, "{}");
    } else if (action === "rollback") {
      await this.engine?.rollbackTransaction(arg2.id, "{}");
    }
    return void 0;
  }
  async instantiateLibrary() {
    debug4("internalSetup");
    if (this.libraryInstantiationPromise) {
      return this.libraryInstantiationPromise;
    }
    await (0, import_get_platform.isNodeAPISupported)();
    this.platform = await this.getPlatform();
    await this.loadEngine();
    this.version();
  }
  async getPlatform() {
    if (this.platform)
      return this.platform;
    const platform2 = await (0, import_get_platform.getPlatform)();
    if (!knownPlatforms.includes(platform2)) {
      throw new PrismaClientInitializationError(`Unknown ${import_chalk7.default.red("PRISMA_QUERY_ENGINE_LIBRARY")} ${import_chalk7.default.redBright.bold(this.platform)}. Possible binaryTargets: ${import_chalk7.default.greenBright(knownPlatforms.join(", "))} or a path to the query engine library.
You may have to run ${import_chalk7.default.greenBright("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
    }
    return platform2;
  }
  parseEngineResponse(response) {
    if (!response) {
      throw new PrismaClientUnknownRequestError(`Response from the Engine was empty`, this.config.clientVersion);
    }
    try {
      const config2 = JSON.parse(response);
      return config2;
    } catch (err) {
      throw new PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, this.config.clientVersion);
    }
  }
  convertDatasources(datasources) {
    const obj = Object.create(null);
    for (const { name, url: url2 } of datasources) {
      obj[name] = url2;
    }
    return obj;
  }
  async loadEngine() {
    if (!this.libQueryEnginePath) {
      this.libQueryEnginePath = await this.getLibQueryEnginePath();
    }
    debug4(`loadEngine using ${this.libQueryEnginePath}`);
    if (!this.engine) {
      if (!this.QueryEngineConstructor) {
        try {
          this.library = eval("require")(this.libQueryEnginePath);
          this.QueryEngineConstructor = this.library.QueryEngine;
        } catch (e) {
          if (fs2.existsSync(this.libQueryEnginePath)) {
            if (this.libQueryEnginePath.endsWith(".node")) {
              throw new PrismaClientInitializationError(`Unable to load Node-API Library from ${import_chalk7.default.dim(this.libQueryEnginePath)}, Library may be corrupt`, this.config.clientVersion);
            } else {
              throw new PrismaClientInitializationError(`Expected an Node-API Library but received ${import_chalk7.default.dim(this.libQueryEnginePath)}`, this.config.clientVersion);
            }
          } else {
            throw new PrismaClientInitializationError(`Unable to load Node-API Library from ${import_chalk7.default.dim(this.libQueryEnginePath)}, It does not exist`, this.config.clientVersion);
          }
        }
      }
      if (this.QueryEngineConstructor) {
        try {
          this.engine = new this.QueryEngineConstructor({
            datamodel: this.datamodel,
            env: process.env,
            logQueries: this.config.logQueries ?? false,
            ignoreEnvVarErrors: false,
            datasourceOverrides: this.datasourceOverrides,
            logLevel: this.logLevel,
            configDir: this.config.cwd
          }, (err, log4) => this.logger(err, log4));
        } catch (_e) {
          const e = _e;
          const error2 = this.parseInitError(e.message);
          if (typeof error2 === "string") {
            throw e;
          } else {
            throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);
          }
        }
      }
    }
  }
  logger(err, log4) {
    if (err) {
      throw err;
    }
    const event = this.parseEngineResponse(log4);
    if (!event)
      return;
    event.level = event?.level.toLowerCase() ?? "unknown";
    if (isQueryEvent(event)) {
      this.logEmitter.emit("query", {
        timestamp: Date.now(),
        query: event.query,
        params: event.params,
        duration: event.duration_ms,
        target: event.module_path
      });
    } else if (isPanicEvent(event)) {
      this.loggerRustPanic = new PrismaClientRustPanicError(this.getErrorMessageWithLink(`${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`), this.config.clientVersion);
      this.logEmitter.emit("error", this.loggerRustPanic);
    } else {
      this.logEmitter.emit(event.level, event);
    }
  }
  getErrorMessageWithLink(title) {
    return getErrorMessageWithLink({
      platform: this.platform,
      title,
      version: this.config.clientVersion,
      engineVersion: this.versionInfo?.version,
      database: this.config.activeProvider,
      query: this.lastQuery
    });
  }
  parseInitError(str) {
    try {
      const error2 = JSON.parse(str);
      return error2;
    } catch (e) {
    }
    return str;
  }
  parseRequestError(str) {
    try {
      const error2 = JSON.parse(str);
      return error2;
    } catch (e) {
    }
    return str;
  }
  on(event, listener) {
    if (event === "beforeExit") {
      this.beforeExitListener = listener;
    } else {
      this.logEmitter.on(event, listener);
    }
  }
  async runBeforeExit() {
    debug4("runBeforeExit");
    if (this.beforeExitListener) {
      try {
        await this.beforeExitListener();
      } catch (e) {
        console.error(e);
      }
    }
  }
  async start() {
    await this.libraryInstantiationPromise;
    await this.libraryStoppingPromise;
    if (this.libraryStartingPromise) {
      debug4(`library already starting, this.libraryStarted: ${this.libraryStarted}`);
      return this.libraryStartingPromise;
    }
    if (!this.libraryStarted) {
      this.libraryStartingPromise = new Promise((resolve2, reject2) => {
        debug4("library starting");
        this.engine?.connect({ enableRawQueries: true }).then(() => {
          this.libraryStarted = true;
          this.libraryStartingPromise = void 0;
          debug4("library started");
          resolve2();
        }).catch((err) => {
          const error2 = this.parseInitError(err.message);
          if (typeof error2 === "string") {
            reject2(err);
          } else {
            reject2(new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code));
          }
        });
      });
      return this.libraryStartingPromise;
    }
  }
  async stop() {
    await this.libraryStartingPromise;
    await this.executingQueryPromise;
    if (this.libraryStoppingPromise) {
      debug4("library is already stopping");
      return this.libraryStoppingPromise;
    }
    if (this.libraryStarted) {
      this.libraryStoppingPromise = new Promise(async (resolve2, reject2) => {
        try {
          await new Promise((r) => setTimeout(r, 5));
          debug4("library stopping");
          await this.engine?.disconnect();
          this.libraryStarted = false;
          this.libraryStoppingPromise = void 0;
          debug4("library stopped");
          resolve2();
        } catch (err) {
          reject2(err);
        }
      });
      return this.libraryStoppingPromise;
    }
  }
  getConfig() {
    return this.library.getConfig({
      datamodel: this.datamodel,
      datasourceOverrides: this.datasourceOverrides,
      ignoreEnvVarErrors: true,
      env: process.env
    });
  }
  version() {
    this.versionInfo = this.library?.version();
    return this.versionInfo?.version ?? "unknown";
  }
  async request(query2, headers = {}, numTry = 1) {
    debug4(`sending request, this.libraryStarted: ${this.libraryStarted}`);
    const request4 = { query: query2, variables: {} };
    const queryStr = JSON.stringify(request4);
    const headerStr = JSON.stringify(headers);
    try {
      await this.start();
      this.executingQueryPromise = this.engine?.query(queryStr, headerStr, headers.transactionId);
      this.lastQuery = queryStr;
      const data = this.parseEngineResponse(await this.executingQueryPromise);
      if (data.errors) {
        if (data.errors.length === 1) {
          throw prismaGraphQLToJSError(data.errors[0], this.config.clientVersion);
        }
        throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
      } else if (this.loggerRustPanic) {
        throw this.loggerRustPanic;
      }
      return { data, elapsed: 0 };
    } catch (e) {
      if (e instanceof PrismaClientInitializationError) {
        throw e;
      }
      const error2 = this.parseRequestError(e.message);
      if (typeof error2 === "string") {
        throw e;
      } else {
        throw new PrismaClientUnknownRequestError(`${error2.message}
${error2.backtrace}`, this.config.clientVersion);
      }
    }
  }
  async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {
    debug4("requestBatch");
    const request4 = {
      batch: queries.map((query2) => ({ query: query2, variables: {} })),
      transaction
    };
    await this.start();
    this.lastQuery = JSON.stringify(request4);
    this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify(headers), headers.transactionId);
    const result = await this.executingQueryPromise;
    const data = this.parseEngineResponse(result);
    if (data.errors) {
      if (data.errors.length === 1) {
        throw prismaGraphQLToJSError(data.errors[0], this.config.clientVersion);
      }
      throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
    }
    const { batchResult, errors: errors2 } = data;
    if (Array.isArray(batchResult)) {
      return batchResult.map((result2) => {
        if (result2.errors) {
          return this.loggerRustPanic ?? prismaGraphQLToJSError(data.errors[0], this.config.clientVersion);
        }
        return {
          data: result2,
          elapsed: 0
        };
      });
    } else {
      if (errors2 && errors2.length === 1) {
        throw new Error(errors2[0].error);
      }
      throw new Error(JSON.stringify(data));
    }
  }
  async resolveEnginePath() {
    const searchedLocations = [];
    let enginePath;
    if (this.libQueryEnginePath) {
      return { enginePath: this.libQueryEnginePath, searchedLocations };
    }
    this.platform = this.platform ?? await (0, import_get_platform.getPlatform)();
    if (__filename.includes("LibraryEngine")) {
      enginePath = path.join((0, import_engines.getEnginesPath)(), (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
      return { enginePath, searchedLocations };
    }
    const searchLocations = [
      eval(`require('path').join(__dirname, '../../../.prisma/client')`),
      this.config.generator?.output?.value ?? eval("__dirname"),
      path.join(eval("__dirname"), ".."),
      path.dirname(this.config.datamodelPath),
      this.config.cwd,
      "/tmp/prisma-engines"
    ];
    if (this.config.dirname) {
      searchLocations.push(this.config.dirname);
    }
    for (const location of searchLocations) {
      searchedLocations.push(location);
      debug4(`Search for Query Engine Library in ${location}`);
      enginePath = path.join(location, (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
      if (fs2.existsSync(enginePath)) {
        return { enginePath, searchedLocations };
      }
    }
    enginePath = path.join(__dirname, (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
    return { enginePath: enginePath ?? "", searchedLocations };
  }
  async getLibQueryEnginePath() {
    const libPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY ?? this.config.prismaPath;
    if (libPath && fs2.existsSync(libPath) && libPath.endsWith(".node")) {
      return libPath;
    }
    this.platform = this.platform ?? await (0, import_get_platform.getPlatform)();
    const { enginePath: enginePath2, searchedLocations: searchedLocations2 } = await this.resolveEnginePath();
    if (!fs2.existsSync(enginePath2)) {
      const incorrectPinnedPlatformErrorStr = this.platform ? `
You incorrectly pinned it to ${import_chalk7.default.redBright.bold(`${this.platform}`)}
` : "";
      let errorText = `Query engine library for current platform "${import_chalk7.default.bold(this.platform)}" could not be found.${incorrectPinnedPlatformErrorStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk7.default.underline(enginePath2)}")

Searched Locations:

${searchedLocations2.map((f) => {
        let msg = `  ${f}`;
        if (process.env.DEBUG === "node-engine-search-locations" && fs2.existsSync(f)) {
          const dir2 = fs2.readdirSync(f);
          msg += dir2.map((d) => `    ${d}`).join("\n");
        }
        return msg;
      }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
      if (this.config.generator) {
        this.platform = this.platform ?? await (0, import_get_platform.getPlatform)();
        if (this.config.generator.binaryTargets.find((object) => object.value === this.platform) || this.config.generator.binaryTargets.find((object) => object.value === "native")) {
          errorText += `
You already added the platform${this.config.generator.binaryTargets.length > 1 ? "s" : ""} ${this.config.generator.binaryTargets.map((t) => `"${import_chalk7.default.bold(t.value)}"`).join(", ")} to the "${import_chalk7.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
          errorText += ``;
        } else {
          errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk7.default.underline("binaryTargets")}" attribute in the "${import_chalk7.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk7.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk7.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
        }
      } else {
        errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
      }
      throw new PrismaClientInitializationError(errorText, this.config.clientVersion);
    }
    this.platform = this.platform ?? await (0, import_get_platform.getPlatform)();
    return enginePath2;
  }
  getFixedGenerator() {
    const fixedGenerator = {
      ...this.config.generator,
      binaryTargets: fixBinaryTargets(this.config.generator.binaryTargets, this.platform)
    };
    return printGeneratorConfig(fixedGenerator);
  }
};
__name(LibraryEngine, "LibraryEngine");
__name13(LibraryEngine, "LibraryEngine");
function hookProcess(handler, exit = false) {
  process.once(handler, async () => {
    debug4(`hookProcess received: ${handler}`);
    for (const engine of engines) {
      await engine.runBeforeExit();
    }
    engines.splice(0, engines.length);
    if (exit && process.listenerCount(handler) === 0) {
      process.exit();
    }
  });
}
__name(hookProcess, "hookProcess");
__name13(hookProcess, "hookProcess");
var hooksInitialized = false;
function initHooks() {
  if (!hooksInitialized) {
    hookProcess("beforeExit");
    hookProcess("exit");
    hookProcess("SIGINT", true);
    hookProcess("SIGUSR2", true);
    hookProcess("SIGTERM", true);
    hooksInitialized = true;
  }
}
__name(initHooks, "initHooks");
__name13(initHooks, "initHooks");

// ../engine-core/dist/esm/binary/BinaryEngine.mjs
var import_debug5 = __toModule2(require_dist7());
var import_engines2 = __toModule2(require_dist8());
var import_get_platform2 = __toModule2(require_dist9());
var import_chalk8 = __toModule2(require_source2());
var import_execa = __toModule2(require_execa2());
var import_p_retry = __toModule2(require_p_retry2());
import { spawn } from "child_process";
import EventEmitter2 from "events";
import fs3 from "fs";
import net from "net";
import path2 from "path";
import { URL as URL2 } from "url";
import { promisify } from "util";

// ../engine-core/dist/esm/tools/byline.mjs
import stream from "stream";
import util from "util";
var __defProp15 = Object.defineProperty;
var __name14 = /* @__PURE__ */ __name((target, value) => __defProp15(target, "name", { value, configurable: true }), "__name");
function byline(readStream, options2) {
  return module.exports.createStream(readStream, options2);
}
__name(byline, "byline");
__name14(byline, "byline");
module.exports.createStream = function(readStream, options2) {
  if (readStream) {
    return createLineStream(readStream, options2);
  } else {
    return new LineStream(options2);
  }
};
function createLineStream(readStream, options2) {
  if (!readStream) {
    throw new Error("expected readStream");
  }
  if (!readStream.readable) {
    throw new Error("readStream must be readable");
  }
  const ls = new LineStream(options2);
  readStream.pipe(ls);
  return ls;
}
__name(createLineStream, "createLineStream");
__name14(createLineStream, "createLineStream");
module.exports.LineStream = LineStream;
function LineStream(options2) {
  stream.Transform.call(this, options2);
  options2 = options2 || {};
  this._readableState.objectMode = true;
  this._lineBuffer = [];
  this._keepEmptyLines = options2.keepEmptyLines || false;
  this._lastChunkEndedWithCR = false;
  this.on("pipe", function(src) {
    if (!this.encoding) {
      if (src instanceof stream.Readable) {
        this.encoding = src._readableState.encoding;
      }
    }
  });
}
__name(LineStream, "LineStream");
__name14(LineStream, "LineStream");
util.inherits(LineStream, stream.Transform);
LineStream.prototype._transform = function(chunk, encoding, done) {
  encoding = encoding || "utf8";
  if (Buffer.isBuffer(chunk)) {
    if (encoding == "buffer") {
      chunk = chunk.toString();
      encoding = "utf8";
    } else {
      chunk = chunk.toString(encoding);
    }
  }
  this._chunkEncoding = encoding;
  const lines = chunk.split(/\r\n|\r|\n/g);
  if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
    lines.shift();
  }
  if (this._lineBuffer.length > 0) {
    this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
    lines.shift();
  }
  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
  this._lineBuffer = this._lineBuffer.concat(lines);
  this._pushBuffer(encoding, 1, done);
};
LineStream.prototype._pushBuffer = function(encoding, keep, done) {
  while (this._lineBuffer.length > keep) {
    const line = this._lineBuffer.shift();
    if (this._keepEmptyLines || line.length > 0) {
      if (!this.push(this._reencode(line, encoding))) {
        const self2 = this;
        setImmediate(function() {
          self2._pushBuffer(encoding, keep, done);
        });
        return;
      }
    }
  }
  done();
};
LineStream.prototype._flush = function(done) {
  this._pushBuffer(this._chunkEncoding, 0, done);
};
LineStream.prototype._reencode = function(line, chunkEncoding) {
  if (this.encoding && this.encoding != chunkEncoding) {
    return Buffer.from(line, chunkEncoding).toString(this.encoding);
  } else if (this.encoding) {
    return line;
  } else {
    return Buffer.from(line, chunkEncoding);
  }
};

// ../engine-core/dist/esm/common/errors/utils/log.mjs
var __defProp16 = Object.defineProperty;
var __name15 = /* @__PURE__ */ __name((target, value) => __defProp16(target, "name", { value, configurable: true }), "__name");
function getMessage(log4) {
  if (typeof log4 === "string") {
    return log4;
  } else if (isRustError(log4)) {
    return getBacktraceFromRustError(log4);
  } else if (isRustLog(log4)) {
    return getBacktraceFromLog(log4);
  }
  return JSON.stringify(log4);
}
__name(getMessage, "getMessage");
__name15(getMessage, "getMessage");
function getBacktraceFromLog(log4) {
  if (log4.fields?.message) {
    let str = log4.fields?.message;
    if (log4.fields?.file) {
      str += ` in ${log4.fields.file}`;
      if (log4.fields?.line) {
        str += `:${log4.fields.line}`;
      }
      if (log4.fields?.column) {
        str += `:${log4.fields.column}`;
      }
    }
    if (log4.fields?.reason) {
      str += `
${log4.fields?.reason}`;
    }
    return str;
  }
  return "Unknown error";
}
__name(getBacktraceFromLog, "getBacktraceFromLog");
__name15(getBacktraceFromLog, "getBacktraceFromLog");
function getBacktraceFromRustError(err) {
  let str = "";
  if (err.is_panic) {
    str += `PANIC`;
  }
  if (err.backtrace) {
    str += ` in ${err.backtrace}`;
  }
  if (err.message) {
    str += `
${err.message}`;
  }
  return str;
}
__name(getBacktraceFromRustError, "getBacktraceFromRustError");
__name15(getBacktraceFromRustError, "getBacktraceFromRustError");
function isRustLog(e) {
  return e.timestamp && typeof e.level === "string" && typeof e.target === "string";
}
__name(isRustLog, "isRustLog");
__name15(isRustLog, "isRustLog");
function isRustErrorLog(e) {
  return isRustLog(e) && (e.level === "error" || e.fields?.message?.includes("fatal error"));
}
__name(isRustErrorLog, "isRustErrorLog");
__name15(isRustErrorLog, "isRustErrorLog");
function isRustError(e) {
  return typeof e.is_panic !== "undefined";
}
__name(isRustError, "isRustError");
__name15(isRustError, "isRustError");
function convertLog(rustLog) {
  const isQuery = isQueryLog(rustLog.fields);
  const level = isQuery ? "query" : rustLog.level.toLowerCase();
  return {
    ...rustLog,
    level,
    timestamp: new Date(new Date().getFullYear() + " " + rustLog.timestamp)
  };
}
__name(convertLog, "convertLog");
__name15(convertLog, "convertLog");
function isQueryLog(fields) {
  return Boolean(fields.query);
}
__name(isQueryLog, "isQueryLog");
__name15(isQueryLog, "isQueryLog");

// ../engine-core/dist/esm/common/errors/PrismaClientRustError.mjs
var __defProp17 = Object.defineProperty;
var __name16 = /* @__PURE__ */ __name((target, value) => __defProp17(target, "name", { value, configurable: true }), "__name");
var PrismaClientRustError = class extends Error {
  constructor({ clientVersion: clientVersion2, log: log4, error: error2 }) {
    if (log4) {
      const backtrace = getBacktraceFromLog(log4);
      super(backtrace ?? "Unkown error");
    } else if (error2) {
      const backtrace = getBacktraceFromRustError(error2);
      super(backtrace);
    } else {
      super(`Unknown error`);
    }
    this.clientVersion = clientVersion2;
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientRustPanicError";
  }
};
__name(PrismaClientRustError, "PrismaClientRustError");
__name16(PrismaClientRustError, "PrismaClientRustError");

// ../engine-core/dist/esm/tools/omit.mjs
var __defProp18 = Object.defineProperty;
var __name17 = /* @__PURE__ */ __name((target, value) => __defProp18(target, "name", { value, configurable: true }), "__name");
function omit2(obj, keys2) {
  return Object.keys(obj).filter((key) => !keys2.includes(key)).reduce((result, key) => {
    result[key] = obj[key];
    return result;
  }, {});
}
__name(omit2, "omit");
__name17(omit2, "omit");

// ../engine-core/dist/esm/binary/Connection.mjs
var import_get_stream = __toModule2(require_get_stream2());

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/wrapper.mjs
var import_index = __toModule2(require_undici());
var Client = import_index.default.Client;
var Agent = import_index.default.Agent;
var errors = import_index.default.errors;
var Pool = import_index.default.Pool;
var request2 = import_index.default.request;
var stream2 = import_index.default.stream;
var pipeline = import_index.default.pipeline;
var setGlobalAgent = import_index.default.setGlobalAgent;

// ../engine-core/dist/esm/binary/Connection.mjs
var __defProp19 = Object.defineProperty;
var __name18 = /* @__PURE__ */ __name((target, value) => __defProp19(target, "name", { value, configurable: true }), "__name");
function assertHasPool(pool) {
  if (pool === void 0) {
    throw new Error("Connection has not been opened");
  }
}
__name(assertHasPool, "assertHasPool");
__name18(assertHasPool, "assertHasPool");
var Connection = class {
  constructor() {
  }
  static async onHttpError(response, handler) {
    const _response = await response;
    if (_response.statusCode >= 400) {
      return handler(_response);
    }
    return _response;
  }
  open(url2, options2) {
    if (this._pool)
      return;
    this._pool = new Pool(url2, {
      connections: 1e3,
      keepAliveMaxTimeout: 6e5,
      headersTimeout: 0,
      ...options2
    });
  }
  async raw(method, endpoint, headers, body) {
    assertHasPool(this._pool);
    const response = await this._pool.request({
      path: endpoint,
      method,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body,
      bodyTimeout: 0
    });
    const result = {
      statusCode: response.statusCode,
      headers: response.headers,
      data: JSON.parse(await (0, import_get_stream.default)(response.body))
    };
    return result;
  }
  post(endpoint, body, headers) {
    return this.raw("POST", endpoint, headers, body);
  }
  get(path6, headers) {
    return this.raw("GET", path6, headers);
  }
  close() {
    if (this._pool) {
      this._pool.close(() => {
      });
    }
    this._pool = void 0;
  }
};
__name(Connection, "Connection");
__name18(Connection, "Connection");

// ../engine-core/dist/esm/binary/BinaryEngine.mjs
var __defProp20 = Object.defineProperty;
var __name19 = /* @__PURE__ */ __name((target, value) => __defProp20(target, "name", { value, configurable: true }), "__name");
var debug5 = (0, import_debug5.default)("prisma:engine");
var exists2 = promisify(fs3.exists);
var logger = /* @__PURE__ */ __name19((...args) => {
}, "logger");
var knownPlatforms2 = [...import_get_platform2.platforms, "native"];
var engines2 = [];
var socketPaths = [];
var MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
var MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
var BinaryEngine = class extends Engine {
  constructor({
    cwd,
    datamodelPath,
    prismaPath,
    generator,
    datasources,
    showColors,
    logLevel,
    logQueries,
    env,
    flags,
    clientVersion: clientVersion2,
    previewFeatures,
    engineEndpoint,
    enableDebugLogs,
    allowTriggerPanic,
    dirname,
    useUds,
    activeProvider
  }) {
    super();
    this.startCount = 0;
    this.previewFeatures = [];
    this.useUds = false;
    this.stderrLogs = "";
    this.handleRequestError = async (error2, graceful = false) => {
      debug5({ error: error2 });
      if (this.startPromise) {
        await this.startPromise;
      }
      this.throwAsyncErrorIfExists();
      if (this.currentRequestPromise?.isCanceled) {
        this.throwAsyncErrorIfExists();
      } else if (error2.code === "ECONNRESET" || error2.code === "ECONNREFUSED" || error2.code === "UND_ERR_CLOSED" || error2.code === "UND_ERR_SOCKET" || error2.code === "UND_ERR_DESTROYED" || error2.code === "UND_ERR_ABORTED" || error2.message.toLowerCase().includes("client is destroyed") || error2.message.toLowerCase().includes("other side closed") || error2.message.toLowerCase().includes("the client is closed")) {
        if (this.globalKillSignalReceived && !this.child?.connected) {
          throw new PrismaClientUnknownRequestError(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
and your request can't be processed.
You probably have some open handle that prevents your process from exiting.
It could be an open http server or stream that didn't close yet.
We recommend using the \`wtfnode\` package to debug open handles.`, this.clientVersion);
        }
        this.throwAsyncErrorIfExists();
        if (this.startCount > MAX_STARTS) {
          for (let i = 0; i < 5; i++) {
            await new Promise((r) => setTimeout(r, 50));
            this.throwAsyncErrorIfExists(true);
          }
          throw new Error(`Query engine is trying to restart, but can't.
Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
        }
      }
      if (!graceful) {
        this.throwAsyncErrorIfExists(true);
        throw error2;
      }
      return false;
    };
    this.dirname = dirname;
    this.useUds = useUds ?? false;
    this.env = env;
    this.cwd = this.resolveCwd(cwd);
    this.enableDebugLogs = enableDebugLogs ?? false;
    this.allowTriggerPanic = allowTriggerPanic ?? false;
    this.datamodelPath = datamodelPath;
    this.prismaPath = process.env.PRISMA_QUERY_ENGINE_BINARY ?? prismaPath;
    this.generator = generator;
    this.datasources = datasources;
    this.logEmitter = new EventEmitter2();
    this.logEmitter.on("error", () => {
    });
    this.showColors = showColors ?? false;
    this.logLevel = logLevel;
    this.logQueries = logQueries ?? false;
    this.clientVersion = clientVersion2;
    this.flags = flags ?? [];
    this.previewFeatures = previewFeatures ?? [];
    this.activeProvider = activeProvider;
    this.connection = new Connection();
    initHooks2();
    const removedFlags = [
      "middlewares",
      "aggregateApi",
      "distinct",
      "aggregations",
      "insensitiveFilters",
      "atomicNumberOperations",
      "transactionApi",
      "transaction",
      "connectOrCreate",
      "uncheckedScalarInputs",
      "nativeTypes",
      "createMany",
      "groupBy",
      "referentialActions",
      "microsoftSqlServer"
    ];
    const removedFlagsUsed = this.previewFeatures.filter((e) => removedFlags.includes(e));
    if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
      console.log(`${import_chalk8.default.blueBright("info")} The preview flags \`${removedFlagsUsed.join("`, `")}\` were removed, you can now safely remove them from your schema.prisma.`);
    }
    this.previewFeatures = this.previewFeatures.filter((e) => !removedFlags.includes(e));
    this.engineEndpoint = engineEndpoint;
    if (engineEndpoint) {
      const url2 = new URL2(engineEndpoint);
      this.port = Number(url2.port);
    }
    if (this.platform) {
      if (!knownPlatforms2.includes(this.platform) && !fs3.existsSync(this.platform)) {
        throw new PrismaClientInitializationError(`Unknown ${import_chalk8.default.red("PRISMA_QUERY_ENGINE_BINARY")} ${import_chalk8.default.redBright.bold(this.platform)}. Possible binaryTargets: ${import_chalk8.default.greenBright(knownPlatforms2.join(", "))} or a path to the query engine binary.
You may have to run ${import_chalk8.default.greenBright("prisma generate")} for your changes to take effect.`, this.clientVersion);
      }
    } else {
      void this.getPlatform();
    }
    if (this.enableDebugLogs) {
      import_debug5.default.enable("*");
    }
    engines2.push(this);
    this.checkForTooManyEngines();
  }
  setError(err) {
    if (isRustError(err)) {
      this.lastRustError = err;
      this.logEmitter.emit("error", new PrismaClientRustError({
        clientVersion: this.clientVersion,
        error: err
      }));
      if (err.is_panic) {
        this.handlePanic();
      }
    } else if (isRustErrorLog(err)) {
      this.lastErrorLog = err;
      this.logEmitter.emit("error", new PrismaClientRustError({
        clientVersion: this.clientVersion,
        log: err
      }));
      if (err.fields?.message === "PANIC") {
        this.handlePanic();
      }
    } else {
      this.logEmitter.emit("error", err);
    }
  }
  checkForTooManyEngines() {
    if (engines2.length >= 10) {
      const runningEngines = engines2.filter((e) => e.child);
      if (runningEngines.length === 10) {
        console.warn(`${import_chalk8.default.yellow("warn(prisma-client)")} Already 10 Prisma Clients are actively running.`);
      }
    }
  }
  resolveCwd(cwd) {
    if (cwd && fs3.existsSync(cwd) && fs3.lstatSync(cwd).isDirectory()) {
      return cwd;
    }
    return process.cwd();
  }
  on(event, listener) {
    if (event === "beforeExit") {
      this.beforeExitListener = listener;
    } else {
      this.logEmitter.on(event, listener);
    }
  }
  async emitExit() {
    if (this.beforeExitListener) {
      try {
        await this.beforeExitListener();
      } catch (e) {
        console.error(e);
      }
    }
  }
  async getPlatform() {
    if (this.platformPromise) {
      return this.platformPromise;
    }
    this.platformPromise = (0, import_get_platform2.getPlatform)();
    return this.platformPromise;
  }
  getQueryEnginePath(platform2, prefix = __dirname) {
    let queryEnginePath = path2.join(prefix, `query-engine-${platform2}`);
    if (platform2 === "windows") {
      queryEnginePath = `${queryEnginePath}.exe`;
    }
    return queryEnginePath;
  }
  handlePanic() {
    this.child?.kill();
    if (this.currentRequestPromise?.cancel) {
      this.currentRequestPromise.cancel();
    }
  }
  async resolvePrismaPath() {
    const searchedLocations = [];
    let enginePath;
    if (this.prismaPath) {
      return { prismaPath: this.prismaPath, searchedLocations };
    }
    const platform = await this.getPlatform();
    if (this.platform && this.platform !== platform) {
      this.incorrectlyPinnedBinaryTarget = this.platform;
    }
    this.platform = this.platform || platform;
    if (__filename.includes("BinaryEngine")) {
      enginePath = this.getQueryEnginePath(this.platform, (0, import_engines2.getEnginesPath)());
      return { prismaPath: enginePath, searchedLocations };
    }
    const searchLocations = [
      eval(`require('path').join(__dirname, '../../../.prisma/client')`),
      this.generator?.output?.value ?? eval("__dirname"),
      path2.join(eval("__dirname"), ".."),
      path2.dirname(this.datamodelPath),
      this.cwd,
      "/tmp/prisma-engines"
    ];
    if (this.dirname) {
      searchLocations.push(this.dirname);
    }
    for (const location of searchLocations) {
      searchedLocations.push(location);
      debug5(`Search for Query Engine in ${location}`);
      enginePath = this.getQueryEnginePath(this.platform, location);
      if (fs3.existsSync(enginePath)) {
        return { prismaPath: enginePath, searchedLocations };
      }
    }
    enginePath = this.getQueryEnginePath(this.platform);
    return { prismaPath: enginePath ?? "", searchedLocations };
  }
  async getPrismaPath() {
    const { prismaPath, searchedLocations: searchedLocations2 } = await this.resolvePrismaPath();
    const platform2 = await this.getPlatform();
    if (!await exists2(prismaPath)) {
      const pinnedStr = this.incorrectlyPinnedBinaryTarget ? `
You incorrectly pinned it to ${import_chalk8.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}
` : "";
      let errorText = `Query engine binary for current platform "${import_chalk8.default.bold(platform2)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk8.default.underline(prismaPath)}")

Searched Locations:

${searchedLocations2.map((f) => {
        let msg = `  ${f}`;
        if (process.env.DEBUG === "node-engine-search-locations" && fs3.existsSync(f)) {
          const dir2 = fs3.readdirSync(f);
          msg += dir2.map((d) => `    ${d}`).join("\n");
        }
        return msg;
      }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
      if (this.generator) {
        if (this.generator.binaryTargets.find((object) => object.value === this.platform) || this.generator.binaryTargets.find((object) => object.value === "native")) {
          errorText += `
You already added the platform${this.generator.binaryTargets.length > 1 ? "s" : ""} ${this.generator.binaryTargets.map((t) => `"${import_chalk8.default.bold(t.value)}"`).join(", ")} to the "${import_chalk8.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
          errorText += ``;
        } else {
          errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk8.default.underline("binaryTargets")}" attribute in the "${import_chalk8.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk8.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk8.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
        }
      } else {
        errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
      }
      throw new PrismaClientInitializationError(errorText, this.clientVersion);
    }
    if (this.incorrectlyPinnedBinaryTarget) {
      console.error(`${import_chalk8.default.yellow("Warning:")} You pinned the platform ${import_chalk8.default.bold(this.incorrectlyPinnedBinaryTarget)}, but Prisma Client detects ${import_chalk8.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${import_chalk8.default.greenBright(await this.getPlatform())} instead.
${import_chalk8.default.dim("In case we're mistaken, please report this to us \u{1F64F}.")}`);
    }
    if (process.platform !== "win32") {
      plusX2(prismaPath);
    }
    return prismaPath;
  }
  getFixedGenerator() {
    const fixedGenerator = {
      ...this.generator,
      binaryTargets: fixBinaryTargets(this.generator.binaryTargets, this.platform)
    };
    return printGeneratorConfig(fixedGenerator);
  }
  printDatasources() {
    if (this.datasources) {
      return JSON.stringify(this.datasources);
    }
    return "[]";
  }
  async start() {
    if (this.stopPromise) {
      await this.stopPromise;
    }
    if (!this.startPromise) {
      this.startCount++;
      this.startPromise = this.internalStart();
    }
    await this.startPromise;
    if (!this.child && !this.engineEndpoint) {
      throw new PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
    }
    return this.startPromise;
  }
  getEngineEnvVars() {
    const env = {
      PRISMA_DML_PATH: this.datamodelPath,
      RUST_BACKTRACE: "1",
      RUST_LOG: "info"
    };
    if (this.logQueries || this.logLevel === "info") {
      env.RUST_LOG = "info";
      if (this.logQueries) {
        env.LOG_QUERIES = "true";
      }
    }
    if (this.datasources) {
      env.OVERWRITE_DATASOURCES = this.printDatasources();
    }
    if (!process.env.NO_COLOR && this.showColors) {
      env.CLICOLOR_FORCE = "1";
    }
    return {
      ...this.env,
      ...process.env,
      ...env
    };
  }
  internalStart() {
    return new Promise(async (resolve2, reject2) => {
      await new Promise((r) => process.nextTick(r));
      if (this.stopPromise) {
        await this.stopPromise;
      }
      if (this.engineEndpoint) {
        try {
          await (0, import_p_retry.default)(() => this.connection.get("/"), {
            retries: 10
          });
        } catch (e) {
          return reject2(e);
        }
        return resolve2();
      }
      try {
        if (this.child?.connected || this.child && !this.child?.killed) {
          debug5(`There is a child that still runs and we want to start again`);
        }
        this.lastRustError = void 0;
        this.lastErrorLog = void 0;
        this.lastPanic = void 0;
        logger("startin & resettin");
        this.globalKillSignalReceived = void 0;
        if (this.useUds) {
          this.socketPath = `/tmp/prisma-${getRandomString()}.sock`;
          socketPaths.push(this.socketPath);
        }
        debug5({ cwd: this.cwd });
        const prismaPath = await this.getPrismaPath();
        const additionalFlag = this.allowTriggerPanic ? ["--debug"] : [];
        const flags = ["--enable-raw-queries", ...this.flags, ...additionalFlag];
        if (this.useUds) {
          flags.push("--unix-path", this.socketPath);
        } else {
          this.port = await this.getFreePort();
          flags.push("--port", String(this.port));
        }
        debug5({ flags });
        const env = this.getEngineEnvVars();
        this.child = spawn(prismaPath, flags, {
          env,
          cwd: this.cwd,
          windowsHide: true,
          stdio: ["ignore", "pipe", "pipe"]
        });
        byline(this.child.stderr).on("data", (msg) => {
          const data = String(msg);
          debug5("stderr", data);
          try {
            const json = JSON.parse(data);
            if (typeof json.is_panic !== "undefined") {
              debug5(json);
              this.setError(json);
              if (this.engineStartDeferred) {
                const err = new PrismaClientInitializationError(json.message, this.clientVersion);
                this.engineStartDeferred.reject(err);
              }
            }
          } catch (e) {
            if (!data.includes("Printing to stderr") && !data.includes("Listening on ")) {
              this.stderrLogs += "\n" + data;
            }
          }
        });
        byline(this.child.stdout).on("data", (msg) => {
          const data = String(msg);
          try {
            const json = JSON.parse(data);
            debug5("stdout", getMessage(json));
            if (this.engineStartDeferred && json.level === "INFO" && json.target === "query_engine::server" && json.fields?.message?.startsWith("Started http server")) {
              if (this.useUds) {
                this.connection.open("http://127.0.0.1", {
                  socketPath: this.socketPath
                });
              } else {
                this.connection.open(`http://127.0.0.1:${this.port}`);
              }
              this.engineStartDeferred.resolve();
              this.engineStartDeferred = void 0;
            }
            if (typeof json.is_panic === "undefined") {
              const log4 = convertLog(json);
              const logIsRustErrorLog = isRustErrorLog(log4);
              if (logIsRustErrorLog) {
                this.setError(log4);
              } else {
                this.logEmitter.emit(log4.level, log4);
              }
            } else {
              this.setError(json);
            }
          } catch (e) {
            debug5(e, data);
          }
        });
        this.child.on("exit", (code) => {
          logger("removing startPromise");
          this.startPromise = void 0;
          if (this.engineStopDeferred) {
            this.engineStopDeferred.resolve(code);
            return;
          }
          this.connection.close();
          if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {
            let err;
            let msg = this.stderrLogs;
            if (this.lastRustError) {
              msg = getMessage(this.lastRustError);
            } else if (this.lastErrorLog) {
              msg = getMessage(this.lastErrorLog);
            }
            if (code !== null) {
              err = new PrismaClientInitializationError(`Query engine exited with code ${code}
` + msg, this.clientVersion);
            } else if (this.child?.signalCode) {
              err = new PrismaClientInitializationError(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${prismaPath} is not corrupt.
` + msg, this.clientVersion);
            } else {
              err = new PrismaClientInitializationError(msg, this.clientVersion);
            }
            this.engineStartDeferred.reject(err);
          }
          if (!this.child) {
            return;
          }
          if (this.lastRustError) {
            return;
          }
          if (code === 126) {
            this.setError({
              timestamp: new Date(),
              target: "exit",
              level: "error",
              fields: {
                message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`
              }
            });
          }
        });
        this.child.on("error", (err) => {
          this.setError({
            message: err.message,
            backtrace: "Could not start query engine",
            is_panic: false
          });
          reject2(err);
        });
        this.child.on("close", (code, signal) => {
          this.connection.close();
          if (code === null && signal === "SIGABRT" && this.child) {
            const error2 = new PrismaClientRustPanicError(this.getErrorMessageWithLink("Panic in Query Engine with SIGABRT signal"), this.clientVersion);
            this.logEmitter.emit("error", error2);
          } else if (code === 255 && signal === null && this.lastErrorLog?.fields.message === "PANIC" && !this.lastPanic) {
            const error2 = new PrismaClientRustPanicError(this.getErrorMessageWithLink(`${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`), this.clientVersion);
            this.setError(error2);
          }
        });
        if (this.lastRustError) {
          return reject2(new PrismaClientInitializationError(getMessage(this.lastRustError), this.clientVersion));
        }
        if (this.lastErrorLog) {
          return reject2(new PrismaClientInitializationError(getMessage(this.lastErrorLog), this.clientVersion));
        }
        try {
          await new Promise((resolve22, reject22) => {
            this.engineStartDeferred = { resolve: resolve22, reject: reject22 };
          });
        } catch (err) {
          this.child?.kill();
          throw err;
        }
        void (async () => {
          try {
            const engineVersion = await this.version(true);
            debug5(`Client Version: ${this.clientVersion}`);
            debug5(`Engine Version: ${engineVersion}`);
            debug5(`Active provider: ${this.activeProvider}`);
          } catch (e) {
            debug5(e);
          }
        })();
        this.stopPromise = void 0;
        resolve2();
      } catch (e) {
        reject2(e);
      }
    });
  }
  async stop() {
    if (!this.stopPromise) {
      this.stopPromise = this._stop();
    }
    return this.stopPromise;
  }
  async _stop() {
    if (this.startPromise) {
      await this.startPromise;
    }
    await new Promise((resolve2) => process.nextTick(resolve2));
    if (this.currentRequestPromise) {
      try {
        await this.currentRequestPromise;
      } catch (e) {
      }
    }
    this.getConfigPromise = void 0;
    let stopChildPromise;
    if (this.child) {
      debug5(`Stopping Prisma engine4`);
      if (this.startPromise) {
        debug5(`Waiting for start promise`);
        await this.startPromise;
      }
      debug5(`Done waiting for start promise`);
      stopChildPromise = new Promise((resolve2, reject2) => {
        this.engineStopDeferred = { resolve: resolve2, reject: reject2 };
      });
      this.connection.close();
      this.child?.kill();
      this.child = void 0;
    }
    if (stopChildPromise) {
      await stopChildPromise;
    }
    await new Promise((r) => process.nextTick(r));
    this.startPromise = void 0;
    this.engineStopDeferred = void 0;
  }
  kill(signal) {
    this.getConfigPromise = void 0;
    this.globalKillSignalReceived = signal;
    this.child?.kill();
    this.connection.close();
  }
  getFreePort() {
    return new Promise((resolve2, reject2) => {
      const server = net.createServer((s) => s.end(""));
      server.unref();
      server.on("error", reject2);
      server.listen(0, () => {
        const address = server.address();
        const port = typeof address === "string" ? parseInt(address.split(":").slice(-1)[0], 10) : address.port;
        server.close((e) => {
          if (e) {
            reject2(e);
          }
          resolve2(port);
        });
      });
    });
  }
  async getConfig() {
    if (!this.getConfigPromise) {
      this.getConfigPromise = this._getConfig();
    }
    return this.getConfigPromise;
  }
  async _getConfig() {
    const prismaPath = await this.getPrismaPath();
    const env = await this.getEngineEnvVars();
    const result = await (0, import_execa.default)(prismaPath, ["cli", "get-config"], {
      env: omit2(env, ["PORT"]),
      cwd: this.cwd
    });
    return JSON.parse(result.stdout);
  }
  async version(forceRun = false) {
    if (this.versionPromise && !forceRun) {
      return this.versionPromise;
    }
    this.versionPromise = this.internalVersion();
    return this.versionPromise;
  }
  async internalVersion() {
    const prismaPath = await this.getPrismaPath();
    const result = await (0, import_execa.default)(prismaPath, ["--version"]);
    this.lastVersion = result.stdout;
    return this.lastVersion;
  }
  async request(query2, headers = {}, numTry = 1) {
    await this.start();
    this.currentRequestPromise = this.connection.post("/", stringifyQuery(query2), runtimeHeadersToHttpHeaders(headers));
    this.lastQuery = query2;
    try {
      const { data, headers: headers2 } = await this.currentRequestPromise;
      if (data.errors) {
        if (data.errors.length === 1) {
          throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);
        }
        throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.clientVersion);
      }
      const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
      if (this.startCount > 0) {
        this.startCount = 0;
      }
      this.currentRequestPromise = void 0;
      return { data, elapsed };
    } catch (e) {
      logger("req - e", e);
      if (e instanceof PrismaClientKnownRequestError) {
        throw e;
      }
      await this.handleRequestError(e, numTry <= MAX_REQUEST_RETRIES);
      if (numTry <= MAX_REQUEST_RETRIES) {
        logger("trying a retry now");
        return this.request(query2, headers, numTry + 1);
      }
    }
    return null;
  }
  async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {
    await this.start();
    const request4 = {
      batch: queries.map((query2) => ({ query: query2, variables: {} })),
      transaction
    };
    this.lastQuery = JSON.stringify(request4);
    this.currentRequestPromise = this.connection.post("/", this.lastQuery, runtimeHeadersToHttpHeaders(headers));
    return this.currentRequestPromise.then(({ data, headers: headers2 }) => {
      const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
      const { batchResult, errors: errors2 } = data;
      if (Array.isArray(batchResult)) {
        return batchResult.map((result) => {
          if (result.errors) {
            throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);
          }
          return {
            data: result,
            elapsed
          };
        });
      } else {
        throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);
      }
    }).catch(async (e) => {
      const isError2 = await this.handleRequestError(e, numTry < 3);
      if (!isError2) {
        if (numTry <= MAX_REQUEST_RETRIES) {
          return this.requestBatch(queries, headers, transaction, numTry + 1);
        }
      }
      throw isError2;
    });
  }
  async transaction(action, arg2) {
    await this.start();
    try {
      if (action === "start") {
        const jsonOptions = JSON.stringify({
          max_wait: arg2?.maxWait ?? 2e3,
          timeout: arg2?.timeout ?? 5e3
        });
        const result = await Connection.onHttpError(this.connection.post("/transaction/start", jsonOptions), transactionHttpErrorHandler);
        return result.data;
      } else if (action === "commit") {
        await Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/commit`), transactionHttpErrorHandler);
      } else if (action === "rollback") {
        await Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/rollback`), transactionHttpErrorHandler);
      }
    } catch (e) {
      this.setError(e);
    }
    return void 0;
  }
  get hasMaxRestarts() {
    return this.startCount >= MAX_STARTS;
  }
  throwAsyncErrorIfExists(forceThrow = false) {
    logger("throwAsyncErrorIfExists", this.startCount, this.hasMaxRestarts);
    if (this.lastRustError) {
      const err = new PrismaClientRustPanicError(this.getErrorMessageWithLink(getMessage(this.lastRustError)), this.clientVersion);
      if (this.lastRustError.is_panic) {
        this.lastPanic = err;
      }
      if (this.hasMaxRestarts || forceThrow) {
        throw err;
      }
    }
    if (this.lastErrorLog && isRustErrorLog(this.lastErrorLog)) {
      const err = new PrismaClientUnknownRequestError(this.getErrorMessageWithLink(getMessage(this.lastErrorLog)), this.clientVersion);
      if (this.lastErrorLog?.fields?.message === "PANIC") {
        this.lastPanic = err;
      }
      if (this.hasMaxRestarts || forceThrow) {
        throw err;
      }
    }
  }
  getErrorMessageWithLink(title) {
    return getErrorMessageWithLink({
      platform: this.platform,
      title,
      version: this.clientVersion,
      engineVersion: this.lastVersion,
      database: this.lastActiveProvider,
      query: this.lastQuery
    });
  }
};
__name(BinaryEngine, "BinaryEngine");
__name19(BinaryEngine, "BinaryEngine");
function stringifyQuery(q) {
  return `{"variables":{},"query":${JSON.stringify(q)}}`;
}
__name(stringifyQuery, "stringifyQuery");
__name19(stringifyQuery, "stringifyQuery");
function hookProcess2(handler, exit = false) {
  process.once(handler, async () => {
    for (const engine of engines2) {
      await engine.emitExit();
      engine.kill(handler);
    }
    engines2.splice(0, engines2.length);
    if (socketPaths.length > 0) {
      for (const socketPath of socketPaths) {
        try {
          fs3.unlinkSync(socketPath);
        } catch (e) {
        }
      }
    }
    if (exit && process.listenerCount(handler) === 0) {
      process.exit();
    }
  });
}
__name(hookProcess2, "hookProcess");
__name19(hookProcess2, "hookProcess");
var hooksInitialized2 = false;
function initHooks2() {
  if (!hooksInitialized2) {
    hookProcess2("beforeExit");
    hookProcess2("exit");
    hookProcess2("SIGINT", true);
    hookProcess2("SIGUSR2", true);
    hookProcess2("SIGTERM", true);
    hooksInitialized2 = true;
  }
}
__name(initHooks2, "initHooks");
__name19(initHooks2, "initHooks");
function transactionHttpErrorHandler(result) {
  throw result.data;
}
__name(transactionHttpErrorHandler, "transactionHttpErrorHandler");
__name19(transactionHttpErrorHandler, "transactionHttpErrorHandler");
function runtimeHeadersToHttpHeaders(headers) {
  return Object.keys(headers).reduce((acc, runtimeHeaderKey) => {
    let httpHeaderKey = runtimeHeaderKey;
    if (runtimeHeaderKey === "transactionId") {
      httpHeaderKey = "X-transaction-id";
    }
    acc[httpHeaderKey] = headers[runtimeHeaderKey];
    return acc;
  }, {});
}
__name(runtimeHeadersToHttpHeaders, "runtimeHeadersToHttpHeaders");
__name19(runtimeHeadersToHttpHeaders, "runtimeHeadersToHttpHeaders");

// ../engine-core/dist/esm/data-proxy/utils/getJSRuntimeName.mjs
var __defProp21 = Object.defineProperty;
var __name20 = /* @__PURE__ */ __name((target, value) => __defProp21(target, "name", { value, configurable: true }), "__name");
function getJSRuntimeName() {
  if (typeof self === "undefined") {
    return "node";
  }
  return "browser";
}
__name(getJSRuntimeName, "getJSRuntimeName");
__name20(getJSRuntimeName, "getJSRuntimeName");

// ../engine-core/dist/esm/data-proxy/utils/request.mjs
var __defProp22 = Object.defineProperty;
var __name21 = /* @__PURE__ */ __name((target, value) => __defProp22(target, "name", { value, configurable: true }), "__name");
async function request3(url2, options2 = {}) {
  const jsRuntimeName = getJSRuntimeName();
  if (jsRuntimeName === "browser") {
    return fetch(url2, options2);
  } else {
    return nodeFetch(url2, options2);
  }
}
__name(request3, "request");
__name21(request3, "request");
function buildHeaders(options2) {
  return {
    ...options2.headers,
    "Content-Type": "application/json"
  };
}
__name(buildHeaders, "buildHeaders");
__name21(buildHeaders, "buildHeaders");
function buildOptions(options2) {
  return {
    method: options2.method,
    headers: buildHeaders(options2)
  };
}
__name(buildOptions, "buildOptions");
__name21(buildOptions, "buildOptions");
function buildResponse(incomingData2, response) {
  return {
    json: () => JSON.parse(Buffer.concat(incomingData2).toString()),
    ok: response.statusCode >= 200 && response.statusCode < 300,
    status: response.statusCode,
    url: response.url
  };
}
__name(buildResponse, "buildResponse");
__name21(buildResponse, "buildResponse");
function nodeFetch(url, options = {}) {
  const httpsOptions = buildOptions(options);
  const incomingData = [];
  return new Promise((resolve, reject) => {
    const https = eval(`require('https')`);
    const request = https.request(url, httpsOptions, (response) => {
      response.on("data", (chunk) => incomingData.push(chunk));
      response.on("end", () => resolve(buildResponse(incomingData, response)));
      response.on("error", reject);
    });
    request.on("error", reject);
    request.write(options.body ?? "");
    request.end();
  });
}
__name(nodeFetch, "nodeFetch");
__name21(nodeFetch, "nodeFetch");

// ../engine-core/dist/esm/data-proxy/DataProxyEngine.mjs
import EventEmitter3 from "events";

// ../engine-core/dist/esm/data-proxy/utils/backOff.mjs
var __defProp23 = Object.defineProperty;
var __name22 = /* @__PURE__ */ __name((target, value) => __defProp23(target, "name", { value, configurable: true }), "__name");
var BACKOFF_INTERVAL = 50;
function backOff(n) {
  const baseDelay = Math.pow(2, n) * BACKOFF_INTERVAL;
  const jitter = Math.ceil(Math.random() * baseDelay) - Math.ceil(baseDelay / 2);
  const total = baseDelay + jitter;
  return new Promise((done) => setTimeout(() => done(total), total));
}
__name(backOff, "backOff");
__name22(backOff, "backOff");

// ../engine-core/dist/esm/data-proxy/utils/getClientVersion.mjs
var __defProp24 = Object.defineProperty;
var __name23 = /* @__PURE__ */ __name((target, value) => __defProp24(target, "name", { value, configurable: true }), "__name");
function getClientVersion(config2) {
  const [version, suffix] = config2.clientVersion?.split("-") ?? [];
  if (!suffix && /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/.test(version)) {
    return version;
  }
  return "3.4.1";
}
__name(getClientVersion, "getClientVersion");
__name23(getClientVersion, "getClientVersion");

// ../engine-core/dist/esm/common/errors/PrismaClientError.mjs
var __defProp25 = Object.defineProperty;
var __name24 = /* @__PURE__ */ __name((target, value) => __defProp25(target, "name", { value, configurable: true }), "__name");
var PrismaClientError = class extends Error {
  constructor(message, info2) {
    super(message);
    this.clientVersion = info2.clientVersion;
    this.cause = info2.cause;
  }
  get [Symbol.toStringTag]() {
    return this.name;
  }
};
__name(PrismaClientError, "PrismaClientError");
__name24(PrismaClientError, "PrismaClientError");

// ../engine-core/dist/esm/data-proxy/errors/DataProxyError.mjs
var __defProp26 = Object.defineProperty;
var __name25 = /* @__PURE__ */ __name((target, value) => __defProp26(target, "name", { value, configurable: true }), "__name");
var DataProxyError = class extends PrismaClientError {
  constructor(message, info2) {
    super(message, info2);
    this.isRetryable = info2.isRetryable ?? true;
  }
};
__name(DataProxyError, "DataProxyError");
__name25(DataProxyError, "DataProxyError");

// ../engine-core/dist/esm/data-proxy/errors/DataProxyAPIError.mjs
var __defProp27 = Object.defineProperty;
var __name26 = /* @__PURE__ */ __name((target, value) => __defProp27(target, "name", { value, configurable: true }), "__name");
var DataProxyAPIError = class extends DataProxyError {
  constructor(message, info2) {
    super(message, info2);
    this.response = info2.response;
  }
};
__name(DataProxyAPIError, "DataProxyAPIError");
__name26(DataProxyAPIError, "DataProxyAPIError");

// ../engine-core/dist/esm/data-proxy/errors/utils/setRetryable.mjs
var __defProp28 = Object.defineProperty;
var __name27 = /* @__PURE__ */ __name((target, value) => __defProp28(target, "name", { value, configurable: true }), "__name");
function setRetryable(info2, retryable) {
  return {
    ...info2,
    isRetryable: retryable
  };
}
__name(setRetryable, "setRetryable");
__name27(setRetryable, "setRetryable");

// ../engine-core/dist/esm/data-proxy/errors/BadRequestError.mjs
var __defProp29 = Object.defineProperty;
var __name28 = /* @__PURE__ */ __name((target, value) => __defProp29(target, "name", { value, configurable: true }), "__name");
var BadRequestError = class extends DataProxyAPIError {
  constructor(info2) {
    super("This request could not be understood by the server", setRetryable(info2, false));
    this.name = "BadRequestError";
    this.code = "P5000";
  }
};
__name(BadRequestError, "BadRequestError");
__name28(BadRequestError, "BadRequestError");

// ../engine-core/dist/esm/data-proxy/errors/NotFoundError.mjs
var __defProp30 = Object.defineProperty;
var __name29 = /* @__PURE__ */ __name((target, value) => __defProp30(target, "name", { value, configurable: true }), "__name");
var NotFoundError = class extends DataProxyAPIError {
  constructor(info2) {
    super("Requested resource does not exist", setRetryable(info2, false));
    this.name = "NotFoundError";
    this.code = "P5003";
  }
};
__name(NotFoundError, "NotFoundError");
__name29(NotFoundError, "NotFoundError");

// ../engine-core/dist/esm/data-proxy/errors/SchemaMissingError.mjs
var __defProp31 = Object.defineProperty;
var __name30 = /* @__PURE__ */ __name((target, value) => __defProp31(target, "name", { value, configurable: true }), "__name");
var SchemaMissingError = class extends DataProxyAPIError {
  constructor(info2) {
    super("Schema needs to be uploaded", setRetryable(info2, true));
    this.name = "SchemaMissingError";
    this.code = "P5005";
  }
};
__name(SchemaMissingError, "SchemaMissingError");
__name30(SchemaMissingError, "SchemaMissingError");

// ../engine-core/dist/esm/data-proxy/errors/ServerError.mjs
var __defProp32 = Object.defineProperty;
var __name31 = /* @__PURE__ */ __name((target, value) => __defProp32(target, "name", { value, configurable: true }), "__name");
var ServerError = class extends DataProxyAPIError {
  constructor(info2) {
    super("Unknown server error", setRetryable(info2, true));
    this.name = "ServerError";
    this.code = "P5006";
  }
};
__name(ServerError, "ServerError");
__name31(ServerError, "ServerError");

// ../engine-core/dist/esm/data-proxy/errors/UnauthorizedError.mjs
var __defProp33 = Object.defineProperty;
var __name32 = /* @__PURE__ */ __name((target, value) => __defProp33(target, "name", { value, configurable: true }), "__name");
var UnauthorizedError = class extends DataProxyAPIError {
  constructor(info2) {
    super("Unauthorized, check your connection string", setRetryable(info2, false));
    this.name = "UnauthorizedError";
    this.code = "P5007";
  }
};
__name(UnauthorizedError, "UnauthorizedError");
__name32(UnauthorizedError, "UnauthorizedError");

// ../engine-core/dist/esm/data-proxy/errors/UsageExceededError.mjs
var __defProp34 = Object.defineProperty;
var __name33 = /* @__PURE__ */ __name((target, value) => __defProp34(target, "name", { value, configurable: true }), "__name");
var UsageExceededError = class extends DataProxyAPIError {
  constructor(info2) {
    super("Usage exceeded, retry again later", setRetryable(info2, true));
    this.name = "UsageExceededError";
    this.code = "P5008";
  }
};
__name(UsageExceededError, "UsageExceededError");
__name33(UsageExceededError, "UsageExceededError");

// ../engine-core/dist/esm/data-proxy/errors/utils/responseToError.mjs
var __defProp35 = Object.defineProperty;
var __name34 = /* @__PURE__ */ __name((target, value) => __defProp35(target, "name", { value, configurable: true }), "__name");
async function responseToError(response, clientVersion2) {
  if (response.ok)
    return void 0;
  const info2 = { clientVersion: clientVersion2, response };
  if (response.status === 401) {
    throw new UnauthorizedError(info2);
  }
  if (response.status === 404) {
    try {
      const body = await response.json();
      const isSchemaMissing = body?.EngineNotStarted?.reason === "SchemaMissing";
      return isSchemaMissing ? new SchemaMissingError(info2) : new NotFoundError(info2);
    } catch (err) {
      return new NotFoundError(info2);
    }
  }
  if (response.status === 429) {
    throw new UsageExceededError(info2);
  }
  if (response.status >= 500) {
    throw new ServerError(info2);
  }
  if (response.status >= 400) {
    throw new BadRequestError(info2);
  }
  return void 0;
}
__name(responseToError, "responseToError");
__name34(responseToError, "responseToError");

// ../engine-core/dist/esm/data-proxy/errors/InvalidDatasourceError.mjs
var __defProp36 = Object.defineProperty;
var __name35 = /* @__PURE__ */ __name((target, value) => __defProp36(target, "name", { value, configurable: true }), "__name");
var InvalidDatasourceError = class extends DataProxyError {
  constructor(message, info2) {
    super(message, setRetryable(info2, false));
    this.name = "InvalidDatasourceError";
    this.code = "P5002";
  }
};
__name(InvalidDatasourceError, "InvalidDatasourceError");
__name35(InvalidDatasourceError, "InvalidDatasourceError");

// ../engine-core/dist/esm/data-proxy/errors/NotImplementedYetError.mjs
var __defProp37 = Object.defineProperty;
var __name36 = /* @__PURE__ */ __name((target, value) => __defProp37(target, "name", { value, configurable: true }), "__name");
var NotImplementedYetError = class extends DataProxyError {
  constructor(message, info2) {
    super(message, setRetryable(info2, false));
    this.name = "NotImplementedYetError";
    this.code = "P5004";
  }
};
__name(NotImplementedYetError, "NotImplementedYetError");
__name36(NotImplementedYetError, "NotImplementedYetError");

// ../engine-core/dist/esm/data-proxy/errors/ForcedRetryError.mjs
var __defProp38 = Object.defineProperty;
var __name37 = /* @__PURE__ */ __name((target, value) => __defProp38(target, "name", { value, configurable: true }), "__name");
var ForcedRetryError = class extends DataProxyError {
  constructor(info2) {
    super("This request must be retried", setRetryable(info2, true));
    this.name = "ForcedRetryError";
    this.code = "P5001";
  }
};
__name(ForcedRetryError, "ForcedRetryError");
__name37(ForcedRetryError, "ForcedRetryError");

// ../engine-core/dist/esm/data-proxy/DataProxyEngine.mjs
var __defProp39 = Object.defineProperty;
var __name38 = /* @__PURE__ */ __name((target, value) => __defProp39(target, "name", { value, configurable: true }), "__name");
var MAX_RETRIES = 10;
var DataProxyEngine = class extends Engine {
  constructor(config2) {
    super();
    this.config = config2;
    this.env = this.config.env ?? {};
    this.inlineSchema = config2.inlineSchema ?? "";
    this.inlineDatasources = config2.inlineDatasources ?? {};
    this.inlineSchemaHash = config2.inlineSchemaHash ?? "";
    this.clientVersion = config2.clientVersion ?? "unknown";
    this.logEmitter = new EventEmitter3();
    this.logEmitter.on("error", () => {
    });
    const [host, apiKey] = this.extractHostAndApiKey();
    this.remoteClientVersion = getClientVersion(this.config);
    this.headers = { Authorization: `Bearer ${apiKey}` };
    this.host = host;
    const promise = Promise.resolve();
    this.pushPromise = promise.then(() => this.pushSchema());
  }
  async pushSchema() {
    const response = await request3(this.url("schema"), {
      method: "GET",
      headers: this.headers
    });
    if (response.status === 404) {
      await this.uploadSchema();
    }
  }
  version() {
    return "unknown";
  }
  async start() {
  }
  async stop() {
  }
  on(event, listener) {
    if (event === "beforeExit") {
      throw new NotImplementedYetError("beforeExit event is not yet supported", {
        clientVersion: this.clientVersion
      });
    } else {
      this.logEmitter.on(event, listener);
    }
  }
  url(s) {
    return `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${s}`;
  }
  async getConfig() {
    return Promise.resolve({
      datasources: [
        {
          activeProvider: this.config.activeProvider
        }
      ]
    });
  }
  async uploadSchema() {
    const response = await request3(this.url("schema"), {
      method: "PUT",
      headers: this.headers,
      body: this.inlineSchema
    });
    const err = await responseToError(response, this.clientVersion);
    if (err) {
      this.logEmitter.emit("warn", { message: `Error while uploading schema: ${err.message}` });
      throw err;
    } else {
      this.logEmitter.emit("info", {
        message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`
      });
    }
  }
  request(query2, headers, attempt = 0) {
    this.logEmitter.emit("query", { query: query2 });
    return this.requestInternal({ query: query2, variables: {} }, headers, attempt);
  }
  async requestBatch(queries, headers, isTransaction = false, attempt = 0) {
    this.logEmitter.emit("query", {
      query: `Batch${isTransaction ? " in transaction" : ""} (${queries.length}):
${queries.join("\n")}`
    });
    const body = {
      batch: queries.map((query2) => ({ query: query2, variables: {} })),
      transaction: isTransaction
    };
    const { batchResult } = await this.requestInternal(body, headers, attempt);
    return batchResult;
  }
  async requestInternal(body, headers, attempt) {
    await this.pushPromise;
    try {
      this.logEmitter.emit("info", {
        message: `Calling ${this.url("graphql")} (n=${attempt})`
      });
      const response = await request3(this.url("graphql"), {
        method: "POST",
        headers: { ...headers, ...this.headers },
        body: JSON.stringify(body)
      });
      const err = await responseToError(response, this.clientVersion);
      if (err instanceof SchemaMissingError) {
        await this.uploadSchema();
        throw new ForcedRetryError({
          clientVersion: this.clientVersion,
          cause: err
        });
      }
      if (err) {
        throw err;
      }
      const data = await response.json();
      if (data.errors) {
        if (data.errors.length === 1) {
          throw prismaGraphQLToJSError(data.errors[0], this.config.clientVersion);
        }
      }
      return data;
    } catch (err) {
      this.logEmitter.emit("error", {
        message: `Error while querying: ${err.message ?? "(unknown)"}`
      });
      if (!(err instanceof DataProxyError)) {
        throw err;
      }
      if (!err.isRetryable) {
        throw err;
      }
      if (attempt >= MAX_RETRIES) {
        if (err instanceof ForcedRetryError) {
          throw err.cause;
        } else {
          throw err;
        }
      }
      this.logEmitter.emit("warn", { message: "This request can be retried" });
      const delay = await backOff(attempt);
      this.logEmitter.emit("warn", { message: `Retrying after ${delay}ms` });
      return this.requestInternal(body, headers, attempt + 1);
    }
  }
  transaction() {
    throw new NotImplementedYetError("Interactive transactions are not yet supported", {
      clientVersion: this.clientVersion
    });
  }
  extractHostAndApiKey() {
    const mainDatasourceName = Object.keys(this.inlineDatasources)[0];
    const mainDatasource = this.inlineDatasources[mainDatasourceName];
    const mainDatasourceURL = mainDatasource?.url.value;
    const mainDatasourceEnv = mainDatasource?.url.fromEnvVar;
    const loadedEnvURL = this.env[mainDatasourceEnv];
    const dataProxyURL = mainDatasourceURL ?? loadedEnvURL;
    let url2;
    try {
      url2 = new URL(dataProxyURL ?? "");
    } catch {
      throw new InvalidDatasourceError("Could not parse URL of the datasource", {
        clientVersion: this.clientVersion
      });
    }
    const { protocol, host, searchParams } = url2;
    if (protocol !== "prisma:") {
      throw new InvalidDatasourceError("Datasource URL should use prisma:// protocol", {
        clientVersion: this.clientVersion
      });
    }
    const apiKey = searchParams.get("api_key");
    if (apiKey === null || apiKey.length < 1) {
      throw new InvalidDatasourceError("No valid API key found in the datasource URL", {
        clientVersion: this.clientVersion
      });
    }
    return [host, apiKey];
  }
};
__name(DataProxyEngine, "DataProxyEngine");
__name38(DataProxyEngine, "DataProxyEngine");

// src/runtime/getPrismaClient.ts
var import_debug9 = __toModule2(require_dist7());

// ../sdk/dist/esm/client/getClientEngineType.mjs
var __defProp40 = Object.defineProperty;
var __name39 = /* @__PURE__ */ __name((target, value) => __defProp40(target, "name", { value, configurable: true }), "__name");
var ClientEngineType;
(function(ClientEngineType2) {
  ClientEngineType2["Library"] = "library";
  ClientEngineType2["Binary"] = "binary";
  ClientEngineType2["DataProxy"] = "dataproxy";
})(ClientEngineType || (ClientEngineType = {}));
var DEFAULT_CLIENT_ENGINE_TYPE = ClientEngineType.Library;
function getClientEngineType(generatorConfig) {
  const engineTypeFromEnvVar = getEngineTypeFromEnvVar();
  if (engineTypeFromEnvVar)
    return engineTypeFromEnvVar;
  if (generatorConfig?.config.engineType === ClientEngineType.Library) {
    return ClientEngineType.Library;
  } else if (generatorConfig?.config.engineType === ClientEngineType.Binary) {
    return ClientEngineType.Binary;
  } else if (generatorConfig?.config.engineType === ClientEngineType.DataProxy) {
    return ClientEngineType.DataProxy;
  } else {
    return DEFAULT_CLIENT_ENGINE_TYPE;
  }
}
__name(getClientEngineType, "getClientEngineType");
__name39(getClientEngineType, "getClientEngineType");
function getEngineTypeFromEnvVar() {
  const engineType = process.env.PRISMA_CLIENT_ENGINE_TYPE;
  if (engineType === ClientEngineType.Library) {
    return ClientEngineType.Library;
  } else if (engineType === ClientEngineType.Binary) {
    return ClientEngineType.Binary;
  } else if (engineType === ClientEngineType.DataProxy) {
    return ClientEngineType.DataProxy;
  } else {
    return void 0;
  }
}
__name(getEngineTypeFromEnvVar, "getEngineTypeFromEnvVar");
__name39(getEngineTypeFromEnvVar, "getEngineTypeFromEnvVar");

// ../sdk/dist/esm/cli/utils.mjs
var import_strip_indent2 = __toModule2(require_strip_indent());
var import_arg = __toModule2(require_arg());
var __defProp41 = Object.defineProperty;
var __name40 = /* @__PURE__ */ __name((target, value) => __defProp41(target, "name", { value, configurable: true }), "__name");
function format(input = "") {
  return (0, import_strip_indent2.default)(input).trimRight() + "\n";
}
__name(format, "format");
__name40(format, "format");
function arg(argv, spec, stopAtPositional = true, permissive = false) {
  try {
    return (0, import_arg.default)(spec, { argv, stopAtPositional, permissive });
  } catch (e) {
    return e;
  }
}
__name(arg, "arg");
__name40(arg, "arg");
function isError(result) {
  return result instanceof Error;
}
__name(isError, "isError");
__name40(isError, "isError");

// ../sdk/dist/esm/utils/mapPreviewFeatures.mjs
var __defProp42 = Object.defineProperty;
var __name41 = /* @__PURE__ */ __name((target, value) => __defProp42(target, "name", { value, configurable: true }), "__name");
var featureFlagMap = {
  transactionApi: "transaction",
  aggregateApi: "aggregations"
};
function mapPreviewFeatures(features) {
  if (Array.isArray(features) && features.length > 0) {
    return features.map((f) => featureFlagMap[f] ?? f);
  }
  return [];
}
__name(mapPreviewFeatures, "mapPreviewFeatures");
__name41(mapPreviewFeatures, "mapPreviewFeatures");

// ../sdk/dist/esm/logger.mjs
var logger_exports = {};
__export2(logger_exports, {
  error: () => error,
  info: () => info,
  log: () => log3,
  query: () => query,
  should: () => should,
  tags: () => tags,
  warn: () => warn
});
var import_chalk9 = __toModule2(require_source2());
var __defProp43 = Object.defineProperty;
var __name42 = /* @__PURE__ */ __name((target, value) => __defProp43(target, "name", { value, configurable: true }), "__name");
var tags = {
  error: import_chalk9.default.red("prisma:error"),
  warn: import_chalk9.default.yellow("prisma:warn"),
  info: import_chalk9.default.cyan("prisma:info"),
  query: import_chalk9.default.blue("prisma:query")
};
var should = {
  warn: !process.env.PRISMA_DISABLE_WARNINGS
};
function log3(...data) {
  console.log(...data);
}
__name(log3, "log");
__name42(log3, "log");
function warn(message, ...optionalParams) {
  if (should.warn) {
    console.warn(`${tags.warn} ${message}`, ...optionalParams);
  }
}
__name(warn, "warn");
__name42(warn, "warn");
function info(message, ...optionalParams) {
  console.info(`${tags.info} ${message}`, ...optionalParams);
}
__name(info, "info");
__name42(info, "info");
function error(message, ...optionalParams) {
  console.error(`${tags.error} ${message}`, ...optionalParams);
}
__name(error, "error");
__name42(error, "error");
function query(message, ...optionalParams) {
  console.log(`${tags.query} ${message}`, ...optionalParams);
}
__name(query, "query");
__name42(query, "query");

// ../sdk/dist/esm/utils/tryLoadEnvs.mjs
var import_chalk10 = __toModule2(require_source2());
var import_debug6 = __toModule2(require_dist7());
var import_dotenv = __toModule2(require_main3());
import fs4 from "fs";
import path3 from "path";

// ../sdk/dist/esm/dotenvExpand.mjs
var __defProp44 = Object.defineProperty;
var __name43 = /* @__PURE__ */ __name((target, value) => __defProp44(target, "name", { value, configurable: true }), "__name");
function dotenvExpand(config2) {
  const environment = config2.ignoreProcessEnv ? {} : process.env;
  const interpolate = /* @__PURE__ */ __name43((envValue) => {
    const matches = envValue.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g) || [];
    return matches.reduce(function(newEnv, match) {
      const parts = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(match);
      if (!parts) {
        return newEnv;
      }
      const prefix = parts[1];
      let value, replacePart;
      if (prefix === "\\") {
        replacePart = parts[0];
        value = replacePart.replace("\\$", "$");
      } else {
        const key = parts[2];
        replacePart = parts[0].substring(prefix.length);
        value = Object.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || "";
        value = interpolate(value);
      }
      return newEnv.replace(replacePart, value);
    }, envValue);
  }, "interpolate");
  for (const configKey in config2.parsed) {
    const value = Object.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];
    config2.parsed[configKey] = interpolate(value);
  }
  for (const processKey in config2.parsed) {
    environment[processKey] = config2.parsed[processKey];
  }
  return config2;
}
__name(dotenvExpand, "dotenvExpand");
__name43(dotenvExpand, "dotenvExpand");

// ../sdk/dist/esm/utils/tryLoadEnvs.mjs
var __defProp45 = Object.defineProperty;
var __name44 = /* @__PURE__ */ __name((target, value) => __defProp45(target, "name", { value, configurable: true }), "__name");
var debug6 = (0, import_debug6.default)("prisma:tryLoadEnv");
function tryLoadEnvs({
  rootEnvPath,
  schemaEnvPath
}, opts2 = {
  conflictCheck: "none"
}) {
  const rootEnvInfo = loadEnv(rootEnvPath);
  if (opts2.conflictCheck !== "none") {
    checkForConflicts(rootEnvInfo, schemaEnvPath, opts2.conflictCheck);
  }
  let schemaEnvInfo = null;
  if (!pathsEqual(rootEnvInfo?.path, schemaEnvPath)) {
    schemaEnvInfo = loadEnv(schemaEnvPath);
  }
  if (!rootEnvInfo && !schemaEnvInfo) {
    debug6("No Environment variables loaded");
  }
  if (schemaEnvInfo?.dotenvResult.error) {
    return console.error(import_chalk10.default.redBright.bold("Schema Env Error: ") + schemaEnvInfo.dotenvResult.error);
  }
  const messages = [rootEnvInfo?.message, schemaEnvInfo?.message].filter(Boolean);
  return {
    message: messages.join("\n"),
    parsed: {
      ...rootEnvInfo?.dotenvResult?.parsed,
      ...schemaEnvInfo?.dotenvResult?.parsed
    }
  };
}
__name(tryLoadEnvs, "tryLoadEnvs");
__name44(tryLoadEnvs, "tryLoadEnvs");
function checkForConflicts(rootEnvInfo, envPath, type) {
  const parsedRootEnv = rootEnvInfo?.dotenvResult.parsed;
  const areNotTheSame = !pathsEqual(rootEnvInfo?.path, envPath);
  if (parsedRootEnv && envPath && areNotTheSame && fs4.existsSync(envPath)) {
    const envConfig = import_dotenv.default.parse(fs4.readFileSync(envPath));
    const conflicts = [];
    for (const k in envConfig) {
      if (parsedRootEnv[k] === envConfig[k]) {
        conflicts.push(k);
      }
    }
    if (conflicts.length > 0) {
      const relativeRootEnvPath = path3.relative(process.cwd(), rootEnvInfo.path);
      const relativeEnvPath = path3.relative(process.cwd(), envPath);
      if (type === "error") {
        const message = `There is a conflict between env var${conflicts.length > 1 ? "s" : ""} in ${import_chalk10.default.underline(relativeRootEnvPath)} and ${import_chalk10.default.underline(relativeEnvPath)}
Conflicting env vars:
${conflicts.map((conflict) => `  ${import_chalk10.default.bold(conflict)}`).join("\n")}

We suggest to move the contents of ${import_chalk10.default.underline(relativeEnvPath)} to ${import_chalk10.default.underline(relativeRootEnvPath)} to consolidate your env vars.
`;
        throw new Error(message);
      } else if (type === "warn") {
        const message = `Conflict for env var${conflicts.length > 1 ? "s" : ""} ${conflicts.map((c) => import_chalk10.default.bold(c)).join(", ")} in ${import_chalk10.default.underline(relativeRootEnvPath)} and ${import_chalk10.default.underline(relativeEnvPath)}
Env vars from ${import_chalk10.default.underline(relativeEnvPath)} overwrite the ones from ${import_chalk10.default.underline(relativeRootEnvPath)}
      `;
        console.warn(`${import_chalk10.default.yellow("warn(prisma)")} ${message}`);
      }
    }
  }
}
__name(checkForConflicts, "checkForConflicts");
__name44(checkForConflicts, "checkForConflicts");
function loadEnv(envPath) {
  if (exists3(envPath)) {
    debug6(`Environment variables loaded from ${envPath}`);
    return {
      dotenvResult: dotenvExpand(import_dotenv.default.config({
        path: envPath
      })),
      message: import_chalk10.default.dim(`Environment variables loaded from ${path3.relative(process.cwd(), envPath)}`),
      path: envPath
    };
  } else {
    debug6(`Environment variables not found at ${envPath}`);
  }
  return null;
}
__name(loadEnv, "loadEnv");
__name44(loadEnv, "loadEnv");
function pathsEqual(path1, path22) {
  return path1 && path22 && path3.resolve(path1) === path3.resolve(path22);
}
__name(pathsEqual, "pathsEqual");
__name44(pathsEqual, "pathsEqual");
function exists3(p) {
  return Boolean(p && fs4.existsSync(p));
}
__name(exists3, "exists");
__name44(exists3, "exists");

// ../sdk/dist/esm/index.mjs
var import_get_platform3 = __toModule2(require_dist9());

// src/runtime/getPrismaClient.ts
var sqlTemplateTag = __toModule2(require_dist10());
import { AsyncResource } from "async_hooks";
import fs5 from "fs";
import path4 from "path";

// src/runtime/getLogLevel.ts
function getLogLevel(log4) {
  if (typeof log4 === "string") {
    return log4;
  }
  return log4.reduce((acc, curr) => {
    const currentLevel = typeof curr === "string" ? curr : curr.level;
    if (currentLevel === "query") {
      return acc;
    }
    if (!acc) {
      return currentLevel;
    }
    if (curr === "info" || acc === "info") {
      return "info";
    }
    return currentLevel;
  }, void 0);
}
__name(getLogLevel, "getLogLevel");

// src/runtime/mergeBy.ts
function mergeBy(arr1, arr2, cb) {
  const groupedArr1 = groupBy(arr1, cb);
  const groupedArr2 = groupBy(arr2, cb);
  const result = Object.values(groupedArr2).map((value) => value[value.length - 1]);
  const arr2Keys = Object.keys(groupedArr2);
  Object.entries(groupedArr1).forEach(([key, value]) => {
    if (!arr2Keys.includes(key)) {
      result.push(value[value.length - 1]);
    }
  });
  return result;
}
__name(mergeBy, "mergeBy");
var groupBy = /* @__PURE__ */ __name((arr, cb) => {
  return arr.reduce((acc, curr) => {
    const key = cb(curr);
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(curr);
    return acc;
  }, {});
}, "groupBy");

// src/runtime/MiddlewareHandler.ts
var MiddlewareHandler = class {
  constructor() {
    this._middlewares = [];
  }
  use(middleware) {
    this._middlewares.push(middleware);
  }
  get(id) {
    return this._middlewares[id];
  }
  has(id) {
    return !!this._middlewares[id];
  }
  length() {
    return this._middlewares.length;
  }
};
__name(MiddlewareHandler, "MiddlewareHandler");
var Middlewares = class {
  constructor() {
    this.query = new MiddlewareHandler();
    this.engine = new MiddlewareHandler();
  }
};
__name(Middlewares, "Middlewares");

// src/runtime/PrismaClientFetcher.ts
var import_debug7 = __toModule2(require_dist7());
var import_strip_ansi4 = __toModule2(require_strip_ansi());

// src/runtime/DataLoader.ts
var DataLoader = class {
  constructor(options2) {
    this.options = options2;
    this.tickActive = false;
    this.batches = {};
  }
  request(request4) {
    const hash = this.options.batchBy(request4);
    if (!hash) {
      return this.options.singleLoader(request4);
    }
    if (!this.batches[hash]) {
      this.batches[hash] = [];
      if (!this.tickActive) {
        this.tickActive = true;
        process.nextTick(() => {
          this.dispatchBatches();
          this.tickActive = false;
        });
      }
    }
    return new Promise((resolve2, reject2) => {
      this.batches[hash].push({
        request: request4,
        resolve: resolve2,
        reject: reject2
      });
    });
  }
  dispatchBatches() {
    for (const key in this.batches) {
      const batch = this.batches[key];
      delete this.batches[key];
      if (batch.length === 1) {
        this.options.singleLoader(batch[0].request).then((result) => {
          if (result instanceof Error) {
            batch[0].reject(result);
          } else {
            batch[0].resolve(result);
          }
        }).catch((e) => {
          batch[0].reject(e);
        });
      } else {
        this.options.batchLoader(batch.map((j) => j.request)).then((results) => {
          if (results instanceof Error) {
            for (let i = 0; i < batch.length; i++) {
              batch[i].reject(results);
            }
          } else {
            for (let i = 0; i < batch.length; i++) {
              const value = results[i];
              if (value instanceof Error) {
                batch[i].reject(value);
              } else {
                batch[i].resolve(value);
              }
            }
          }
        }).catch((e) => {
          for (let i = 0; i < batch.length; i++) {
            batch[i].reject(e);
          }
        });
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "DataLoader";
  }
};
__name(DataLoader, "DataLoader");

// src/runtime/utils/rejectOnNotFound.ts
var NotFoundError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotFoundError";
    this.stack = void 0;
  }
};
__name(NotFoundError2, "NotFoundError");
function getRejectOnNotFound(action, modelName, args, clientInstance) {
  let rejectOnNotFound;
  if (args && typeof args === "object" && "rejectOnNotFound" in args && args["rejectOnNotFound"] !== void 0) {
    rejectOnNotFound = args["rejectOnNotFound"];
    delete args["rejectOnNotFound"];
  } else if (typeof clientInstance === "boolean") {
    rejectOnNotFound = clientInstance;
  } else if (clientInstance && typeof clientInstance === "object" && action in clientInstance) {
    const rejectPerOperation = clientInstance[action];
    if (rejectPerOperation && typeof rejectPerOperation === "object") {
      if (modelName in rejectPerOperation) {
        return rejectPerOperation[modelName];
      }
      return void 0;
    }
    rejectOnNotFound = getRejectOnNotFound(action, modelName, args, rejectPerOperation);
  } else if (typeof clientInstance === "function") {
    rejectOnNotFound = clientInstance;
  } else {
    rejectOnNotFound = false;
  }
  return rejectOnNotFound;
}
__name(getRejectOnNotFound, "getRejectOnNotFound");
var REGEX = /(findUnique|findFirst)/;
function throwIfNotFound(data, clientMethod, typeName, rejectOnNotFound) {
  if (rejectOnNotFound && !data && REGEX.exec(clientMethod)) {
    if (typeof rejectOnNotFound === "boolean" && rejectOnNotFound) {
      throw new NotFoundError2(`No ${typeName} found`);
    } else if (typeof rejectOnNotFound === "function") {
      throw rejectOnNotFound(new NotFoundError2(`No ${typeName} found`));
    } else if (isError(rejectOnNotFound)) {
      throw rejectOnNotFound;
    }
    throw new NotFoundError2(`No ${typeName} found`);
  }
}
__name(throwIfNotFound, "throwIfNotFound");

// src/runtime/PrismaClientFetcher.ts
var debug7 = (0, import_debug7.default)("prisma:client:fetcher");
var PrismaClientFetcher = class {
  constructor(prisma, enableDebug = false, hooks) {
    this.prisma = prisma;
    this.debug = enableDebug;
    this.hooks = hooks;
    this.dataloader = new DataLoader({
      batchLoader: (requests) => {
        const queries = requests.map((r) => String(r.document));
        const runTransaction = requests[0].runInTransaction;
        return this.prisma._engine.requestBatch(queries, {}, runTransaction);
      },
      singleLoader: (request4) => {
        const query2 = String(request4.document);
        return this.prisma._engine.request(query2, request4.headers);
      },
      batchBy: (request4) => {
        if (request4.runInTransaction) {
          if (request4.transactionId) {
            return `transaction-batch-${request4.transactionId}`;
          }
          return "transaction-batch";
        }
        if (!request4.document.children[0].name.startsWith("findUnique")) {
          return void 0;
        }
        const selectionSet = request4.document.children[0].children.join(",");
        const args = request4.document.children[0].args?.args.map((a) => {
          if (a.value instanceof Args) {
            return `${a.key}-${a.value.args.map((a2) => a2.key).join(",")}`;
          }
          return a.key;
        }).join(",");
        return `${request4.document.children[0].name}|${args}|${selectionSet}`;
      }
    });
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientFetcher";
  }
  async request({
    document: document2,
    dataPath = [],
    rootField,
    typeName,
    isList,
    callsite,
    rejectOnNotFound,
    clientMethod,
    runInTransaction,
    showColors,
    engineHook,
    args,
    headers,
    transactionId,
    unpacker
  }) {
    const cb = /* @__PURE__ */ __name(async () => {
      if (this.hooks && this.hooks.beforeRequest) {
        const query2 = String(document2);
        this.hooks.beforeRequest({
          query: query2,
          path: dataPath,
          rootField,
          typeName,
          document: document2,
          isList,
          clientMethod,
          args
        });
      }
      try {
        let data, elapsed;
        if (engineHook) {
          const result = await engineHook({
            document: document2,
            runInTransaction
          }, (params) => this.dataloader.request(params));
          data = result.data;
          elapsed = result.elapsed;
        } else {
          const result = await this.dataloader.request({
            document: document2,
            runInTransaction,
            headers,
            transactionId
          });
          data = result?.data;
          elapsed = result?.elapsed;
        }
        const unpackResult = this.unpack(document2, data, dataPath, rootField, unpacker);
        throwIfNotFound(unpackResult, clientMethod, typeName, rejectOnNotFound);
        if (process.env.PRISMA_CLIENT_GET_TIME) {
          return { data: unpackResult, elapsed };
        }
        return unpackResult;
      } catch (e) {
        debug7(e);
        let message = e.message;
        if (callsite) {
          const { stack } = printStack({
            callsite,
            originalMethod: clientMethod,
            onUs: e.isPanic,
            showColors
          });
          message = `${stack}
  ${e.message}`;
        }
        message = this.sanitizeMessage(message);
        if (e.code) {
          throw new PrismaClientKnownRequestError(message, e.code, this.prisma._clientVersion, e.meta);
        } else if (e.isPanic) {
          throw new PrismaClientRustPanicError(message, this.prisma._clientVersion);
        } else if (e instanceof PrismaClientUnknownRequestError) {
          throw new PrismaClientUnknownRequestError(message, this.prisma._clientVersion);
        } else if (e instanceof PrismaClientInitializationError) {
          throw new PrismaClientInitializationError(message, this.prisma._clientVersion);
        } else if (e instanceof PrismaClientRustPanicError) {
          throw new PrismaClientRustPanicError(message, this.prisma._clientVersion);
        }
        e.clientVersion = this.prisma._clientVersion;
        throw e;
      }
    }, "cb");
    if (transactionId) {
      return cb;
    } else {
      return cb();
    }
  }
  sanitizeMessage(message) {
    if (this.prisma._errorFormat && this.prisma._errorFormat !== "pretty") {
      return (0, import_strip_ansi4.default)(message);
    }
    return message;
  }
  unpack(document2, data, path6, rootField, unpacker) {
    if (data?.data) {
      data = data.data;
    }
    if (unpacker) {
      data[rootField] = unpacker(data[rootField]);
    }
    const getPath = [];
    if (rootField) {
      getPath.push(rootField);
    }
    getPath.push(...path6.filter((p) => p !== "select" && p !== "include"));
    return unpack({ document: document2, data, path: getPath });
  }
};
__name(PrismaClientFetcher, "PrismaClientFetcher");

// src/runtime/utils/clientVersion.ts
var clientVersion = require_package2().version;

// src/runtime/utils/mssqlPreparedStatement.ts
var mssqlPreparedStatement = /* @__PURE__ */ __name((template) => {
  return template.reduce((acc, str, idx) => `${acc}@P${idx}${str}`);
}, "mssqlPreparedStatement");

// src/runtime/utils/serializeRawParameters.ts
function serializeRawParameters(data) {
  return JSON.stringify(serializeBigInt(replaceDates(data)));
}
__name(serializeRawParameters, "serializeRawParameters");
function replaceDates(data) {
  const type = Object.prototype.toString.call(data);
  if (type === "[object Date]") {
    return {
      prisma__type: "date",
      prisma__value: data.toJSON()
    };
  }
  if (type === "[object Object]") {
    const tmp = {};
    for (const key in data) {
      if (key !== "__proto__") {
        tmp[key] = replaceDates(data[key]);
      }
    }
    return tmp;
  }
  if (type === "[object Array]") {
    let k = data.length;
    let tmp;
    for (tmp = new Array(k); k--; ) {
      tmp[k] = replaceDates(data[k]);
    }
    return tmp;
  }
  return data;
}
__name(replaceDates, "replaceDates");
function serializeBigInt(data) {
  const type = Object.prototype.toString.call(data);
  if (type === "[object BigInt]") {
    return data.toString();
  }
  if (type === "[object Object]") {
    const tmp = {};
    for (const key in data) {
      if (key !== "__proto__") {
        tmp[key] = serializeBigInt(data[key]);
      }
    }
    return tmp;
  }
  if (type === "[object Array]") {
    let k = data.length;
    let tmp;
    for (tmp = new Array(k); k--; ) {
      tmp[k] = serializeBigInt(data[k]);
    }
    return tmp;
  }
  return data;
}
__name(serializeBigInt, "serializeBigInt");

// src/runtime/utils/validatePrismaClientOptions.ts
var import_js_levenshtein2 = __toModule2(require_js_levenshtein());
var knownProperties = ["datasources", "errorFormat", "log", "__internal", "rejectOnNotFound"];
var errorFormats = ["pretty", "colorless", "minimal"];
var logLevels = ["info", "query", "warn", "error"];
var validators = {
  datasources: (options2, datasourceNames) => {
    if (!options2) {
      return;
    }
    if (typeof options2 !== "object" || Array.isArray(options2)) {
      throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options2)} for "datasources" provided to PrismaClient constructor`);
    }
    for (const [key, value] of Object.entries(options2)) {
      if (!datasourceNames.includes(key)) {
        const didYouMean = getDidYouMean(key, datasourceNames) || `Available datasources: ${datasourceNames.join(", ")}`;
        throw new PrismaClientConstructorValidationError(`Unknown datasource ${key} provided to PrismaClient constructor.${didYouMean}`);
      }
      if (typeof value !== "object" || Array.isArray(value)) {
        throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options2)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
      }
      if (value && typeof value === "object") {
        for (const [key1, value1] of Object.entries(value)) {
          if (key1 !== "url") {
            throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options2)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
          if (typeof value1 !== "string") {
            throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value1)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
        }
      }
    }
  },
  errorFormat: (options2) => {
    if (!options2) {
      return;
    }
    if (typeof options2 !== "string") {
      throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options2)} for "errorFormat" provided to PrismaClient constructor.`);
    }
    if (!errorFormats.includes(options2)) {
      const didYouMean = getDidYouMean(options2, errorFormats);
      throw new PrismaClientConstructorValidationError(`Invalid errorFormat ${options2} provided to PrismaClient constructor.${didYouMean}`);
    }
  },
  log: (options2) => {
    if (!options2) {
      return;
    }
    if (!Array.isArray(options2)) {
      throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options2)} for "log" provided to PrismaClient constructor.`);
    }
    function validateLogLevel(level) {
      if (typeof level === "string") {
        if (!logLevels.includes(level)) {
          const didYouMean = getDidYouMean(level, logLevels);
          throw new PrismaClientConstructorValidationError(`Invalid log level "${level}" provided to PrismaClient constructor.${didYouMean}`);
        }
      }
    }
    __name(validateLogLevel, "validateLogLevel");
    for (const option of options2) {
      validateLogLevel(option);
      const logValidators = {
        level: validateLogLevel,
        emit: (value) => {
          const emits = ["stdout", "event"];
          if (!emits.includes(value)) {
            const didYouMean = getDidYouMean(value, emits);
            throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value)} for "emit" in logLevel provided to PrismaClient constructor.${didYouMean}`);
          }
        }
      };
      if (option && typeof option === "object") {
        for (const [key, value] of Object.entries(option)) {
          if (logValidators[key]) {
            logValidators[key](value);
          } else {
            throw new PrismaClientConstructorValidationError(`Invalid property ${key} for "log" provided to PrismaClient constructor`);
          }
        }
      }
    }
  },
  __internal: (value) => {
    if (!value) {
      return;
    }
    const knownKeys = ["debug", "hooks", "useUds", "engine", "measurePerformance"];
    if (typeof value !== "object") {
      throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value)} for "__internal" to PrismaClient constructor`);
    }
    for (const [key] of Object.entries(value)) {
      if (!knownKeys.includes(key)) {
        const didYouMean = getDidYouMean(key, knownKeys);
        throw new PrismaClientConstructorValidationError(`Invalid property ${JSON.stringify(key)} for "__internal" provided to PrismaClient constructor.${didYouMean}`);
      }
    }
  },
  rejectOnNotFound: (value) => {
    if (!value) {
      return;
    }
    if (isError(value) || typeof value === "boolean" || typeof value === "object" || typeof value === "function") {
      return value;
    }
    throw new PrismaClientConstructorValidationError(`Invalid rejectOnNotFound expected a boolean/Error/{[modelName: Error | boolean]} but received ${JSON.stringify(value)}`);
  }
};
function validatePrismaClientOptions(options2, datasourceNames) {
  for (const [key, value] of Object.entries(options2)) {
    if (!knownProperties.includes(key)) {
      const didYouMean = getDidYouMean(key, knownProperties);
      throw new PrismaClientConstructorValidationError(`Unknown property ${key} provided to PrismaClient constructor.${didYouMean}`);
    }
    validators[key](value, datasourceNames);
  }
}
__name(validatePrismaClientOptions, "validatePrismaClientOptions");
function getDidYouMean(str, options2) {
  if (options2.length === 0) {
    return "";
  }
  if (typeof str !== "string") {
    return "";
  }
  const alternative = getAlternative(str, options2);
  if (!alternative) {
    return "";
  }
  return ` Did you mean "${alternative}"?`;
}
__name(getDidYouMean, "getDidYouMean");
function getAlternative(str, options2) {
  if (options2.length === 0) {
    return null;
  }
  const optionsWithDistances = options2.map((value) => ({
    value,
    distance: (0, import_js_levenshtein2.default)(str, value)
  }));
  optionsWithDistances.sort((a, b) => {
    return a.distance < b.distance ? -1 : 1;
  });
  const bestAlternative = optionsWithDistances[0];
  if (bestAlternative.distance < 3) {
    return bestAlternative.value;
  }
  return null;
}
__name(getAlternative, "getAlternative");

// src/runtime/RequestHandler.ts
var import_debug8 = __toModule2(require_dist7());
var import_strip_ansi5 = __toModule2(require_strip_ansi());
var debug8 = (0, import_debug8.default)("prisma:client:request_handler");
var RequestHandler = class {
  constructor(client, hooks) {
    this.client = client;
    this.hooks = hooks;
    this.dataloader = new DataLoader({
      batchLoader: (requests) => {
        const queries = requests.map((r) => String(r.document));
        return this.client._engine.requestBatch(queries, {
          transactionId: requests[0].transactionId
        });
      },
      singleLoader: (request4) => {
        const query2 = String(request4.document);
        return this.client._engine.request(query2, {
          transactionId: request4.transactionId,
          ...request4.headers
        });
      },
      batchBy: (request4) => {
        if (request4.transactionId) {
          return `transaction-${request4.transactionId}`;
        }
        return batchFindUniqueBy(request4);
      }
    });
  }
  async request({
    document: document2,
    dataPath = [],
    rootField,
    typeName,
    isList,
    callsite,
    rejectOnNotFound,
    clientMethod,
    runInTransaction,
    showColors,
    engineHook,
    args,
    headers,
    transactionId,
    unpacker
  }) {
    if (this.hooks && this.hooks.beforeRequest) {
      const query2 = String(document2);
      this.hooks.beforeRequest({
        query: query2,
        path: dataPath,
        rootField,
        typeName,
        document: document2,
        isList,
        clientMethod,
        args
      });
    }
    try {
      let data, elapsed;
      if (engineHook) {
        const result = await engineHook({
          document: document2,
          runInTransaction
        }, (params) => this.dataloader.request(params));
        data = result.data;
        elapsed = result.elapsed;
      } else {
        const result = await this.dataloader.request({
          document: document2,
          runInTransaction,
          headers,
          transactionId
        });
        data = result?.data;
        elapsed = result?.elapsed;
      }
      const unpackResult = this.unpack(document2, data, dataPath, rootField, unpacker);
      throwIfNotFound(unpackResult, clientMethod, typeName, rejectOnNotFound);
      if (process.env.PRISMA_CLIENT_GET_TIME) {
        return { data: unpackResult, elapsed };
      }
      return unpackResult;
    } catch (e) {
      debug8(e);
      let message = e.message;
      if (callsite) {
        const { stack } = printStack({
          callsite,
          originalMethod: clientMethod,
          onUs: e.isPanic,
          showColors
        });
        message = `${stack}
  ${e.message}`;
      }
      message = this.sanitizeMessage(message);
      if (e.code) {
        throw new PrismaClientKnownRequestError(message, e.code, this.client._clientVersion, e.meta);
      } else if (e.isPanic) {
        throw new PrismaClientRustPanicError(message, this.client._clientVersion);
      } else if (e instanceof PrismaClientUnknownRequestError) {
        throw new PrismaClientUnknownRequestError(message, this.client._clientVersion);
      } else if (e instanceof PrismaClientInitializationError) {
        throw new PrismaClientInitializationError(message, this.client._clientVersion);
      } else if (e instanceof PrismaClientRustPanicError) {
        throw new PrismaClientRustPanicError(message, this.client._clientVersion);
      }
      e.clientVersion = this.client._clientVersion;
      throw e;
    }
  }
  sanitizeMessage(message) {
    if (this.client._errorFormat && this.client._errorFormat !== "pretty") {
      return (0, import_strip_ansi5.default)(message);
    }
    return message;
  }
  unpack(document2, data, path6, rootField, unpacker) {
    if (data?.data) {
      data = data.data;
    }
    if (unpacker) {
      data[rootField] = unpacker(data[rootField]);
    }
    const getPath = [];
    if (rootField) {
      getPath.push(rootField);
    }
    getPath.push(...path6.filter((p) => p !== "select" && p !== "include"));
    return unpack({ document: document2, data, path: getPath });
  }
  get [Symbol.toStringTag]() {
    return "RequestHandler";
  }
};
__name(RequestHandler, "RequestHandler");
function batchFindUniqueBy(request4) {
  if (!request4.document.children[0].name.startsWith("findUnique")) {
    return void 0;
  }
  const args = request4.document.children[0].args?.args.map((a) => {
    if (a.value instanceof Args) {
      return `${a.key}-${a.value.args.map((a2) => a2.key).join(",")}`;
    }
    return a.key;
  }).join(",");
  const selectionSet = request4.document.children[0].children.join(",");
  return `${request4.document.children[0].name}|${args}|${selectionSet}`;
}
__name(batchFindUniqueBy, "batchFindUniqueBy");

// src/runtime/getPrismaClient.ts
var debug9 = (0, import_debug9.default)("prisma:client");
var ALTER_RE = /^(\s*alter\s)/i;
(globalThis = globalThis).NOT_PRISMA_DATA_PROXY = true;
function isReadonlyArray(arg2) {
  return Array.isArray(arg2);
}
__name(isReadonlyArray, "isReadonlyArray");
function checkAlter(query2, values, invalidCall) {
  if (values.length > 0 && ALTER_RE.exec(query2)) {
    throw new Error(`Running ALTER using ${invalidCall} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
}
__name(checkAlter, "checkAlter");
var actionOperationMap = {
  findUnique: "query",
  findFirst: "query",
  findMany: "query",
  count: "query",
  create: "mutation",
  createMany: "mutation",
  update: "mutation",
  updateMany: "mutation",
  upsert: "mutation",
  delete: "mutation",
  deleteMany: "mutation",
  executeRaw: "mutation",
  queryRaw: "mutation",
  aggregate: "query",
  groupBy: "query"
};
var aggregateKeys = {
  _avg: true,
  _count: true,
  _sum: true,
  _min: true,
  _max: true
};
function getPrismaClient(config2) {
  class PrismaClient {
    constructor(optionsArg) {
      this._middlewares = new Middlewares();
      this._transactionId = 1;
      if (optionsArg) {
        validatePrismaClientOptions(optionsArg, config2.datasourceNames);
      }
      this._rejectOnNotFound = optionsArg?.rejectOnNotFound;
      this._clientVersion = config2.clientVersion ?? clientVersion;
      this._activeProvider = config2.activeProvider;
      this._clientEngineType = getClientEngineType(config2.generator);
      const envPaths = {
        rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path4.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
        schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path4.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
      };
      const loadedEnv = tryLoadEnvs(envPaths, { conflictCheck: "none" });
      try {
        const options2 = optionsArg ?? {};
        const internal = options2.__internal ?? {};
        const useDebug = internal.debug === true;
        if (useDebug) {
          import_debug9.default.enable("prisma:client");
        }
        if (internal.hooks) {
          this._hooks = internal.hooks;
        }
        let cwd = path4.resolve(config2.dirname, config2.relativePath);
        if (!fs5.existsSync(cwd)) {
          cwd = config2.dirname;
        }
        const thedatasources = options2.datasources || {};
        const inputDatasources = Object.entries(thedatasources).filter(([_, source]) => {
          return source && source.url;
        }).map(([name, { url: url2 }]) => ({
          name,
          url: url2
        }));
        const datasources = mergeBy([], inputDatasources, (source) => source.name);
        const engineConfig = internal.engine || {};
        if (options2.errorFormat) {
          this._errorFormat = options2.errorFormat;
        } else if (process.env.NODE_ENV === "production") {
          this._errorFormat = "minimal";
        } else if (process.env.NO_COLOR) {
          this._errorFormat = "colorless";
        } else {
          this._errorFormat = "colorless";
        }
        this._dmmf = new DMMFClass(config2.document);
        this._previewFeatures = config2.generator?.previewFeatures ?? [];
        this._engineConfig = {
          cwd,
          dirname: config2.dirname,
          enableDebugLogs: useDebug,
          allowTriggerPanic: engineConfig.allowTriggerPanic,
          datamodelPath: path4.join(config2.dirname, "schema.prisma"),
          prismaPath: engineConfig.binaryPath ?? void 0,
          engineEndpoint: engineConfig.endpoint,
          datasources,
          generator: config2.generator,
          showColors: this._errorFormat === "pretty",
          logLevel: options2.log && getLogLevel(options2.log),
          logQueries: options2.log && Boolean(typeof options2.log === "string" ? options2.log === "query" : options2.log.find((o) => typeof o === "string" ? o === "query" : o.level === "query")),
          env: loadedEnv ? loadedEnv.parsed : config2.inlineEnv?.parsed ?? {},
          flags: [],
          clientVersion: config2.clientVersion,
          previewFeatures: mapPreviewFeatures(this._previewFeatures),
          useUds: internal.useUds,
          activeProvider: config2.activeProvider,
          inlineSchema: config2.inlineSchema,
          inlineDatasources: config2.inlineDatasources,
          inlineSchemaHash: config2.inlineSchemaHash
        };
        if (config2.activeProvider === "mongodb") {
          const previewFeatures = this._engineConfig.previewFeatures ? this._engineConfig.previewFeatures.concat("mongodb") : ["mongodb"];
          this._engineConfig.previewFeatures = previewFeatures;
        }
        debug9(`clientVersion: ${config2.clientVersion}`);
        debug9(`clientEngineType: ${this._clientEngineType}`);
        this._engine = this.getEngine();
        void this._getActiveProvider();
        if (!this._hasPreviewFlag("interactiveTransactions")) {
          this._fetcher = new PrismaClientFetcher(this, false, this._hooks);
        } else {
          this._fetcher = new RequestHandler(this, this._hooks);
        }
        if (options2.log) {
          for (const log4 of options2.log) {
            const level = typeof log4 === "string" ? log4 : log4.emit === "stdout" ? log4.level : null;
            if (level) {
              this.$on(level, (event) => {
                logger_exports.log(`${logger_exports.tags[level] ?? ""}`, event.message || event.query);
              });
            }
          }
        }
        this._bootstrapClient();
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    get [Symbol.toStringTag]() {
      return "PrismaClient";
    }
    getEngine() {
      if (this._clientEngineType === ClientEngineType.Library) {
        return new LibraryEngine(this._engineConfig);
      } else if (this._clientEngineType === ClientEngineType.Binary) {
        return new BinaryEngine(this._engineConfig);
      } else {
        return new DataProxyEngine(this._engineConfig);
      }
    }
    $use(arg0, arg1) {
      if (typeof arg0 === "function") {
        this._middlewares.query.use(arg0);
      } else if (arg0 === "all") {
        this._middlewares.query.use(arg1);
      } else if (arg0 === "engine") {
        this._middlewares.engine.use(arg1);
      } else {
        throw new Error(`Invalid middleware ${arg0}`);
      }
    }
    $on(eventType, callback) {
      if (eventType === "beforeExit") {
        this._engine.on("beforeExit", callback);
      } else {
        this._engine.on(eventType, (event) => {
          const fields = event.fields;
          if (eventType === "query") {
            return callback({
              timestamp: event.timestamp,
              query: fields?.query ?? event.query,
              params: fields?.params ?? event.params,
              duration: fields?.duration_ms ?? event.duration,
              target: event.target
            });
          } else {
            return callback({
              timestamp: event.timestamp,
              message: fields?.message ?? event.message,
              target: event.target
            });
          }
        });
      }
    }
    $connect() {
      try {
        return this._engine.start();
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    async _runDisconnect() {
      await this._engine.stop();
      delete this._connectionPromise;
      this._engine = this.getEngine();
      delete this._disconnectionPromise;
      delete this._getConfigPromise;
    }
    $disconnect() {
      try {
        return this._engine.stop();
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    async _getActiveProvider() {
      try {
        const configResult = await this._engine.getConfig();
        this._activeProvider = configResult.datasources[0].activeProvider;
      } catch (e) {
      }
    }
    $executeRawInternal(runInTransaction, transactionId, query2, ...values) {
      let queryString = "";
      let parameters = void 0;
      if (typeof query2 === "string") {
        queryString = query2;
        parameters = {
          values: serializeRawParameters(values || []),
          __prismaRawParamaters__: true
        };
        checkAlter(queryString, values, "prisma.$executeRawUnsafe(<SQL>, [...values])");
      } else if (isReadonlyArray(query2)) {
        switch (this._activeProvider) {
          case "sqlite":
          case "mysql": {
            const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
            queryString = queryInstance.sql;
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
          case "postgresql": {
            const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
            queryString = queryInstance.text;
            checkAlter(queryString, queryInstance.values, "prisma.$executeRaw`<SQL>`");
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
          case "sqlserver": {
            queryString = mssqlPreparedStatement(query2);
            parameters = {
              values: serializeRawParameters(values),
              __prismaRawParamaters__: true
            };
            break;
          }
        }
      } else {
        switch (this._activeProvider) {
          case "sqlite":
          case "mysql":
            queryString = query2.sql;
            break;
          case "postgresql":
            queryString = query2.text;
            checkAlter(queryString, query2.values, "prisma.$executeRaw(sql`<SQL>`)");
            break;
          case "sqlserver":
            queryString = mssqlPreparedStatement(query2.strings);
            break;
        }
        parameters = {
          values: serializeRawParameters(query2.values),
          __prismaRawParamaters__: true
        };
      }
      if (parameters?.values) {
        debug9(`prisma.$executeRaw(${queryString}, ${parameters.values})`);
      } else {
        debug9(`prisma.$executeRaw(${queryString})`);
      }
      const args = { query: queryString, parameters };
      debug9(`Prisma Client call:`);
      return this._request({
        args,
        clientMethod: "executeRaw",
        dataPath: [],
        action: "executeRaw",
        callsite: this._getCallsite(),
        runInTransaction,
        transactionId
      });
    }
    $executeRawRequest(query2, ...values) {
      const request4 = /* @__PURE__ */ __name((transactionId, runInTransaction) => {
        try {
          const promise = this.$executeRawInternal(runInTransaction ?? false, transactionId, query2, ...values);
          promise.isExecuteRaw = true;
          return promise;
        } catch (e) {
          e.clientVersion = this._clientVersion;
          throw e;
        }
      }, "request");
      return createPrismaPromise(request4);
    }
    $executeRaw(query2, ...values) {
      return createPrismaPromise(() => {
        if (query2.raw || query2.sql) {
          return this.$executeRawRequest(query2, ...values);
        }
        throw new PrismaClientValidationError(`\`$executeRaw\` is a tag function, please use it like the following:
\`\`\`
const result = await prisma.$executeRaw\`UPDATE User SET cool = \${true} WHERE email = \${'user@email.com'};\`
\`\`\`

Or read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw
`);
      });
    }
    $executeRawUnsafe(query2, ...values) {
      return this.$executeRawRequest(query2, ...values);
    }
    _getCallsite() {
      if (this._errorFormat !== "minimal") {
        return new Error().stack;
      }
      return void 0;
    }
    $queryRawInternal(runInTransaction, transactionId, query2, ...values) {
      let queryString = "";
      let parameters = void 0;
      if (typeof query2 === "string") {
        queryString = query2;
        parameters = {
          values: serializeRawParameters(values || []),
          __prismaRawParamaters__: true
        };
      } else if (isReadonlyArray(query2)) {
        switch (this._activeProvider) {
          case "sqlite":
          case "mysql": {
            const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
            queryString = queryInstance.sql;
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
          case "postgresql": {
            const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
            queryString = queryInstance.text;
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
          case "sqlserver": {
            const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
            queryString = mssqlPreparedStatement(queryInstance.strings);
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
        }
      } else {
        switch (this._activeProvider) {
          case "sqlite":
          case "mysql":
            queryString = query2.sql;
            break;
          case "postgresql":
            queryString = query2.text;
            break;
          case "sqlserver":
            queryString = mssqlPreparedStatement(query2.strings);
            break;
        }
        parameters = {
          values: serializeRawParameters(query2.values),
          __prismaRawParamaters__: true
        };
      }
      if (parameters?.values) {
        debug9(`prisma.queryRaw(${queryString}, ${parameters.values})`);
      } else {
        debug9(`prisma.queryRaw(${queryString})`);
      }
      const args = { query: queryString, parameters };
      debug9(`Prisma Client call:`);
      return this._request({
        args,
        clientMethod: "queryRaw",
        dataPath: [],
        action: "queryRaw",
        callsite: this._getCallsite(),
        runInTransaction,
        transactionId
      });
    }
    $queryRawRequest(query2, ...values) {
      const request4 = /* @__PURE__ */ __name((transactionId, runInTransaction) => {
        try {
          const promise = this.$queryRawInternal(runInTransaction ?? false, transactionId, query2, ...values);
          promise.isQueryRaw = true;
          return promise;
        } catch (e) {
          e.clientVersion = this._clientVersion;
          throw e;
        }
      }, "request");
      return createPrismaPromise(request4);
    }
    $queryRaw(query2, ...values) {
      return createPrismaPromise(() => {
        if (query2.raw || query2.sql) {
          return this.$queryRawRequest(query2, ...values);
        }
        throw new PrismaClientValidationError(`\`$queryRaw\` is a tag function, please use it like the following:
\`\`\`
const result = await prisma.$queryRaw\`SELECT * FROM User WHERE id = \${1} OR email = \${'user@email.com'};\`
\`\`\`

Or read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw
`);
      });
    }
    $queryRawUnsafe(query2, ...values) {
      return this.$queryRawRequest(query2, ...values);
    }
    __internal_triggerPanic(fatal) {
      if (!this._engineConfig.allowTriggerPanic) {
        throw new Error(`In order to use .__internal_triggerPanic(), please enable it like so:
new PrismaClient({
  __internal: {
    engine: {
      allowTriggerPanic: true
    }
  }
})`);
      }
      const headers = fatal ? { "X-DEBUG-FATAL": "1" } : { "X-DEBUG-NON-FATAL": "1" };
      return this._request({
        action: "queryRaw",
        args: {
          query: "SELECT 1",
          parameters: void 0
        },
        clientMethod: "queryRaw",
        dataPath: [],
        runInTransaction: false,
        headers,
        callsite: this._getCallsite()
      });
    }
    ___getTransactionId() {
      return this._transactionId++;
    }
    async $___transactionInternal(promises) {
      for (const p of promises) {
        if (!p) {
          throw new Error(`All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`);
        }
        if ((!p.requestTransaction || typeof p.requestTransaction !== "function") && !p?.isQueryRaw && !p?.isExecuteRaw) {
          throw new Error(`All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`);
        }
      }
      const transactionId = this.___getTransactionId();
      const requests = await Promise.all(promises.map((p) => {
        if (p.requestTransaction) {
          return p.requestTransaction(transactionId);
        } else {
        }
        return p;
      }));
      return Promise.all(requests.map((r) => {
        if (Object.prototype.toString.call(r) === "[object Promise]") {
          return r;
        }
        if (r && typeof r === "function") {
          return r();
        }
        return r;
      }));
    }
    async $___transaction(promises) {
      try {
        return this.$___transactionInternal(promises);
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    $transaction(input, options2) {
      if (!this._hasPreviewFlag("interactiveTransactions")) {
        return this.$___transaction(input);
      }
      try {
        return this._transaction(input, options2);
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    async _transaction(input, options2) {
      if (typeof input === "function") {
        return this._transactionWithCallback(input, options2);
      }
      return this._transactionWithRequests(input, options2);
    }
    async _transactionWithCallback(callback, options2) {
      const info2 = await this._engine.transaction("start", options2);
      let result;
      try {
        result = await callback(transactionProxy(this, info2.id));
        await this._engine.transaction("commit", info2);
      } catch (e) {
        await this._engine.transaction("rollback", info2);
        throw e;
      }
      return result;
    }
    async _transactionWithRequests(requests, options2) {
      return this._transactionWithCallback(async (prisma) => {
        const transactionId = prisma[TX_ID];
        const _requests = requests.map((request4) => {
          return new Promise((resolve2, reject2) => {
            ;
            request4.then(resolve2, reject2, transactionId);
          });
        });
        return Promise.all(_requests);
      }, options2);
    }
    _request(internalParams) {
      try {
        const params = {
          args: internalParams.args,
          dataPath: internalParams.dataPath,
          runInTransaction: internalParams.runInTransaction,
          action: internalParams.action,
          model: internalParams.model
        };
        let index = -1;
        const consumer = /* @__PURE__ */ __name((changedParams) => {
          const nextMiddleware = this._middlewares.query.get(++index);
          if (nextMiddleware) {
            return nextMiddleware(changedParams, consumer);
          }
          const changedInternalParams = { ...internalParams, ...params };
          if (index > 0 && !this._hasPreviewFlag("interactiveTransactions")) {
            delete changedInternalParams["transactionId"];
          }
          return this._executeRequest(changedInternalParams);
        }, "consumer");
        if (true) {
          const resource = new AsyncResource("prisma-client-request");
          return resource.runInAsyncScope(() => consumer(params));
        }
        return consumer(params);
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    _executeRequest({
      args,
      clientMethod,
      dataPath,
      callsite,
      runInTransaction,
      action,
      model,
      headers,
      transactionId,
      unpacker
    }) {
      if (action !== "executeRaw" && action !== "queryRaw" && !model) {
        throw new Error(`Model missing for action ${action}`);
      }
      if ((action === "executeRaw" || action === "queryRaw") && model) {
        throw new Error(`executeRaw and queryRaw can't be executed on a model basis. The model ${model} has been provided`);
      }
      let rootField;
      const operation = actionOperationMap[action];
      if (action === "executeRaw" || action === "queryRaw") {
        rootField = action;
      }
      let mapping;
      if (model) {
        mapping = this._dmmf.mappingsMap[model];
        if (!mapping) {
          throw new Error(`Could not find mapping for model ${model}`);
        }
        rootField = mapping[action];
      }
      if (operation !== "query" && operation !== "mutation") {
        throw new Error(`Invalid operation ${operation} for action ${action}`);
      }
      const field = this._dmmf.rootFieldMap[rootField];
      if (!field) {
        throw new Error(`Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`);
      }
      const { isList } = field.outputType;
      const typeName = getOutputTypeName(field.outputType.type);
      const rejectOnNotFound = getRejectOnNotFound(action, typeName, args, this._rejectOnNotFound);
      let document2 = makeDocument({
        dmmf: this._dmmf,
        rootField,
        rootTypeName: operation,
        select: args
      });
      document2.validate(args, false, clientMethod, this._errorFormat, callsite);
      document2 = transformDocument(document2);
      if (import_debug9.default.enabled("prisma:client")) {
        const query2 = String(document2);
        debug9(`Prisma Client call:`);
        debug9(`prisma.${clientMethod}(${printJsonWithErrors({
          ast: args,
          keyPaths: [],
          valuePaths: [],
          missingItems: []
        })})`);
        debug9(`Generated request:`);
        debug9(query2 + "\n");
      }
      return this._fetcher.request({
        document: document2,
        clientMethod,
        typeName,
        dataPath,
        rejectOnNotFound,
        isList,
        rootField,
        callsite,
        showColors: this._errorFormat === "pretty",
        args,
        engineHook: this._middlewares.engine.get(0),
        runInTransaction,
        headers,
        transactionId,
        unpacker
      });
    }
    _bootstrapClient() {
      const modelClientBuilders = this._dmmf.mappings.modelOperations.reduce((modelClientBuilders2, modelMapping) => {
        const lowerCaseModel = lowerCase(modelMapping.model);
        const model = this._dmmf.modelMap[modelMapping.model];
        if (!model) {
          throw new Error(`Invalid mapping ${modelMapping.model}, can't find model`);
        }
        const ModelClientBuilder = /* @__PURE__ */ __name(({
          operation,
          actionName,
          args,
          dataPath,
          modelName,
          unpacker
        }) => {
          let requestPromise;
          const callsite = this._getCallsite();
          const request4 = /* @__PURE__ */ __name((transactionId, runInTransaction) => {
            requestPromise = requestPromise ?? this._request({
              args,
              model: modelName ?? model.name,
              action: actionName,
              clientMethod: `${lowerCaseModel}.${actionName}`,
              dataPath,
              callsite,
              runInTransaction: runInTransaction ?? false,
              transactionId,
              unpacker
            });
            return requestPromise;
          }, "request");
          const modelClient = createPrismaPromise(request4);
          for (const field of model.fields.filter((f) => f.kind === "object")) {
            modelClient[field.name] = (fieldArgs) => {
              const prefix = dataPath.includes("select") ? "select" : dataPath.includes("include") ? "include" : "select";
              const newDataPath = [...dataPath, prefix, field.name];
              const newArgs = deepSet(args, newDataPath, fieldArgs || true);
              return modelClientBuilders2[field.type]({
                operation,
                actionName,
                args: newArgs,
                dataPath: newDataPath,
                isList: field.isList,
                modelName: modelName || model.name
              });
            };
          }
          return modelClient;
        }, "ModelClientBuilder");
        modelClientBuilders2[model.name] = ModelClientBuilder;
        return modelClientBuilders2;
      }, {});
      for (const mapping of this._dmmf.mappings.modelOperations) {
        const lowerCaseModel = lowerCase(mapping.model);
        const filteredActionsList = {
          model: true,
          plural: true,
          aggregate: true,
          groupBy: true
        };
        const delegate = Object.keys(mapping).reduce((acc, actionName) => {
          if (!filteredActionsList[actionName]) {
            const operation = getOperation(actionName);
            acc[actionName] = (args) => modelClientBuilders[mapping.model]({
              operation,
              actionName,
              dataPath: [],
              args
            });
          }
          return acc;
        }, {});
        delegate.count = (args) => {
          let select;
          let unpacker;
          if (args?.select && typeof args?.select === "object") {
            select = { _count: { select: args.select } };
          } else {
            select = { _count: { select: { _all: true } } };
            unpacker = /* @__PURE__ */ __name((data) => {
              data._count = data._count?._all;
              return data;
            }, "unpacker");
          }
          return modelClientBuilders[mapping.model]({
            operation: "query",
            actionName: `aggregate`,
            args: {
              ...args ?? {},
              select
            },
            dataPath: ["_count"],
            unpacker
          });
        };
        delegate.aggregate = (args) => {
          let unpacker = void 0;
          const select = Object.entries(args).reduce((acc, [key, value]) => {
            if (aggregateKeys[key]) {
              if (!acc.select) {
                acc.select = {};
              }
              if (key === "_count" || key === "count") {
                if (typeof value === "object" && value) {
                  acc.select[key] = { select: value };
                } else {
                  acc.select[key] = { select: { _all: value } };
                  unpacker = /* @__PURE__ */ __name((data) => {
                    if (data._count) {
                      data._count = data._count?._all;
                    } else if (data.count) {
                      data.count = data.count?._all;
                    }
                    return data;
                  }, "unpacker");
                }
              } else {
                acc.select[key] = { select: value };
              }
            } else {
              acc[key] = value;
            }
            return acc;
          }, {});
          return modelClientBuilders[mapping.model]({
            operation: "query",
            actionName: "aggregate",
            rootField: mapping.aggregate,
            args: select,
            dataPath: [],
            unpacker
          });
        };
        delegate.groupBy = (args) => {
          let unpacker = void 0;
          const select = Object.entries(args).reduce((acc, [key, value]) => {
            if (aggregateKeys[key]) {
              if (!acc.select) {
                acc.select = {};
              }
              acc.select[key] = { select: value };
            } else {
              acc[key] = value;
            }
            if (key === "_count") {
              if (typeof value === "object" && value) {
                acc.select[key] = { select: value };
              } else if (typeof value === "boolean") {
                acc.select[key] = { select: { _all: value } };
                unpacker = /* @__PURE__ */ __name((data) => {
                  if (Array.isArray(data)) {
                    data = data.map((row) => {
                      if (row && typeof row._count === "object" && row._count?._all) {
                        row._count = row._count?._all;
                      }
                      return row;
                    });
                  }
                  return data;
                }, "unpacker");
              }
            }
            if (key === "by" && Array.isArray(value) && value.length > 0) {
              if (!acc.select) {
                acc.select = {};
              }
              for (const by of value) {
                acc.select[by] = true;
              }
            }
            return acc;
          }, {});
          return modelClientBuilders[mapping.model]({
            operation: "query",
            actionName: "groupBy",
            rootField: mapping.groupBy,
            args: select,
            dataPath: [],
            unpacker
          });
        };
        this[lowerCaseModel] = delegate;
      }
    }
    _hasPreviewFlag(feature) {
      return !!this._engineConfig.previewFeatures?.includes(feature);
    }
  }
  __name(PrismaClient, "PrismaClient");
  return PrismaClient;
}
__name(getPrismaClient, "getPrismaClient");
var TX_ID = Symbol.for("prisma.client.transaction.id");
var forbidden = ["$connect", "$disconnect", "$on", "$transaction", "$use"];
function transactionProxy(thing, transactionId) {
  if (typeof thing !== "object")
    return thing;
  return new Proxy(thing, {
    get: (target, prop) => {
      if (forbidden.includes(prop))
        return void 0;
      if (prop === TX_ID)
        return transactionId;
      if (typeof target[prop] === "function") {
        return (...args) => {
          if (prop === "then") {
            return target[prop](...args, transactionId);
          }
          return transactionProxy(target[prop](...args), transactionId);
        };
      }
      return transactionProxy(target[prop], transactionId);
    }
  });
}
__name(transactionProxy, "transactionProxy");
function createPrismaPromise(callback) {
  const _callback = /* @__PURE__ */ __name((transactionId, runInTransaction) => {
    try {
      return callback(transactionId, runInTransaction);
    } catch (error2) {
      return Promise.reject(error2);
    }
  }, "_callback");
  return {
    then(onFulfilled, onRejected, transactionId) {
      const promise = _callback(transactionId, false);
      return promise.then(onFulfilled, onRejected, transactionId);
    },
    catch(onRejected) {
      return _callback().catch(onRejected);
    },
    finally(onFinally) {
      return _callback().finally(onFinally);
    },
    requestTransaction(transactionId) {
      const promise = _callback(transactionId, true);
      if (promise.requestTransaction) {
        return promise.requestTransaction(transactionId);
      }
      return promise;
    },
    [Symbol.toStringTag]: "PrismaPromise"
  };
}
__name(createPrismaPromise, "createPrismaPromise");
function getOperation(action) {
  if (action === DMMF.ModelAction.findMany || action === DMMF.ModelAction.findUnique || action === DMMF.ModelAction.findFirst) {
    return "query";
  }
  return "mutation";
}
__name(getOperation, "getOperation");

// src/runtime/index.ts
var import_sql_template_tag = __toModule2(require_dist10());

// src/runtime/warnEnvConflicts.ts
function warnEnvConflicts(envPaths) {
  tryLoadEnvs(envPaths, { conflictCheck: "warn" });
}
__name(warnEnvConflicts, "warnEnvConflicts");

// src/runtime/utils/find.ts
import fs6 from "fs";
import path5 from "path";
import { promisify as promisify2 } from "util";
var readdirAsync = promisify2(fs6.readdir);
var realpathAsync = promisify2(fs6.realpath);
var statAsync = promisify2(fs6.stat);
var readdirSync = fs6.readdirSync;
var realpathSync = fs6.realpathSync;
var statSync = fs6.statSync;
function direntToType(dirent) {
  return dirent.isFile() ? "f" : dirent.isDirectory() ? "d" : dirent.isSymbolicLink() ? "l" : void 0;
}
__name(direntToType, "direntToType");
function isMatched(string, regexs) {
  for (const regex of regexs) {
    if (typeof regex === "string") {
      if (string.includes(regex)) {
        return true;
      }
    } else if (regex.exec(string)) {
      return true;
    }
  }
  return false;
}
__name(isMatched, "isMatched");
function findSync(root, match, types = ["f", "d", "l"], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {
  try {
    const realRoot = realpathSync(root);
    if (seen[realRoot]) {
      return found;
    }
    if (limit - found.length <= 0) {
      return found;
    }
    if (direntToType(statSync(realRoot)) !== "d") {
      return found;
    }
    const items = readdirSync(root, { withFileTypes: true });
    seen[realRoot] = true;
    for (const item of items) {
      const itemName = item.name;
      const itemType = direntToType(item);
      const itemPath = path5.join(root, item.name);
      if (itemType && types.includes(itemType)) {
        if (isMatched(itemPath, match)) {
          const value = handler(root, itemName, itemType);
          if (typeof value === "string") {
            found.push(value);
          } else if (value === true) {
            found.push(itemPath);
          }
        }
      }
      if (deep.includes(itemType)) {
        findSync(itemPath, match, types, deep, limit, handler, found, seen);
      }
    }
  } catch {
  }
  return found;
}
__name(findSync, "findSync");

// src/runtime/index.ts
var lzString = __toModule2(require_lz_string());
var decompressFromBase642 = lzString.decompressFromBase64;
var export_Sql = import_sql_template_tag.Sql;
var export_empty = import_sql_template_tag.empty;
var export_join = import_sql_template_tag.join;
var export_raw = import_sql_template_tag.raw;
var export_sqltag = import_sql_template_tag.sqltag;
export {
  DMMF,
  DMMFClass,
  decimal_default as Decimal,
  Engine,
  PrismaClientInitializationError,
  PrismaClientKnownRequestError,
  PrismaClientRustPanicError,
  PrismaClientUnknownRequestError,
  PrismaClientValidationError,
  export_Sql as Sql,
  decompressFromBase642 as decompressFromBase64,
  export_empty as empty,
  findSync,
  getPrismaClient,
  export_join as join,
  makeDocument,
  export_raw as raw,
  export_sqltag as sqltag,
  transformDocument,
  unpack,
  warnEnvConflicts
};
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
